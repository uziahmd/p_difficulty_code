{
    "start": 1758296469.2848778,
    "end": 1758299382.6487527,
    "start-formatted": "2025-09-20 00:41 KST",
    "end-formatted": "2025-09-20 01:29 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We are to find a non-negative integer k such that the LCM of (a+k) and (b+k) is minimized, and if there are multiple k with the same minimal LCM, choose the smallest k.\n\n Let d = (a+k) and e = (b+k). Then note that d - e = a - b (constant). Without loss of generality, assume a >= b. Then we can let g = gcd(a+k, b+k). Then note that g must divide (a-b). Also, we have:\n   LCM(a+k, b+k) = (a+k)*(b+k) / g\n\n But note: (a+k) = (b+k) + (a-b). So the difference between the two numbers is fixed (a-b). However, we can also consider symmetry: if a < b, then we can swap the roles.\n\n Alternatively, we can set x = k, and note that the two numbers are (a+x) and (b+x). The LCM of two numbers u and v is |u*v| / gcd(u,v). Since they are positive, we can write:\n\n   LCM(a+x, b+x) = (a+x)*(b+x) / gcd(a+x, b+x)\n\n We know that gcd(a+x, b+x) = gcd(a+x, (a+x)-(b+x)) = gcd(a+x, a-b). Similarly, if we set d = |a-b|, then the gcd divides d.\n\n Therefore, the problem reduces to: for each divisor g of |a-b| (if a != b), we can set g = gcd(a+x, b+x) and then note that g must divide d = |a-b|. Moreover, for a fixed divisor g, we require that:\n   g divides (a+x) and g divides (b+x).\n\n But since g divides (a+x) and (a+x) - (b+x) = a-b, then g divides (a-b). So we consider all divisors of |a-b| (if a==b, then the problem is trivial because k=0 gives the same numbers and LCM is (a)(a)/a = a, and any k would give the same? Actually, note: when a=b, then we have two same numbers so LCM(a+k, a+k)=a+k, which is minimized at k=0).\n\n However, note: if a==b, then we return 0.\n\n Now, for a fixed divisor g (which divides d = |a-b|), we can set up the condition that:\n   (a+x) mod g == 0   and   (b+x) mod g == 0.\n\n This means that x must be congruent to (-a) mod g and (-b) mod g. But note: since (a+x) and (b+x) are congruent modulo g (because their difference is divisible by g, which it is because g divides d and d = a-b), then we require that x ≡ (-a) mod g and x ≡ (-b) mod g. But these two conditions are consistent because (a-b) is divisible by g. So we need to solve:\n   x ≡ r (mod g)\n where r is the remainder such that (a+x) % g == 0, i.e., x ≡ (-a) mod g.\n\n The smallest non-negative x satisfying this is x0 = (g - a % g) % g, but note: if a % g is 0 then x0=0. However, wait: what if we use negative modulo? We want the smallest non-negative k.\n\n Actually, we can compute the smallest non-negative k for modulus g as:\n   k0 = (-a) % g   [this gives the smallest non-negative residue]\n\n But note: (-a) % g is the same as (g - (a % g)) % g, but if a % g == 0 then (-a)%g is 0.\n\n However, note: we have two conditions: one from a and one from b. But they are consistent because g divides (a-b). So we only need one equation.\n\n Steps:\n\n 1. If a == b, then answer is 0.\n\n 2. Otherwise, let d = abs(a-b). Then consider all divisors of d (both positive and negative? but note g is positive divisor). Actually, we consider positive divisors.\n\n 3. For each divisor g of d (positive divisors):\n      candidate_k = (-a) % g   [this gives the smallest non-negative k that satisfies (a+k) % g == 0]\n      But note: we also require that (b+k) % g == 0. However, since g divides d (i.e., g divides a-b) and",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the difference between \\( a + k \\) and \\( b + k \\) is constant (\\( |a - b| \\)). The LCM of two numbers \\( u \\) and \\( v \\) can be expressed as \\( \\frac{u \\times v}{\\gcd(u, v)} \\). To minimize the LCM, we need to maximize the greatest common divisor (gcd) of \\( a + k \\) and \\( b + k \\), since the product \\( (a + k) \\times (b + k) \\) increases with \\( k \\).\n\n2. **Insight**: The gcd of \\( a + k \\) and \\( b + k \\) must divide the absolute difference \\( |a - b| \\). Therefore, for each divisor \\( g \\) of \\( |a - b| \\), we can compute the smallest \\( k \\) such that \\( g \\) divides both \\( a + k \\) and \\( b + k \\). This \\( k \\) is given by \\( (-a) \\% g \\).\n\n3. **Algorithm Selection**: \n   - If \\( a = b \\), the answer is trivially 0.\n   - Otherwise, factorize \\( |a - b| \\) to find all its divisors.\n   - For each divisor \\( g \\), compute the candidate \\( k \\) as \\( (-a) \\% g \\).\n   - Among all candidate \\( k \\) values, select the one that minimizes the LCM of \\( a + k \\) and \\( b + k \\). If multiple \\( k \\) values yield the same minimal LCM, choose the smallest \\( k \\).\n\n4. **Complexity Analysis**: The algorithm involves factorizing \\( |a - b| \\), which has a time complexity of \\( O(\\sqrt{n}) \\) where \\( n = |a - b| \\). Given the constraints \\( 1 \\leq a, b \\leq 10^9 \\), this approach is efficient as \\( \\sqrt{10^9} \\) is around \\( 3 \\times 10^4 \\).\n\n### Solution Code\n```python\nimport math\n\ndef main():\n    a, b = map(int, input().split())\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    best_k = 0\n    best_lcm = (a + best_k) * (b + best_k) // math.gcd(a + best_k, b + best_k)\n    \n    for g in divisors:\n        k_candidate = (-a) % g\n        num1 = a + k_candidate\n        num2 = b + k_candidate\n        current_gcd = math.gcd(num1, num2)\n        current_lcm = num1 * num2 // current_gcd\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k_candidate\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads two integers \\( a \\) and \\( b \\).\n2. **Special Case Handling**: If \\( a \\) equals \\( b \\), it immediately prints 0 since the LCM is minimized at \\( k = 0 \\).\n3. **Divisor Calculation**: The absolute difference \\( |a - b| \\) is computed, and all its divisors are found by checking up to the square root of the difference.\n4. **Candidate Evaluation**: For each divisor \\( g \\), the smallest \\( k \\) (non-negative) such that \\( g \\) divides both \\( a + k \\) and \\( b + k \\) is calculated using \\( (-a) \\% g \\). The LCM for this \\( k \\) is then computed.\n5. **Optimal \\( k \\) Selection**: The candidate \\( k \\) with the smallest LCM is selected. If multiple \\( k \\) values yield the same LCM, the smallest \\( k \\) is chosen by default due to the iteration order and selection logic.\n\nThis approach efficiently narrows down the possible values of \\( k \\) by leveraging mathematical properties of divisors and gcd, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef main():\n    a, b = map(int, input().split())\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    best_k = 0\n    best_lcm = (a + best_k) * (b + best_k) // math.gcd(a + best_k, b + best_k)\n    \n    for g in divisors:\n        k_candidate = (-a) % g\n        num1 = a + k_candidate\n        num2 = b + k_candidate\n        current_gcd = math.gcd(num1, num2)\n        current_lcm = num1 * num2 // current_gcd\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k_candidate\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 397,
        "completion_token_count": 1026,
        "thoughts_token_count": 1023
    }
}