{
    "start": 1758296011.145613,
    "end": 1758298601.3108482,
    "start-formatted": "2025-09-20 00:33 KST",
    "end-formatted": "2025-09-20 01:16 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We are to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized.\n\n Let d = a - b. Without loss of generality, assume a <= b, then we can set d = b - a (if negative, we swap). But note: the problem does not specify which is larger.\n\n Alternatively, let g = gcd(a+k, b+k). Then note:\n   (a+k) * (b+k) = LCM(a+k, b+k) * GCD(a+k, b+k)\n\n However, we can also note that the difference between (a+k) and (b+k) is fixed: |(a+k) - (b+k)| = |a-b|.\n\n Let d = |a-b|. Then, for any k, we have:\n   gcd(a+k, b+k) = gcd(a+k, d)\n\n Why? Because gcd(x, y) = gcd(x, y-x). So gcd(a+k, b+k) = gcd(a+k, b-a) [if b>=a] or gcd(b+k, a-b) if a>=b.\n\n Therefore, let d = abs(a-b). Then the gcd of (a+k) and (b+k) is the same as the gcd of (a+k) and d.\n\n Now, note that the LCM is (a+k)*(b+k) / gcd(a+k, b+k). Since (a+k)*(b+k) grows with k, but the gcd might change and can be large, we need to consider different k's that make the gcd large (so that the denominator is large and the LCM becomes smaller).\n\n However, note that k must be chosen so that the LCM is minimized. The key observation:\n\n   Let g = gcd(a+k, b+k). Then g divides d (because g divides both (a+k) and (b+k), hence divides their difference d). So g is a divisor of d.\n\n Also, we require that g divides (a+k) and (b+k). But note: (a+k) mod d might be related.\n\n Alternate approach:\n\n   Consider: For each divisor g of d (where d = |a-b|), we can set k such that:\n        (a+k) ≡ 0 (mod g)   and   (b+k) ≡ 0 (mod g)\n\n   But note: (a+k) ≡ 0 (mod g) => k ≡ (-a) mod g.\n   Similarly, (b+k) ≡ 0 (mod g) => k ≡ (-b) mod g.\n\n   So we require k ≡ (-a) mod g and k ≡ (-b) mod g. Since g divides d, note that (-a) ≡ (-b) mod g? \n        Actually, because d = |a-b| is divisible by g, then a ≡ b (mod g). So (-a) ≡ (-b) (mod g). Therefore, the congruences are compatible.\n\n   Therefore, for each divisor g of d, we can set k to be the smallest non-negative integer satisfying:\n        k ≡ (-a) mod g   (which is equivalent to k ≡ (g - a % g) % g, but if we use modulo we have to be careful)\n\n   However, note: we can also think of k as the smallest non-negative solution to k ≡ r (mod g) where r = (-a) mod g, but note that (-a) mod g is the same as (g - a % g) % g? Actually, we can compute:\n\n        Let r = (-a) % g. Then k_min = r if r < g? Actually, k_min = (g - a % g) % g, but wait:\n\n        We want k such that (a+k) % g == 0. Then k = (g - a % g) if a % g != 0, and if a % g == 0 then k=0.\n\n        But note: if a % g == 0, then k=0 satisfies the condition. Otherwise, k = g - (a % g) is the smallest positive k that satisfies the condition (but note: k must be non-negative, and 0 is allowed). However, we must also satisfy the condition for b? But since g divides d and a ≡ b (mod g), then the same k will work for b.\n\n   Therefore, for each divisor g of d (considering positive divisors), we can compute candidate k_g = (g - a % g) % g. However, note: if (a % g) == 0, then k_g = 0. Otherwise, k_g = g - (a % g). But wait: is",
    "response": "\nTo solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a+k \\) and \\( b+k \\) is minimized. The key observation here is that the difference between \\( a+k \\) and \\( b+k \\) is fixed as \\( |a - b| \\). This difference allows us to leverage the properties of the greatest common divisor (GCD) to efficiently determine the optimal \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The LCM of two numbers \\( x \\) and \\( y \\) is given by \\( \\text{LCM}(x, y) = \\frac{x \\cdot y}{\\text{GCD}(x, y)} \\). To minimize the LCM, we need to maximize the GCD of \\( (a+k) \\) and \\( (b+k) \\), since the product \\( (a+k) \\times (b+k) \\) increases with \\( k \\). However, directly computing the LCM for all possible \\( k \\) is infeasible due to the constraints \\( 1 \\leq a, b \\leq 10^9 \\).\n\n2. **Key Insight**: The GCD of \\( (a+k) \\) and \\( (b+k) \\) must divide their difference \\( |a - b| \\). Therefore, the possible values of the GCD are the divisors of \\( |a - b| \\). For each divisor \\( g \\) of \\( |a - b| \\), we can compute the smallest \\( k \\) such that \\( g \\) divides both \\( (a + k) \\) and \\( (b + k) \\). This \\( k \\) is derived from the congruence \\( k \\equiv (-a) \\mod g \\).\n\n3. **Algorithm Selection**: \n   - Compute the absolute difference \\( d = |a - b| \\).\n   - Find all divisors of \\( d \\).\n   - For each divisor \\( g \\), compute the smallest \\( k \\) that satisfies \\( (a + k) \\mod g = 0 \\). This \\( k \\) is \\( (g - (a \\% g)) \\% g \\).\n   - Among all computed \\( k \\) values, select the one that minimizes the LCM of \\( (a + k) \\) and \\( (b + k) \\). If multiple \\( k \\) values yield the same minimal LCM, choose the smallest \\( k \\).\n\n4. **Complexity Analysis**: The number of divisors of \\( d \\) is \\( O(\\sqrt{d}) \\), which is efficient even for \\( d \\) up to \\( 10^9 \\). Each divisor requires constant time operations, making the overall complexity manageable.\n\n### Solution Code\n```python\nimport math\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    candidates = []\n    for g in divisors:\n        remainder = a % g\n        if remainder == 0:\n            k_candidate = 0\n        else:\n            k_candidate = g - (a % g)\n        candidates.append(k_candidate)\n        \n    best_k = None\n    best_lcm = None\n    \n    for k in candidates:\n        x = a + k\n        y = b + k\n        current_lcm = (x * y) // math.gcd(x, y)\n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k < best_k):\n            best_k = k\n            best_lcm = current_lcm\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads two integers \\( a \\) and \\( b \\). If they are equal, the answer is immediately \\( 0 \\) since the LCM of two identical numbers is the number itself.\n2. **Divisor Calculation**: The absolute difference \\( d \\) between \\( a \\) and \\( b \\) is computed. All divisors of \\( d \\) are found by checking each integer up to \\( \\sqrt{d} \\).\n3. **Candidate Generation**: For each divisor \\( g \\), the smallest \\( k \\) that makes \\( (a + k) \\) divisible by \\( g \\) is calculated. This \\( k \\) ensures that \\( \\text{GCD}(a + k, b + k) \\) is at least \\( g \\).\n4. **Optimal \\( k \\) Selection**: The LCM of \\( (a + k) \\) and \\( (b + k) \\) is computed for each candidate \\( k \\). The smallest \\( k \\) yielding the minimal LCM is selected and printed.\n\nThis approach efficiently narrows down the search space using mathematical properties of divisors and GCD, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    candidates = []\n    for g in divisors:\n        remainder = a % g\n        if remainder == 0:\n            k_candidate = 0\n        else:\n            k_candidate = g - (a % g)\n        candidates.append(k_candidate)\n        \n    best_k = None\n    best_lcm = None\n    \n    for k in candidates:\n        x = a + k\n        y = b + k\n        current_lcm = (x * y) // math.gcd(x, y)\n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k < best_k):\n            best_k = k\n            best_lcm = current_lcm\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 396,
        "completion_token_count": 1107,
        "thoughts_token_count": 1023
    }
}