{
    "start": 1758294368.0456154,
    "end": 1758296038.1847725,
    "start-formatted": "2025-09-20 00:06 KST",
    "end-formatted": "2025-09-20 00:33 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given R and B (each between 1 and 10) and then R lines for rebels and B lines for bases.\n We need to assign each base to exactly one rebel and each rebel to exactly one base (perfect matching) such that:\n   - The straight line from the base to its assigned rebel does not intersect any other such line.\n\n Since the total number of points (R+B) is at most 20, we can consider using a bipartite matching algorithm that also checks for non-intersecting conditions.\n\n However, note: the problem requires that no two straight paths (from base to its rebel) intersect. This condition is equivalent to: \n   The set of segments connecting the bases to the rebels must be non-crossing.\n\n But note: the assignment is a perfect matching from rebels to bases (so |R| = |B|? Actually, the input says first two integers R and B, and then R lines for rebels and B lines for bases. So if R != B, then it's impossible? However, the example inputs have R=B.\n\n Let me check the problem statement: \"assign R Rebel spaceships to guard B bases\" and \"every base has exactly one guardian and each spaceship has exactly one assigned base\" -> so this implies that R must equal B. But the input guarantees 1<=R,B<=10, and the example inputs have R=B.\n\n However, the problem does not explicitly say that R must equal B, but the condition of perfect matching requires that. So if R != B, then we output 'No' because there's no perfect matching.\n\n But wait: the example input format: first line \"3 3\", then 3 rebels and 3 bases. Then the second example: \"2 1\" meaning R=2, B=1 -> so they are different.\n\n Therefore, step 1: if R != B, then output 'No'.\n\n Now, if R == B, we have a set of R rebels and R bases (total 2R points). We need to form a matching (a bijection) from rebels to bases such that the segments connecting each base to its rebel do not cross.\n\n How to check if two segments (base1->rebel1) and (base2->rebel2) cross?\n   Two segments (p1, q1) and (p2, q2) cross if and only if the points p1, q1, p2, q2 are in cyclic order (like p1, p2, q1, q2) or (p1, q2, p2, q1) when traversing the boundary.\n\n However, note: the problem says \"any two (straight) paths – from a base to its assigned spaceship – do not intersect\". Also note that the entire set of segments must be non-crossing.\n\n There's an alternative way: we can use the concept of planar matching. One common approach is to fix an ordering of the rebels (or bases) and then check for crossings.\n\n Since R is at most 10, we can try all permutations (which would be factorial(10)=3628800, which is acceptable in worst-case for R=10, but note that we have to check for crossing in each matching).\n\n Steps:\n\n 1. Read R and B.\n 2. If R != B, output 'No'.\n 3. Otherwise, read R rebel points and B base points (which are R base points since R==B).\n 4. Generate all permutations of base indices (or assign rebels in a fixed order and permute base assignments). Alternatively, we can fix the rebels in a particular order (say, sorted by x-coordinate) and then consider all assignments of bases (which is a permutation of base points). But note: the condition is independent of the labeling? Actually, the condition of non-crossing depends on the positions.\n\n However, note: the problem does not require that the rebels and bases are labeled in any particular way. But we can fix the rebels in increasing order of x (if tie, then y) and then consider all matchings (permutations of bases) and check for non-crossing.\n\n But wait: what if we fix the rebels in an arbitrary order? Actually, the non-crossing condition is independent of the order of the rebels? No, the condition is about the segments. However, we can fix the order of the rebels arbitrarily (because we are going to assign a base to each) and then check the matching.\n\n Alternatively, we can fix the order of the rebels by their coordinates (for example, sort by x, and if same x then by y) and then consider the base points as they are. Then, we consider all permutations of base points (which is R! possibilities). For each permutation, we assign the i-th rebel to the i-th base in the permutation.\n\n Then, we have a set of segments: (rebel_i",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between a set of Rebel spaceships and bases such that the straight-line segments connecting each base to its assigned spaceship do not intersect. The solution involves checking all possible permutations of assignments and verifying the non-intersection condition for each permutation.\n\n### Approach\n1. **Problem Analysis**: The problem requires assigning each base to exactly one rebel spaceship (and vice versa) such that the connecting segments do not intersect. Given the constraints (R and B are at most 10), a brute-force approach is feasible.\n2. **Key Insight**: The non-intersection condition can be checked by ensuring that no two segments cross each other. Two segments (p1, q1) and (p2, q2) cross if the points are in cyclic order when traversing the boundary around the intersection point.\n3. **Algorithm Selection**: \n   - **Check for Perfect Matching**: If the number of rebels (R) does not equal the number of bases (B), output \"No\".\n   - **Generate Permutations**: For R = B, generate all possible permutations of base assignments to rebels.\n   - **Check Non-Intersection**: For each permutation, check if the connecting segments between bases and rebels intersect. If any permutation satisfies the condition, output \"Yes\"; otherwise, output \"No\".\n\n### Solution Code\n```python\nimport itertools\n\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    it = iter(data)\n    R = int(next(it))\n    B = int(next(it))\n    \n    if R != B:\n        print(\"No\")\n        return\n        \n    rebels = []\n    for _ in range(R):\n        x = int(next(it))\n        y = int(next(it))\n        rebels.append((x, y))\n        \n    bases = []\n    for _ in range(B):\n        x = int(next(it))\n        y = int(next(it))\n        bases.append((x, y))\n        \n    def ccw(A, B, C):\n        return (C[1]-A[1]) * (B[0]-A[0]) > (B[1]-A[1]) * (C[0]-A[0])\n        \n    def do_segments_intersect(A, B, C, D):\n        o1 = ccw(A, B, C)\n        o2 = ccw(A, B, D)\n        o3 = ccw(C, D, A)\n        o4 = ccw(C, D, B)\n        if (o1 != o2) and (o3 != o4):\n            return True\n        return False\n        \n    bases_permutations = list(itertools.permutations(bases))\n    found = False\n    \n    for perm in bases_permutations:\n        valid = True\n        n = len(rebels)\n        for i in range(n):\n            for j in range(i+1, n):\n                seg1 = (rebels[i], perm[i])\n                seg2 = (rebels[j], perm[j])\n                if do_segments_intersect(seg1[0], seg1[1], seg2[0], seg2[1]):\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if valid:\n            found = True\n            break\n            \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into integers R (number of rebels) and B (number of bases). If R and B are not equal, the answer is immediately \"No\" since a perfect matching is impossible.\n2. **Reading Coordinates**: The coordinates of rebels and bases are stored in lists.\n3. **Counter-Clockwise (ccw) Check**: The `ccw` function checks if three points are in counter-clockwise order, which is essential for determining segment intersections.\n4. **Segment Intersection Check**: The `do_segments_intersect` function uses the `ccw` function to determine if two segments intersect.\n5. **Permutations Check**: All permutations of base assignments are generated. For each permutation, the code checks if any pair of segments (from rebels to bases) intersect. If a valid permutation is found where no segments intersect, the answer is \"Yes\"; otherwise, it's \"No\".\n\nThis approach efficiently checks all possible assignments and ensures the non-intersection condition is met, leveraging combinatorial generation and geometric properties to solve the problem.",
    "ground_truth": "N/A",
    "extracted_answer": "import itertools\n\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    it = iter(data)\n    R = int(next(it))\n    B = int(next(it))\n    \n    if R != B:\n        print(\"No\")\n        return\n        \n    rebels = []\n    for _ in range(R):\n        x = int(next(it))\n        y = int(next(it))\n        rebels.append((x, y))\n        \n    bases = []\n    for _ in range(B):\n        x = int(next(it))\n        y = int(next(it))\n        bases.append((x, y))\n        \n    def ccw(A, B, C):\n        return (C[1]-A[1]) * (B[0]-A[0]) > (B[1]-A[1]) * (C[0]-A[0])\n        \n    def do_segments_intersect(A, B, C, D):\n        o1 = ccw(A, B, C)\n        o2 = ccw(A, B, D)\n        o3 = ccw(C, D, A)\n        o4 = ccw(C, D, B)\n        if (o1 != o2) and (o3 != o4):\n            return True\n        return False\n        \n    bases_permutations = list(itertools.permutations(bases))\n    found = False\n    \n    for perm in bases_permutations:\n        valid = True\n        n = len(rebels)\n        for i in range(n):\n            for j in range(i+1, n):\n                seg1 = (rebels[i], perm[i])\n                seg2 = (rebels[j], perm[j])\n                if do_segments_intersect(seg1[0], seg1[1], seg2[0], seg2[1]):\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if valid:\n            found = True\n            break\n            \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 480,
        "completion_token_count": 941,
        "thoughts_token_count": 1023
    }
}