{
    "start": 1758088076.665457,
    "end": 1758089193.8251336,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:06 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given n and x (the total desired duration) and then n lines of [l, r, cost]\n Each voucher has duration = r - l + 1.\n\n Conditions:\n We need two distinct vouchers i and j such that:\n   (duration_i + duration_j == x) and the two intervals [li, ri] and [lj, rj] do not intersect (at least one condition: ri < lj or rj < li).\n\n We want the minimal total cost.\n\n Approach:\n\n Since x can be up to 200,000 and the number of vouchers is up to 200,000, we cannot try all pairs.\n\n Idea:\n Let d = duration of a voucher = r-l+1.\n\n We are looking for two durations d1 and d2 such that d1+d2 = x.\n\n Then we need to consider two types of non-overlapping conditions:\n   Condition 1: [l1, r1] and [l2, r2] with r1 < l2 (voucher1 ends before voucher2 starts)\n   Condition 2: [l2, r2] and [l1, r1] with r2 < l1 (voucher2 ends before voucher1 starts)\n\n However, note that the two conditions are symmetric. So without loss of generality, we can consider:\n\n   Case 1: The first voucher ends before the second starts (r1 < l2)\n   Case 2: The second voucher ends before the first starts (r2 < l1)\n\n But note: the problem does not specify which voucher is taken first. However, the condition for non-intersection is symmetric.\n\n Steps:\n\n 1. We can group vouchers by their duration. But note: same duration might appear multiple times, and we have two conditions (order matters for non-overlapping).\n\n 2. Alternatively, we can precompute for each duration d (from 1 to max_d, which is at most 200000) the best (lowest) cost for a voucher of duration d, but also we must consider the intervals.\n\n However, the non-overlapping condition depends on the actual intervals (l and r). So we need to know the earliest start and latest end? Actually, we need to know the positions.\n\n Alternate approach:\n\n Let's define two arrays (or dictionaries) for the two cases:\n\n Case 1: Voucher A (first) must end before B (second) starts -> so we require rA < lB.\n\n We can fix the two durations: d1 and d2 such that d1+d2 = x.\n\n Then for all vouchers with duration d1, we want the one that ends as early as possible (to leave room for the next) and for d2, we want the one that starts as late as possible? Not exactly: because we can choose any two.\n\n Actually, we want to minimize the total cost. So we can:\n\n   Precompute for each duration d:\n     Option1: We want to know for a voucher of duration d, what is the minimal cost and also the minimal starting day? Actually, we need to know the entire interval [l, r] for the voucher.\n\n But note: the condition is about the entire interval. We can store for each duration d a list of (l, r, cost) and then sort by l or by r? \n\n However, the constraints are high (n up to 200000, and d from 1 to 200000). We cannot iterate over every d from 1 to 200000 and then over every other d' = x-d.\n\n Instead, we can:\n\n   Step 1: Group vouchers by duration. For each duration d, we want to store:\n        - The minimal cost for a voucher of duration d.\n        - But wait: maybe there are multiple vouchers with same duration and different intervals. However, we are allowed to pick two. So we need to consider all combinations.\n\n   However, note: two vouchers of the same duration might be used together if x = 2*d and they don't overlap. But also, we might combine two different durations.\n\n   But the problem: we need two distinct vouchers, and the condition of non-overlap.\n\n   Alternate plan:\n\n   We can precompute for each duration d the best (minimal) cost and also the minimal starting day and maximal ending day? Actually, we need to know the intervals to check non-overlap.\n\n   However, we can use two separate structures:\n\n   We will create two lists:\n\n     List1: For case 1 (voucher1 ends before voucher2 starts) we want for a fixed duration d1 (which is part of the pair) to have a voucher that ends as early as possible (so we can have a voucher2 that starts after that). Similarly, for the other voucher (duration d2) we want one that starts as late as possible?",
    "response": "\nTo solve this problem, we need to find two distinct travel vouchers such that their combined duration equals exactly `x` days, they do not overlap in time, and their total cost is minimized. The solution involves efficiently processing the vouchers grouped by their durations and then checking for non-overlapping pairs.\n\n### Approach\n1. **Group Vouchers by Duration**: We first group all vouchers by their duration. For each duration, we store the minimal cost and the earliest departure day (minimal `l`) and latest return day (maximal `r`) among all vouchers of that duration. This helps in quickly identifying the most cost-effective and time-efficient vouchers for any given duration.\n\n2. **Check Valid Pairs**: For each possible duration `d`, we check if there exists another duration `x - d` such that their combination sums to `x`. For each valid pair of durations `(d, x-d)`, we consider two cases:\n   - **Case 1**: A voucher of duration `d` ends before a voucher of duration `x-d` starts.\n   - **Case 2**: A voucher of duration `x-d` ends before a voucher of duration `d` starts.\n   \n   For each case, we use the precomputed minimal cost and earliest/latest days to determine if a valid pair exists and what their combined cost would be.\n\n3. **Minimize Total Cost**: We keep track of the minimal total cost encountered during the checks. If no valid pair is found, we return `-1`.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        cost_val = int(data[index+2])\n        index += 3\n        vouchers.append((l, r, cost_val))\n    \n    max_day = 400000\n    min_cost_by_duration = {}\n    min_l_by_duration = {}\n    max_r_by_duration = {}\n    \n    for l, r, cost_val in vouchers:\n        d = r - l + 1\n        if d not in min_cost_by_duration:\n            min_cost_by_duration[d] = cost_val\n            min_l_by_duration[d] = l\n            max_r_by_duration[d] = r\n        else:\n            if cost_val < min_cost_by_duration[d]:\n                min_cost_by_duration[d] = cost_val\n                min_l_by_duration[d] = l\n                max_r_by_duration[d] = r\n            else:\n                if l < min_l_by_duration[d]:\n                    min_l_by_duration[d] = l\n                if r > max_r_by_duration[d]:\n                    max_r_by_duration[d] = r\n\n    ans = float('inf')\n    used = set()\n    for d in list(min_cost_by_duration.keys()):\n        d_other = x - d\n        if d_other not in min_cost_by_duration or d in used:\n            continue\n        used.add(d)\n        used.add(d_other)\n        \n        # Case 1: d voucher ends before d_other starts\n        r1 = max_r_by_duration[d]\n        l2_min = min_l_by_duration[d_other]\n        if r1 < l2_min:\n            total_cost = min_cost_by_duration[d] + min_cost_by_duration[d_other]\n            if total_cost < ans:\n                ans = total_cost\n                \n        # Case 2: d_other voucher ends before d voucher starts\n        r2 = max_r_by_duration[d_other]\n        l1_min = min_l_by_duration[d]\n        if r2 < l1_min:\n            total_cost = min_cost_by_duration[d] + min_cost_by_duration[d_other]\n            if total_cost < ans:\n                ans = total_cost\n                \n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each characterized by departure day, return day, and cost.\n2. **Grouping Vouchers**: Vouchers are grouped by their duration. For each duration, we store the minimal cost, earliest departure day, and latest return day among all vouchers of that duration.\n3. **Checking Valid Pairs**: For each duration `d`, we check if there exists a duration `x - d`. For each valid pair, we verify if one voucher ends before the other starts, ensuring they do not overlap. The minimal cost for valid pairs is tracked.\n4. **Output Result**: If a valid pair is found, the minimal total cost is printed; otherwise, `-1` is printed indicating no valid pair exists.\n\nThis approach efficiently narrows down the search space by leveraging grouping and precomputation, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        cost_val = int(data[index+2])\n        index += 3\n        vouchers.append((l, r, cost_val))\n    \n    max_day = 400000\n    min_cost_by_duration = {}\n    min_l_by_duration = {}\n    max_r_by_duration = {}\n    \n    for l, r, cost_val in vouchers:\n        d = r - l + 1\n        if d not in min_cost_by_duration:\n            min_cost_by_duration[d] = cost_val\n            min_l_by_duration[d] = l\n            max_r_by_duration[d] = r\n        else:\n            if cost_val < min_cost_by_duration[d]:\n                min_cost_by_duration[d] = cost_val\n                min_l_by_duration[d] = l\n                max_r_by_duration[d] = r\n            else:\n                if l < min_l_by_duration[d]:\n                    min_l_by_duration[d] = l\n                if r > max_r_by_duration[d]:\n                    max_r_by_duration[d] = r\n\n    ans = float('inf')\n    used = set()\n    for d in list(min_cost_by_duration.keys()):\n        d_other = x - d\n        if d_other not in min_cost_by_duration or d in used:\n            continue\n        used.add(d)\n        used.add(d_other)\n        \n        # Case 1: d voucher ends before d_other starts\n        r1 = max_r_by_duration[d]\n        l2_min = min_l_by_duration[d_other]\n        if r1 < l2_min:\n            total_cost = min_cost_by_duration[d] + min_cost_by_duration[d_other]\n            if total_cost < ans:\n                ans = total_cost\n                \n        # Case 2: d_other voucher ends before d voucher starts\n        r2 = max_r_by_duration[d_other]\n        l1_min = min_l_by_duration[d]\n        if r2 < l1_min:\n            total_cost = min_cost_by_duration[d] + min_cost_by_duration[d_other]\n            if total_cost < ans:\n                ans = total_cost\n                \n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 734,
        "completion_token_count": 1033,
        "thoughts_token_count": 1023
    }
}