{
    "start": 1758296445.3957944,
    "end": 1758299383.4252422,
    "start-formatted": "2025-09-20 00:40 KST",
    "end-formatted": "2025-09-20 01:29 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We are to find a non-negative integer k such that the LCM(a+k, b+k) is minimized, and if there are multiple k's achieving the same minimal LCM, choose the smallest k.\n\n Observation:\n Let d = gcd(a+k, b+k). Then, note that d divides (a+k) and (b+k). Also, note that d divides (b+k - (a+k)) = b - a (if a != b). So, when a != b, the difference d must be a divisor of |a-b|.\n\n However, note that k can be chosen arbitrarily. The idea is to consider divisors of |a-b|. But note: if a == b, then we have the same number, so LCM(a+k, a+k) = a+k, and we want to minimize a+k. The minimal value is achieved at k=0.\n\n For a != b, let g = gcd(a+k, b+k). Then, since g divides |a-b|, we can consider divisors of |a-b|. However, note that k is related to the divisor by:\n\n We require that g divides both (a+k) and (b+k). This means that k ≡ (-a) mod g and k ≡ (-b) mod g. Since g divides |a-b|, we can set g to be a divisor of |a-b| (including negative divisors? but divisors are positive).\n\n Actually, we can consider all divisors d of |a-b|. Then, for each divisor d (which will be our candidate for the gcd in the expression), we can set:\n\n   k ≡ (-a) mod d   and   k ≡ (-b) mod d\n\n But note: if d divides both a+k and b+k, then d divides (a+k) and (b+k). Also, note that d must divide |a-b| (because d divides (a+k) and (b+k), so it divides their difference).\n\n However, we can also consider that for a fixed divisor d of |a-b|, we require that d divides (a+k) and (b+k). Then, k must be chosen so that (a+k) is divisible by d and (b+k) is divisible by d. This is equivalent to:\n\n   k ≡ (-a) mod d   and   k ≡ (-b) mod d.\n\n But note: if d divides |a-b|, then (a mod d) and (b mod d) are related. In fact, (a mod d) must equal (b mod d) because d divides (a-b). So the congruences are consistent. Then the smallest non-negative k satisfying both is:\n\n   k = (ceil(-a/d)) * d + (-a % d) doesn't work directly.\n\n Alternatively, we can write:\n\n   Let r = a % d. Then we require k ≡ (-a) mod d, which is equivalent to k ≡ (d - r) mod d if r != 0, but note that if r==0 then k must be 0 mod d. However, we can also use:\n\n   k_min = (d - (a % d)) % d   if a % d != 0, but if a % d == 0 then k_min=0? Actually, if a % d == 0, then k_min=0 is one solution. But wait: we also require (b+k) divisible by d. Since d divides (a-b), then if d divides a, then it divides b as well? Not necessarily: because d divides (a-b) and if d divides a then d divides (a-b+a) = 2a - b, but that doesn't imply d divides b. \n\n Actually, note: d divides (a-b) and d divides a implies d divides (a-b+a)=2a-b, but we don't know about b. However, from the condition that d divides both a+k and b+k, and k is chosen to satisfy both, we can also consider:\n\n   We require k >= 0 and k ≡ (-a) mod d and k ≡ (-b) mod d. But since d divides (a-b), then a ≡ b (mod d). Therefore, (-a) ≡ (-b) mod d, so the two congruences are the same. Thus, we only need one: k ≡ (-a) mod d.\n\n Then the smallest non-negative k for divisor d is:\n\n   k0 = (-a) mod d\n\n But note: the modulo operation for negative numbers: we can compute k0 = (d - (a % d)) % d, but wait:\n\n   Let r = a % d. Then if r==0, then k0=0. Otherwise, k",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that for any \\( k \\), the difference between \\( a + k \\) and \\( b + k \\) is \\( |a - b| \\). The greatest common divisor (GCD) of \\( a + k \\) and \\( b + k \\) must be a divisor of \\( |a - b| \\). Therefore, we can consider all divisors of \\( |a - b| \\) to determine potential candidates for \\( k \\).\n\n2. **Insight**: For each divisor \\( d \\) of \\( |a - b| \\), the smallest non-negative \\( k \\) that satisfies \\( (a + k) \\% d == 0 \\) and \\( (b + k) \\% d == 0 \\) is given by \\( k = (-a) \\% d \\). However, since \\( d \\) divides \\( |a - b| \\), the congruences \\( (a + k) \\% d == 0 \\) and \\( (b + k) \\% d == 0 \\) are equivalent. Thus, we only need to ensure \\( (a + k) \\% d == 0 \\).\n\n3. **Algorithm Selection**: \n   - If \\( a == b \\), the minimal LCM is achieved when \\( k = 0 \\).\n   - Otherwise, for each divisor \\( d \\) of \\( |a - b| \\), compute the candidate \\( k \\) as \\( (-a) \\% d \\). The LCM for this \\( k \\) can be derived from \\( \\frac{(a + k) \\times (b + k)}{\\gcd(a + k, b + k)} \\). However, since \\( \\gcd(a + k, b + k) \\) might not be directly known, we use the fact that \\( \\gcd(a + k, b + k) = \\gcd(a + k, |a - b|) \\).\n\n4. **Optimization**: Instead of computing the LCM for every candidate \\( k \\) explicitly, we can leverage the relationship between \\( k \\), \\( d \\), and the GCD to efficiently determine the minimal LCM without additional computational overhead.\n\n5. **Complexity Analysis**: The number of divisors of \\( |a - b| \\) is \\( O(\\sqrt{|a - b|}) \\), which is efficient given the constraints \\( 1 \\leq a, b \\leq 10^9 \\).\n\n### Solution Code\n```python\nimport math\n\ndef main():\n    a, b = map(int, input().split())\n    \n    if a == b:\n        print(0)\n        return\n        \n    n = abs(a - b)\n    divisors = []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n        i += 1\n        \n    best_k = None\n    best_lcm = None\n    \n    for d in divisors:\n        k = (-a) % d\n        num1 = a + k\n        num2 = b + k\n        g = math.gcd(num1, num2)\n        current_lcm = num1 * num2 // g\n        \n        if best_lcm is None or current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k\n        elif current_lcm == best_lcm and k < best_k:\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads two integers \\( a \\) and \\( b \\) from standard input.\n2. **Special Case Handling**: If \\( a \\) equals \\( b \\), the solution is trivially \\( k = 0 \\) because the LCM of \\( a + k \\) and \\( a + k \\) is minimized at \\( k = 0 \\).\n3. **Divisor Calculation**: For \\( a \\neq b \\), the code calculates all divisors of \\( |a - b| \\). These divisors are potential candidates for the GCD of \\( a + k \\) and \\( b + k \\).\n4. **Candidate Evaluation**: For each divisor \\( d \\), the smallest non-negative \\( k \\) satisfying \\( (a + k) \\% d == 0 \\) is computed. The LCM for this \\( k \\) is then calculated and compared to the current best LCM.\n5. **Result Selection**: The smallest \\( k \\) yielding the minimal LCM is printed. If multiple \\( k \\) values yield the same minimal LCM, the smallest \\( k \\) is chosen.\n\nThis approach efficiently narrows down the candidates for \\( k \\) by leveraging mathematical properties of divisors and GCD, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef main():\n    a, b = map(int, input().split())\n    \n    if a == b:\n        print(0)\n        return\n        \n    n = abs(a - b)\n    divisors = []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n        i += 1\n        \n    best_k = None\n    best_lcm = None\n    \n    for d in divisors:\n        k = (-a) % d\n        num1 = a + k\n        num2 = b + k\n        g = math.gcd(num1, num2)\n        current_lcm = num1 * num2 // g\n        \n        if best_lcm is None or current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k\n        elif current_lcm == best_lcm and k < best_k:\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 397,
        "completion_token_count": 1107,
        "thoughts_token_count": 1023
    }
}