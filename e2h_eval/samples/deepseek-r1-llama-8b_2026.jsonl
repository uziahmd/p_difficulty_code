{"task_id": "E2H_CF1031A", "completion": "import sys\n\ndef golden_plate():\n    w, h, k = map(int, input().split())\n\n    total_cells = 0\n    for i in range(1, k + 1):\n        inner_w = w - 4 * (i - 1)\n        inner_h = h - 4 * (i - 1)\n        if inner_w > 0 and inner_h > 0:\n            total_cells += (inner_w + inner_h) * 2 - 4 * i + 1\n\n    print(total_cells)\n\nif __name__ == \"__main__\":\n    for _ in range(int(input())):\n        golden_plate()"}
{"task_id": "E2H_CF404A", "completion": "import sys\n\ndef read_input():\n    n = int(input())\n    grid = []\n    for _ in range(n):\n        grid.append(input().strip())\n    return n, grid\n\ndef check_x(n, grid):\n    diagonal1 = [grid[i][i] for i in range(n)]\n    diagonal2 = [grid[i][n - i - 1] for i in range(n)]\n\n    if len(set(diagonal1)) == 1 and len(set(diagonal2)) == 1:\n        middle_letter = grid[n // 2][n // 2]\n        for i in range(n):\n            for j in range(n):\n                if (i == j or i + j == n - 1) and grid[i][j] != middle_letter:\n                    return False\n                elif (i != j and i + j != n - 1) and grid[i][j] != diagonal1[0]:\n                    return False\n        return True\n    else:\n        return False\n\ndef main():\n    n, grid = read_input()\n    result = \"YES\" if check_x(n, grid) else \"NO\"\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF492B", "completion": "import sys\n\ndef read_input():\n    n, l = map(int, input().split())\n    a = list(map(int, input().split()))\n    return n, l, a\n\ndef solve(n, l, a):\n    a.sort()\n    max_dist = 0\n    for i in range(1, n):\n        max_dist = max(max_dist, a[i] - a[i-1])\n    if a[0] == 0:\n        max_dist = max(max_dist, a[-1])\n    else:\n        max_dist = max(max_dist, l - a[-1], a[0])\n    return max_dist / 2\n\ndef main():\n    n, l, a = read_input()\n    print(f\"{solve(n, l, a):.10f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF173A", "completion": "import sys\n\ndef read_input():\n    n = int(input())\n    a = input()\n    b = input()\n    return n, a, b\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(n, a, b):\n    m = len(a)\n    k = len(b)\n    lcm_val = lcm(m, k)\n    red_spots_a = 0\n    red_spots_b = 0\n\n    for i in range(1, n + 1):\n        a_index = (i - 1) % m\n        b_index = (i - 1) % k\n\n        if a[a_index] == b[b_index]:\n            continue\n        elif (a[a_index] == 'R' and b[b_index] == 'S') or \\\n             (a[a_index] == 'S' and b[b_index] == 'P') or \\\n             (a[a_index] == 'P' and b[b_index] == 'R'):\n            red_spots_b += 1\n        else:\n            red_spots_a += 1\n\n    print(red_spots_a, red_spots_b)\n\nif __name__ == \"__main__\":\n    n, a, b = read_input()\n    solve(n, a, b)"}
{"task_id": "E2H_CF1141D", "completion": "import sys\n\ndef read_input():\n    n = int(input())\n    l = input()\n    r = input()\n    return n, l, r\n\ndef solve(n, l, r):\n    freq = {}\n    for i in range(n):\n        if l[i] != '?' and r[i] != '?':\n            if l[i] not in freq or r[i] not in freq[l[i]]:\n                freq[l[i]] = {l[i]: 1}\n            elif freq[l[i]][l[i]] < 2:\n                freq[l[i]][l[i]] += 1\n        elif l[i] == '?' or r[i] == '?':\n            if l[i] != '?' and r[i] not in freq:\n                freq[r[i]] = {r[i]: 1}\n            elif r[i] != '?' and l[i] not in freq:\n                freq[l[i]] = {l[i]: 1}\n            elif r[i] != '?' and l[i] in freq and r[i] not in freq[l[i]]:\n                freq[l[i]][r[i]] = 1\n            elif l[i] != '?' and r[i] in freq and l[i] not in freq[r[i]]:\n                freq[r[i]][l[i]] = 1\n    pairs = []\n    for k in freq:\n        if len(freq[k]) > 1:\n            sorted_freq = sorted(freq[k].items(), key=lambda x: (-x[1], x[0]))\n            for i in range(1, len(sorted_freq)):\n                if sorted_freq[i][1] == 1:\n                    pairs.append((sorted_freq[i-1][0], sorted_freq[i][0]))\n                    sorted_freq[i-1] = (sorted_freq[i-1][0], sorted_freq[i-1][1] - 1)\n                    sorted_freq[i] = (sorted_freq[i][0], sorted_freq[i][1] - 1)\n    for k in freq:\n        if len(freq[k]) == 1:\n            pairs.append((k, list(freq[k].keys())[0]))\n    return pairs\n\ndef main():\n    n, l, r = read_input()\n    pairs = solve(n, l, r)\n    print(len(pairs))\n    for pair in pairs:\n        print(*pair)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF822C", "completion": "import sys\n\ndef read_input():\n    n, x = map(int, input().split())\n    vouchers = []\n    for _ in range(n):\n        li, ri, costi = map(int, input().split())\n        vouchers.append((li, ri, costi))\n    return n, x, vouchers\n\ndef solve(n, x, vouchers):\n    vouchers.sort(key=lambda x: (x[0], x[1]))\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if vouchers[i][1] < vouchers[j][0] or vouchers[j][1] < vouchers[i][0]:\n                duration = vouchers[i][1] - vouchers[i][0] + 1 + vouchers[j][1] - vouchers[j][0] + 1\n                if duration == x:\n                    min_cost = min(min_cost, vouchers[i][2] + vouchers[j][2])\n    return min_cost if min_cost != float('inf') else -1\n\ndef main():\n    n, x, vouchers = read_input()\n    result = solve(n, x, vouchers)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1846E2", "completion": "import sys\n\ndef solve():\n    n = int(input())\n    k = 2\n    while k <= 10**6:\n        if n == 1:\n            return \"NO\"\n        x = k + 1\n        y = k + 1\n        t = 1\n        while True:\n            t += 1\n            if x > n or y > n:\n                break\n            x += (k - 1) * t\n            y += (k - 1) * t\n        if x == n or y == n:\n            return \"YES\"\n        k += 1\n    return \"NO\"\n\nt = int(input().strip())\nfor _ in range(t):\n    print(solve())"}
{"task_id": "E2H_CF270E", "completion": "from collections import deque\n\ndef read_input():\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, c = map(int, input().split())\n        graph[u].append((v, c))\n        graph[v].append((u, c))\n    return n, graph\n\ndef bfs(graph, parent):\n    visited = [False] * (len(graph) + 1)\n    queue = deque()\n    queue.append(1)\n    visited[1] = True\n    while queue:\n        node = queue.popleft()\n        for neighbor, _ in graph[node]:\n            if not visited[neighbor]:\n                queue.append(neighbor)\n                visited[neighbor] = True\n                parent[neighbor] = node\n    return visited\n\ndef solve(n, graph):\n    parent = [-1] * (n + 1)\n    bfs_result = bfs(graph, parent)\n    if not bfs_result[n]:\n        raise ValueError(\"Graph is not connected\")\n    edges = []\n    for i in range(2, n):\n        if bfs_result[i]:\n            edges.extend([(i, parent[i]) for _ in range(graph[i][0][1])])\n    return edges\n\ndef write_output(edges):\n    edge_index = {}\n    for i, (u, v) in enumerate(edges):\n        edge_index[(u, v)] = i\n        edge_index[(v, u)] = i\n    directions = [0] * len(edges)\n    for i, (u, v) in enumerate(edges):\n        directions[i] = int(u == 1 or v == n)\n    for direction in directions:\n        print(direction)\n\nif __name__ == \"__main__\":\n    n, graph = read_input()\n    edges = solve(n, graph)\n    write_output(edges)"}
{"task_id": "E2H_CF808E", "completion": "import sys\n\ndef solve(n, m, items):\n    # Sort the items by weight-to-cost ratio in descending order\n    items.sort(key=lambda x: (x[0], -x[1]))\n\n    max_cost = 0\n    current_weight = 0\n\n    for item in items:\n        if current_weight + item[0] <= m:\n            current_weight += item[0]\n            max_cost += item[1]\n\n    return max_cost\n\nif __name__ == \"__main__\":\n    input_lines = sys.stdin.read().splitlines()\n    n, m = map(int, input_lines[0].split())\n    items = []\n\n    for i in range(1, n + 1):\n        wi, ci = map(int, input_lines[i].split())\n        items.append((wi, ci))\n\n    results = []\n    for _ in range(1):\n        result = solve(n, m, items)\n        results.append(str(result))\n\n    print('\\n'.join(results))"}
{"task_id": "E2H_CF409I", "completion": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef parse_befunge_string(s):\n    instructions = []\n    i = 0\n    while i < len(s):\n        if s[i] == ':':\n            i += 1\n            c = ''\n            while i < len(s) and s[i].isalnum():\n                c += s[i]\n                i += 1\n            instructions.append(c)\n        else:\n            i += 1\n    return instructions\n\ndef parse_instruction(instruction):\n    ops = {\n        '+': lambda x, y: (x + y) % 10,\n        '-': lambda x, y: (x - y) % 10,\n        '*': lambda x, y: (x * y) % 10,\n        '/': lambda x, y: (x // y) % 10,\n        '>': lambda x, y: (x + 1) % 10,\n        '<': lambda x, y: (x - 1) % 10\n    }\n    stack = []\n    for c in instruction:\n        if c in ops:\n            b = stack.pop()\n            a = stack.pop()\n            stack.append(ops[c](a, b))\n        else:\n            stack.append(int(c))\n    return stack[0]\n\ndef feed_golorp(s):\n    instructions = parse_befunge_string(s)\n    jaw_shape = [0] * len(instructions)\n    for i in range(len(instructions)):\n        if instructions[i] == ':':\n            continue\n        jaw_shape[i] = 1\n    jaw_width = sum(jaw_shape)\n    jaw_height = len(instructions)\n    jaw_depth = max(i + 1 for i, x in enumerate(jaw_shape) if x)\n\n    values = [[0] * jaw_width for _ in range(jaw_height)]\n    for i in range(jaw_depth):\n        for j in range(jaw_width):\n            for k in range(jaw_height):\n                if jaw_shape[k * jaw_width + j]:\n                    values[k][j] = parse_instruction(instructions[k * jaw_width + j])\n\n    min_value = float('inf')\n    min_sequence = None\n    for i in range(10 ** jaw_depth):\n        sequence = []\n        value = i\n        for d in range(jaw_depth):\n            digit = value % 10\n            sequence.append(str(digit))\n            value //= 10\n        valid = True\n        for h in range(jaw_height):\n            for w in range(jaw_width):\n                if jaw_shape[h * jaw_width + w]:\n                    calculated_value = values[h][w]\n                    expected_value = int(sequence[w])\n                    if calculated_value != expected_value:\n                        valid = False\n                        break\n            if not valid:\n                break\n        if valid and int(''.join(sequence)) < min_value:\n            min_value = int(''.join(sequence))\n            min_sequence = sequence\n    if min_sequence is None:\n        return 'false'\n    return ''.join(min_sequence)\n\nif __name__ == '__main__':\n    s = read_input()\n    print(feed_golorp(s))"}
{"task_id": "E2H_CF151A", "completion": "import sys\n\ndef soft_drinking():\n    n, k, l, c, d, p, nl, np = map(int, input().split())\n\n    toasts_with_drink = k * l // (nl * n)\n    toasts_with_lime = c * d // n\n    toasts_with_salt = p // (np * n)\n\n    print(min(toasts_with_drink, toasts_with_lime, toasts_with_salt))\n\nif __name__ == \"__main__\":\n    soft_drinking()"}
{"task_id": "E2H_CF339B", "completion": "import sys\n\ndef solve():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    max_val = 0\n    time = 0\n    for i in range(m):\n        if a[i] > max_val:\n            time += (a[i] - max_val) * 2\n            max_val = a[i]\n        else:\n            time += (n - max_val + a[i]) % n\n\n    print(time)\n\nif __name__ == \"__main__\":\n    t = 1  # int(input())\n    while t > 0:\n        solve()\n        t -= 1"}
{"task_id": "E2H_CF88A", "completion": "import sys\n\ndef get_distance(note1, note2):\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    index1 = notes.index(note1)\n    index2 = notes.index(note2)\n    if index1 > index2:\n        index1 -= 12\n    return (index2 - index1) % 12\n\ndef is_major(triad):\n    notes = triad.split()\n    distances = [get_distance(notes[0], notes[1]), get_distance(notes[1], notes[2])]\n    distances.sort()\n    return distances == [3, 4]\n\ndef is_minor(triad):\n    notes = triad.split()\n    distances = [get_distance(notes[0], notes[1]), get_distance(notes[1], notes[2])]\n    distances.sort()\n    return distances == [4, 3]\n\ndef solve():\n    triads = sys.stdin.read().strip().split('\\n')\n    for triad in triads:\n        notes = triad.split()\n        if len(notes) != 3:\n            print('strange')\n        elif is_major(triad):\n            print('major')\n        elif is_minor(triad):\n            print('minor')\n        else:\n            print('strange')\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF633B", "completion": "import sys\n\ndef count_zeros(m):\n    \"\"\"\n    Calculate the number of positive integers n, such that the factorial of n ends with exactly m zeroes.\n\n    Args:\n        m (int): The required number of trailing zeroes in factorial.\n\n    Returns:\n        list: A list of integers representing the values of n such that the factorial of n ends with m zeroes.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n\n    # Initialize a variable to keep track of the current number\n    i = 5\n\n    # Continue until we find a number whose factorial has more than m trailing zeroes\n    while True:\n        # Calculate the number of trailing zeroes in i!\n        zeros = 0\n        j = i\n        while j > 0:\n            zeros += j // 5\n            j //= 5\n\n        # If the number of trailing zeroes is equal to m, add i to the result list\n        if zeros == m:\n            result.append(i)\n        # If the number of trailing zeroes is greater than m, break the loop\n        elif zeros > m:\n            break\n        # Otherwise, increment i by 1\n        i += 1\n\n    return result\n\n\ndef main():\n    # Read the input from standard input\n    m = int(input())\n\n    # Count the number of positive integers n, such that the factorial of n ends with exactly m zeroes\n    result = count_zeros(m)\n\n    # Print the number of values of n\n    print(len(result))\n\n    # Print the values of n in increasing order\n    print(' '.join(map(str, result)))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1767D", "completion": "import sys\n\ndef solve():\n    n = int(input())\n    s = input()\n    a = [0] * (n + 1)\n    for i in range(1, n + 1):\n        a[i] = a[i - 1] + (ord(s[i - 1]) - ord('0')) * (2 ** (n - i))\n    b = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        b[i] = b[i + 1] + (ord(s[i - 1]) - ord('0')) * (2 ** (i - 1))\n    x = 1\n    y = 1\n    for i in range(1, n + 1):\n        if s[i - 1] == '0':\n            x *= 2\n        else:\n            y *= 2\n    print(*list(range(b[1] + 1, min(x, 2 ** n - b[n] + 1) + 1)))\n\nt = 1\nfor _ in range(t):\n    solve()"}
{"task_id": "E2H_CF498A", "completion": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    x1, y1 = map(int, input().split())\n    x2, y2 = map(int, input().split())\n    n = int(input())\n\n    lines = []\n    for _ in range(n):\n        a, b, c = map(int, input().split())\n        lines.append((a, b, c))\n\n    return x1, y1, x2, y2, n, lines\n\ndef get_block(x, y, lines):\n    block = 0\n    for a, b, c in lines:\n        if a * x + b * y + c == 0:\n            block += 1\n    return block\n\ndef solve(x1, y1, x2, y2, n, lines):\n    blocks = set()\n    for a, b, c in lines:\n        blocks.add((a, b))\n    blocks = list(blocks)\n\n    stack = [(x1, y1)]\n    visited = set((x1, y1))\n    while stack:\n        x, y = stack.pop()\n        for a, b in blocks:\n            if a * x + b * y == 0:\n                continue\n            new_x = (b * y - a * x) / (a * b)\n            new_y = (a * x + b * y) / (a * b)\n            if (new_x, new_y) not in visited:\n                visited.add((new_x, new_y))\n                stack.append((new_x, new_y))\n\n    block1 = get_block(x1, y1, lines)\n    block2 = get_block(x2, y2, lines)\n\n    if block1 == block2:\n        return 0\n    else:\n        return min(abs(block1 - i) + abs(block2 - i) for i in range(1, block2 + 1))\n\ndef main():\n    x1, y1, x2, y2, n, lines = read_input()\n    print(solve(x1, y1, x2, y2, n, lines))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1092C", "completion": "from collections import defaultdict\n\ndef get_prefixes_and_suffixes(n, strings):\n    prefixes = defaultdict(set)\n    suffixes = defaultdict(set)\n\n    for s in strings:\n        if len(s) == n - 1:\n            prefixes[len(s)].add(s)\n            suffixes[len(s)].add(s)\n        elif len(s) < n - 1:\n            prefixes[len(s)].add(s)\n        else:\n            suffixes[len(s)].add(s)\n\n    return prefixes, suffixes\n\n\ndef solve():\n    n = int(input())\n    strings = []\n    for _ in range(2 * n - 2):\n        strings.append(input())\n\n    prefixes, suffixes = get_prefixes_and_suffixes(n, strings)\n\n    result = ['P' if i in prefixes[s] else 'S' for i in strings]\n    print(''.join(result))\n\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF1146D", "completion": "bash\npython frog_jumping.py"}
{"task_id": "E2H_CF980E", "completion": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    n, k = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    return n, k, graph\n\n\ndef find_parent(graph, u, parent):\n    for v in graph[u]:\n        if v != parent[u]:\n            parent[v] = u\n            find_parent(graph, v, parent)\n\n\ndef solve(n, k, graph):\n    parent = [0] * (n + 1)\n    find_parent(graph, 1, parent)\n\n    size = [1] * (n + 1)\n    for i in range(2, n + 1):\n        size[parent[i]] += size[i]\n\n    ans = []\n    for i in range(n, 0, -1):\n        if size[i] == 1:\n            ans.append(i)\n        if len(ans) == k:\n            break\n\n    return ' '.join(map(str, sorted(ans)))\n\n\ndef main():\n    t = 1\n    for _ in range(t):\n        n, k, graph = read_input()\n        print(solve(n, k, graph))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1709F", "completion": "import sys\ninput = sys.stdin.readline\n\nMOD = 998244353\n\ndef pow_mod(a, b):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = (res * a) % MOD\n        a = (a * a) % MOD\n        b >>= 1\n    return res\n\ndef inv(x):\n    return pow_mod(x, MOD - 2)\n\nclass Matrix:\n    def __init__(self, n):\n        self.n = n\n        self.data = [[0] * n for _ in range(n)]\n\n    def mul(self, other):\n        res = Matrix(self.n)\n        for i in range(self.n):\n            for j in range(self.n):\n                for k in range(self.n):\n                    res.data[i][j] += self.data[i][k] * other.data[k][j]\n                    res.data[i][j] %= MOD\n        return res\n\n    def __str__(self):\n        return '\\n'.join([' '.join(map(str, row)) for row in self.data])\n\ndef solve():\n    n, k, f = map(int, input().split())\n    if n == 1:\n        print(1 if k >= f else 0)\n        return\n    if n == 2:\n        dp = [Matrix(200001) for _ in range(f + 1)]\n        dp[0].data[0][0] = 1\n        for i in range(1, f + 1):\n            for j in range(min(i, k) + 1):\n                for m in range(j + 1):\n                    dp[i].data[j][m] += dp[i - 1].data[j][m]\n                    dp[i].data[j][m] %= MOD\n                    dp[i].data[j][m + 1] += dp[i - 1].data[j][m]\n                    dp[i].data[j][m + 1] %= MOD\n        ans = 0\n        for i in range(k + 1):\n            for j in range(i + 1):\n                ans += dp[f].data[i][j] * inv(pow_mod(2, j))\n                ans %= MOD\n        print(ans)\n        return\n    dp = [Matrix(200001) for _ in range(f + 1)]\n    dp[0].data[0][0] = 1\n    for i in range(1, f + 1):\n        for j in range(min(i, k) + 1):\n            for m in range(j + 1):\n                dp[i].data[j][m] += dp[i - 1].data[j][m]\n                dp[i].data[j][m] %= MOD\n                dp[i].data[j][m + 1] += dp[i - 1].data[j][m]\n                dp[i].data[j][m + 1] %= MOD\n    dp2 = [Matrix(200001) for _ in range(f + 1)]\n    dp2[0].data[0][0] = 1\n    for i in range(1, f + 1):\n        for j in range(min(i, k) + 1):\n            for m in range(j + 1):\n                dp2[i].data[j][m] += dp2[i - 1].data[j][m]\n                dp2[i].data[j][m] %= MOD\n                dp2[i].data[j + 1][m] += dp2[i - 1].data[j][m]\n                dp2[i].data[j + 1][m] %= MOD\n    ans = 0\n    for i in range(k + 1):\n        for j in range(i + 1):\n            ans += dp[f].data[i][j] * dp2[f].data[i][j]\n            ans %= MOD\n    print(ans)\n\nif __name__ == '__main__':\n    T = 1\n    # T = int(input())\n    for _ in range(T):\n        solve()"}
