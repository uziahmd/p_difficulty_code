{"task_id": "E2H_CF1031A", "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    w, h, k = map(int, input().split())\n    \n    total_cells = 0\n    for i in range(k):\n        width = w - 4 * i\n        height = h - 4 * i\n        perimeter = 2 * (width + height - 2)\n        total_cells += perimeter\n    print(total_cells)"}
{"task_id": "E2H_CF151A", "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    l = int(data[2])\n    c = int(data[3])\n    d = int(data[4])\n    p = int(data[5])\n    nl = int(data[6])\n    np = int(data[7])\n    \n    total_drink = k * l\n    total_lime_slices = c * d\n    total_salt = p\n    \n    toasts_by_drink = total_drink // nl\n    toasts_by_lime = total_lime_slices // n\n    toasts_by_salt = total_salt // np\n    \n    result = min(toasts_by_drink, toasts_by_lime, toasts_by_salt)\n    print(result)"}
{"task_id": "E2H_CF404A", "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    grid = data[1:]\n    \n    # Check if n is odd (as per problem statement, it's guaranteed)\n    # But we can still proceed\n    \n    # Collect characters from both diagonals\n    diag1 = set()\n    diag2 = set()\n    \n    for i in range(n):\n        diag1.add(grid[i][i])\n        diag2.add(grid[i][n - 1 - i])\n    \n    # If diagonals do not have the same character or more than one unique character\n    if len(diag1) != 1 or len(diag2) != 1 or diag1 != diag2:\n        print(\"NO\")\n        return\n    \n    diagonal_char = diag1.pop()\n    \n    # Check all other cells (not on diagonals)\n    other_char = None\n    for i in range(n):\n        for j in range(n):\n            if i == j or i + j == n - 1:\n                continue\n            if other_char is None:\n                other_char = grid[i][j]\n            elif grid[i][j] != other_char:\n                print(\"NO\")\n                return\n    \n    # Ensure other_char is different from diagonal_char\n    if other_char == diagonal_char:\n        print(\"NO\")\n    else:\n        print(\"YES\")"}
{"task_id": "E2H_CF339B", "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    tasks = list(map(int, data[2:2 + m]))\n    \n    current_position = 1\n    total_time = 0\n    \n    for task in tasks:\n        if task == current_position:\n            continue\n        elif task > current_position:\n            total_time += task - current_position\n            current_position = task\n        else:\n            total_time += n - current_position + task\n            current_position = task\n    \n    print(total_time)"}
{"task_id": "E2H_CF492B", "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    l = int(data[1])\n    a = list(map(int, data[2:2 + n]))\n    \n    a.sort()\n    \n    max_gap = 0\n    for i in range(1, n):\n        gap = a[i] - a[i - 1]\n        if gap > max_gap:\n            max_gap = gap\n    \n    # Check the beginning and the end of the street\n    first_gap = a[0] - 0\n    last_gap = l - a[-1]\n    \n    max_gap = max(max_gap, first_gap, last_gap)\n    \n    d = max_gap / 2.0\n    print(\"{0:.10f}\".format(d))"}
{"task_id": "E2H_CF88A", "completion": "def solve():\n    import sys\n\n    # Define the order of notes\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\n    # Map each note to its index\n    note_to_index = {note: idx for idx, note in enumerate(notes)}\n\n    # Read input\n    input_line = sys.stdin.readline().strip()\n    chord = input_line.split()\n\n    # Get indices of the three notes\n    a, b, c = chord\n    i, j, k = note_to_index[a], note_to_index[b], note_to_index[c]\n\n    # Function to calculate distance from note1 to note2 (cyclic)\n    def distance(note1, note2):\n        return (note2 - note1) % 12\n\n    # Generate all permutations of the three notes\n    from itertools import permutations\n    for perm in permutations([i, j, k]):\n        x, y, z = perm\n        d1 = distance(x, y)\n        d2 = distance(y, z)\n        if d1 == 4 and d2 == 3:\n            print(\"major\")\n            return\n        if d1 == 3 and d2 == 4:\n            print(\"minor\")\n            return\n\n    print(\"strange\")"}
{"task_id": "E2H_CF173A", "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    A = data[1]\n    B = data[2]\n    \n    m = len(A)\n    k = len(B)\n    \n    # Precompute the results for one full cycle of both sequences\n    # We will simulate up to LCM(m, k) rounds to find a repeating pattern\n    from math import gcd\n    \n    lcm = m * k // gcd(m, k)\n    \n    # Initialize counters for red spots\n    nike_red = 0\n    poly_red = 0\n    \n    # Simulate one full cycle of both sequences\n    for i in range(lcm):\n        a = A[i % m]\n        b = B[i % k]\n        \n        if a == b:\n            continue\n        elif (a == 'R' and b == 'S') or (a == 'S' and b == 'P') or (a == 'P' and b == 'R'):\n            nike_red += 1\n        else:\n            poly_red += 1\n    \n    # Number of full cycles and remaining rounds\n    full_cycles = n // lcm\n    remainder = n % lcm\n    \n    total_nike = full_cycles * nike_red\n    total_poly = full_cycles * poly_red\n    \n    # Add results from the remaining rounds\n    for i in range(remainder):\n        a = A[i % m]\n        b = B[i % k]\n        \n        if a == b:\n            continue\n        elif (a == 'R' and b == 'S') or (a == 'S' and b == 'P') or (a == 'P' and b == 'R'):\n            total_nike += 1\n        else:\n            total_poly += 1\n    \n    print(total_nike, total_poly)"}
{"task_id": "E2H_CF633B", "completion": "import sys\n\ndef count_trailing_zeros(n):\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\ndef solve():\n    m = int(sys.stdin.readline())\n    \n    # Binary search to find the smallest n such that count_trailing_zeros(n) == m\n    low, high = 0, 5 * m\n    left = -1\n    while low <= high:\n        mid = (low + high) // 2\n        tz = count_trailing_zeros(mid)\n        if tz == m:\n            left = mid\n            high = mid - 1\n        elif tz < m:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    if left == -1:\n        print(0)\n        return\n    \n    # Find the range of n's that have exactly m trailing zeros\n    right = left\n    while count_trailing_zeros(right) == m:\n        right += 1\n    \n    result = list(range(left, right))\n    print(len(result))\n    print(' '.join(map(str, result)))"}
{"task_id": "E2H_CF1141D", "completion": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split('\\n')\n    \n    n = int(data[0])\n    l = data[1]\n    r = data[2]\n\n    # We will use dictionaries to count the number of each color in left and right boots\n    left_count = defaultdict(int)\n    right_count = defaultdict(int)\n\n    # First, count all colors in left and right boots\n    for c in l:\n        left_count[c] += 1\n    for c in r:\n        right_count[c] += 1\n\n    # Now, we'll try to match specific colors first\n    matched = 0\n    pairs = []\n\n    # For each color (excluding '?'), match as many as possible\n    for color in left_count:\n        if color == '?':\n            continue\n        if color in right_count:\n            match = min(left_count[color], right_count[color])\n            matched += match\n            # We need to track which indices are used\n            # So we'll create lists of indices for each color\n            left_indices = []\n            right_indices = []\n            for i in range(n):\n                if l[i] == color:\n                    left_indices.append(i + 1)\n                if r[i] == color:\n                    right_indices.append(i + 1)\n            # Pair them up\n            for i in range(match):\n                pairs.append((left_indices[i], right_indices[i]))\n            # Update counts\n            left_count[color] -= match\n            right_count[color] -= match\n\n    # Now handle the '?' in left and right\n    # First, match '?' in left with non-'?' in right\n    left_q = []\n    right_non_q = []\n    for i in range(n):\n        if l[i] == '?':\n            left_q.append(i + 1)\n        elif r[i] != '?':\n            right_non_q.append(i + 1)\n    # Pair them up\n    match = min(len(left_q), len(right_non_q))\n    matched += match\n    for i in range(match):\n        pairs.append((left_q[i], right_non_q[i]))\n\n    # Then, match '?' in right with non-'?' in left\n    right_q = []\n    left_non_q = []\n    for i in range(n):\n        if r[i] == '?':\n            right_q.append(i + 1)\n        elif l[i] != '?':\n            left_non_q.append(i + 1)\n    # Pair them up\n    match = min(len(right_q), len(left_non_q))\n    matched += match\n    for i in range(match):\n        pairs.append((left_non_q[i], right_q[i]))\n\n    # Finally, match '?' with '?'\n    left_q_remaining = []\n    right_q_remaining = []\n    for i in range(n):\n        if l[i] == '?':\n            left_q_remaining.append(i + 1)\n        if r[i] == '?':\n            right_q_remaining.append(i + 1)\n    match = min(len(left_q_remaining), len(right_q_remaining))\n    matched += match\n    for i in range(match):\n        pairs.append((left_q_remaining[i], right_q_remaining[i]))\n\n    print(matched)\n    for a, b in pairs:\n        print(f\"{a} {b}\")"}
{"task_id": "E2H_CF1767D", "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    s = data[1]\n    \n    total_teams = 2 ** n\n    \n    # We need to determine for each x in 1..total_teams whether it can be the champion\n    # Based on the rules of the tournament and the string s\n    \n    # We simulate the tournament from the bottom up using a priority queue approach\n    # For each round, we simulate matches based on the rule in s[i]\n    \n    # Start with all teams as leaves in a binary tree\n    # We will simulate the tournament using a list of lists, where each level represents a round\n    # We'll build the tournament from the bottom up\n    \n    # Initialize the first round (leaves)\n    teams = list(range(1, total_teams + 1))\n    \n    # We'll simulate the tournament for each round\n    for i in range(n):\n        phase = s[i]\n        next_round = []\n        games_in_phase = 2 ** (n - i - 1)\n        \n        for j in range(games_in_phase):\n            team1 = teams[2 * j]\n            team2 = teams[2 * j + 1]\n            \n            if phase == '0':\n                # Lower skill wins\n                winner = min(team1, team2)\n            else:\n                # Higher skill wins\n                winner = max(team1, team2)\n            \n            next_round.append(winner)\n        \n        teams = next_round\n    \n    # The champion is the only element left in teams\n    champion = teams[0]\n    \n    # Now we need to find all x such that there exists a permutation p where x is the champion\n    # We can simulate the tournament for each possible x as the champion and see if it's possible\n    \n    # To do this efficiently, we simulate the tournament for each x as the \"champion\"\n    # and check if it can reach the top based on the rules in s\n    \n    winning_numbers = set()\n    \n    for x in range(1, total_teams + 1):\n        # Create a list of teams with x as the champion\n        # We will simulate the tournament with x as the champion\n        # We need to simulate the tournament in reverse to see if x can be the winner\n        \n        # Start with x at the final round\n        # Then simulate the rounds in reverse\n        current_round = [x]\n        \n        for i in range(n - 1, -1, -1):\n            phase = s[i]\n            next_round = []\n            games_in_phase = 2 ** (i)\n            \n            for j in range(games_in_phase):\n                # Each game in this round has one winner which is in current_round\n                # The other team must be such that it loses to the winner according to the rule\n                winner = current_round[j]\n                \n                if phase == '0':\n                    # Lower skill wins, so the other team must have higher skill than winner\n                    # So we can choose any value > winner\n                    other_team = winner + 1\n                else:\n                    # Higher skill wins, so the other team must have lower skill than winner\n                    # So we can choose any value < winner\n                    other_team = winner - 1\n                \n                next_round.append(winner)\n                next_round.append(other_team)\n            \n            current_round = next_round\n        \n        # If we can construct a valid tournament with x as the winner, then x is winning\n        winning_numbers.add(x)\n    \n    # Sort and print the winning numbers\n    print(' '.join(map(str, sorted(winning_numbers))))"}
{"task_id": "E2H_CF822C", "completion": "import sys\nimport bisect\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    \n    vouchers = []\n    idx = 2\n    for _ in range(n):\n        l = int(data[idx])\n        r = int(data[idx + 1])\n        cost = int(data[idx + 2])\n        vouchers.append((l, r, cost))\n        idx += 3\n    \n    # Sort vouchers by their end date\n    vouchers.sort()\n    \n    # Preprocess: For each voucher, store the minimum cost for a given duration\n    # We'll use two dictionaries:\n    # - left_duration: maps duration to min cost for vouchers ending before a certain day\n    # - right_duration: maps duration to min cost for vouchers starting after a certain day\n    \n    # First pass: build left_duration\n    left_duration = {}\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if duration not in left_duration or cost < left_duration[duration]:\n            left_duration[duration] = cost\n    \n    # Second pass: build right_duration\n    right_duration = {}\n    for l, r, cost in reversed(vouchers):\n        duration = r - l + 1\n        if duration not in right_duration or cost < right_duration[duration]:\n            right_duration[duration] = cost\n    \n    # Now, for each voucher, check if there's another voucher that can pair with it\n    min_cost = float('inf')\n    for l, r, cost in vouchers:\n        duration1 = r - l + 1\n        duration2 = x - duration1\n        \n        # Check if duration2 is valid\n        if duration2 <= 0:\n            continue\n        \n        # Check if there is a voucher that starts after r and has duration2\n        # Use binary search to find the first voucher with l > r\n        # Since vouchers are sorted by r, we need to find the first voucher where l > r\n        # So we can binary search on l of vouchers\n        # Extract all l's from vouchers for binary search\n        l_list = [v[0] for v in vouchers]\n        i = bisect.bisect_right(l_list, r)\n        if i < n:\n            # Check if there is a voucher starting after r with duration2\n            if duration2 in right_duration:\n                total_cost = cost + right_duration[duration2]\n                if total_cost < min_cost:\n                    min_cost = total_cost\n        \n        # Check if there is a voucher that ends before l and has duration2\n        # Use binary search to find the last voucher with r < l\n        r_list = [v[1] for v in vouchers]\n        j = bisect.bisect_left(r_list, l) - 1\n        if j >= 0:\n            # Check if there is a voucher ending before l with duration2\n            if duration2 in left_duration:\n                total_cost = cost + left_duration[duration2]\n                if total_cost < min_cost:\n                    min_cost = total_cost\n    \n    if min_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_cost)"}
{"task_id": "E2H_CF498A", "completion": "import sys\nfrom collections import deque\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split('\\n')\n    \n    x1, y1 = map(int, data[0].split())\n    x2, y2 = map(int, data[1].split())\n    n = int(data[2])\n    roads = []\n    for i in range(3, 3 + n):\n        a, b, c = map(int, data[i].split())\n        roads.append((a, b, c))\n    \n    # Function to determine which side of the line (a, b, c) a point (x, y) is on\n    def side(a, b, c, x, y):\n        return a * x + b * y + c\n    \n    # Function to compute the sign of the value\n    def sign(val):\n        if val > 0:\n            return 1\n        elif val < 0:\n            return -1\n        else:\n            return 0\n    \n    # Determine the initial region (block) for home and university\n    def get_region(point):\n        signs = []\n        for a, b, c in roads:\n            val = side(a, b, c, *point)\n            signs.append(sign(val))\n        return tuple(signs)\n    \n    start_region = get_region((x1, y1))\n    end_region = get_region((x2, y2))\n    \n    if start_region == end_region:\n        print(0)\n        return\n    \n    # Build graph: nodes are regions, edges exist if regions share a nonzero boundary\n    # To avoid checking all pairs, we use BFS with a way to find adjacent regions\n    \n    # Use BFS to find shortest path from start_region to end_region\n    # We will represent each region as a tuple of signs\n    \n    # Helper function to check if two regions are adjacent (share a boundary)\n    def is_adjacent(region1, region2):\n        diff_count = sum(1 for s1, s2 in zip(region1, region2) if s1 != s2)\n        return diff_count == 1\n    \n    # BFS\n    visited = set()\n    queue = deque()\n    queue.append((start_region, 0))\n    visited.add(start_region)\n    \n    while queue:\n        current_region, steps = queue.popleft()\n        if current_region == end_region:\n            print(steps)\n            return\n        # Generate all possible adjacent regions\n        for i in range(len(roads)):\n            # Flip the sign for the i-th road\n            new_region = list(current_region)\n            new_region[i] *= -1\n            new_region = tuple(new_region)\n            if new_region not in visited:\n                visited.add(new_region)\n                queue.append((new_region, steps + 1))\n    \n    # If not found (should not happen per problem statement)\n    print(-1)"}
{"task_id": "E2H_CF1846E2", "completion": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Check for possible k > 1 such that n = 1 + k + k * (k - 1) * m for some m >= 1\n    # Which simplifies to n = 1 + k + k*(k-1)*m\n    # So n - 1 = k*(1 + (k-1)*m)\n    # Try all possible k from 2 to sqrt(n)\n    max_k = int(math.isqrt(n)) + 2\n    for k in range(2, max_k):\n        if (n - 1) % k == 0:\n            remainder = (n - 1) // k\n            # remainder should be 1 + (k-1)*m => remainder - 1 must be divisible by (k-1)\n            if (remainder - 1) % (k - 1) == 0:\n                return True\n    return False\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n = int(data[i])\n        if is_snowflake(n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    print(\"\\n\".join(results))\n\nsolve()"}
{"task_id": "E2H_CF1092C", "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    strings = data[1:]\n    \n    # We need to find a string s of length n such that all given strings are its prefixes or suffixes\n    # Try each string as a possible candidate for the full string s\n    for candidate in strings:\n        if len(candidate) == n:\n            # Check if all other strings are either prefix or suffix of this candidate\n            valid = True\n            for s in strings:\n                if s == candidate:\n                    continue\n                if not s == candidate[:len(s)] and not s == candidate[-len(s):]:\n                    valid = False\n                    break\n            if valid:\n                # Now determine which strings are prefixes and which are suffixes\n                result = []\n                for s in strings:\n                    if s == candidate:\n                        continue\n                    if s == candidate[:len(s)]:\n                        result.append('P')\n                    else:\n                        result.append('S')\n                print(''.join(result))\n                return"}
{"task_id": "E2H_CF270E", "completion": "import sys\nimport threading\nfrom collections import defaultdict, deque\n\ndef solve():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    graph = defaultdict(list)\n    edge_index = {}\n    \n    for i in range(m):\n        a, b, c = map(int, sys.stdin.readline().split())\n        edges.append((a, b, c))\n        graph[a].append((b, i))\n        graph[b].append((a, i))\n        edge_index[(a, b)] = i\n        edge_index[(b, a)] = i\n\n    # We need to assign directions to edges such that:\n    # - The flow is valid (conservation of flow at intermediate nodes)\n    # - Source has no incoming edges\n    # - The directed graph is acyclic\n\n    # To ensure acyclicity and correct flow, we can build a directed tree rooted at source (node 1)\n    # and direct all edges away from the root.\n\n    # Use BFS to build a tree starting from node 1\n    parent = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    q = deque()\n    q.append(1)\n    visited[1] = True\n\n    while q:\n        u = q.popleft()\n        for v, idx in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                parent[v] = u\n                q.append(v)\n\n    # Now assign directions based on the tree\n    result = [0] * m\n\n    for i in range(m):\n        a, b, c = edges[i]\n        if parent[b] == a:\n            result[i] = 0  # direction a -> b\n        elif parent[a] == b:\n            result[i] = 1  # direction b -> a\n        else:\n            # This edge is not part of the tree; we can choose any direction\n            # But we need to make sure it doesn't create a cycle.\n            # Since the tree is built with BFS, we can safely direct it from parent to child\n            # If neither is parent of other, then it's a back edge. We can direct it from lower to higher node to avoid cycles\n            if a < b:\n                result[i] = 0\n            else:\n                result[i] = 1\n\n    for d in result:\n        print(d)\n        \nthreading.Thread(target=solve).start()"}
{"task_id": "E2H_CF1146D", "completion": "import sys\nimport math\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    m, a, b = map(int, input().split())\n\n    # If a == b, then the frog can only jump forward by a (or backward by a)\n    # So it can reach all multiples of a up to m\n    if a == b:\n        count = m // a + 1\n        total = count * (count + 1) // 2\n        print(total)\n        return\n\n    # We need to find the set of positions reachable by the frog without going out of [0, x]\n    # This is equivalent to finding all positions reachable by moving forward a or backward b\n    # The key insight is that the frog can reach any position congruent to 0 mod gcd(a, b)\n    # But we must ensure that the frog never goes below 0 or above x\n\n    def f(x):\n        if x < 0:\n            return 0\n        if x == 0:\n            return 1\n        g = math.gcd(a, b)\n        if g == 0:\n            return 0\n        # The frog can reach any position in the form of k * g where k is an integer\n        # But we need to ensure that the frog can reach such positions within [0, x]\n        max_k = x // g\n        min_k = 0\n        # Now we need to find how many of these positions are reachable\n        # Let's simulate the process using BFS up to the first few steps\n        # Since a and b are small, we can simulate up to a certain point\n        from collections import deque\n        visited = set()\n        queue = deque()\n        queue.append(0)\n        visited.add(0)\n        while queue:\n            pos = queue.popleft()\n            for step in [a, -b]:\n                next_pos = pos + step\n                if 0 <= next_pos <= x and next_pos not in visited:\n                    visited.add(next_pos)\n                    queue.append(next_pos)\n        return len(visited)\n\n    # For large m, we can't compute f(i) for each i from 0 to m directly\n    # Instead, we observe that once the frog can reach all positions in [0, x] that are multiples of g,\n    # then for all larger x, the number of reachable positions increases by 1 per g\n    # So we find the minimal x where the frog can reach all positions in [0, x] that are multiples of g\n    # Then we compute the sum accordingly\n\n    # Let's simulate until we find the pattern\n    # We will simulate for some initial values and find the pattern\n    from collections import deque\n    visited = set()\n    queue = deque()\n    queue.append(0)\n    visited.add(0)\n    positions = set()\n    positions.add(0)\n    while queue:\n        pos = queue.popleft()\n        for step in [a, -b]:\n            next_pos = pos + step\n            if next_pos >= 0:\n                if next_pos not in visited:\n                    visited.add(next_pos)\n                    queue.append(next_pos)\n                    positions.add(next_pos)\n\n    # All reachable positions are in positions\n    # The maximum reachable position is max_pos\n    max_pos = max(positions) if positions else 0\n\n    # From now on, for x >= max_pos, the frog can reach all positions in [0, x] that are multiples of g\n    g = math.gcd(a, b)\n    if g == 0:\n        print(0)\n        return\n\n    # Compute the number of reachable positions for x < max_pos\n    total = 0\n    for x in range(0, max_pos + 1):\n        total += f(x)\n\n    # For x >= max_pos, the number of reachable positions is floor(x / g) + 1\n    # But we need to be careful with x > m\n    start = max_pos + 1\n    if start <= m:\n        count = (m - start + 1)\n        # Sum of floor(x / g) + 1 for x from start to m\n        # floor(x / g) + 1 = floor((x + g) / g)\n        # So sum_{x=start}^m (floor((x + g) / g)) = sum_{k=ceil(start/g)}^{floor((m + g)/g)} k * g - g + 1 ?\n        # Alternatively, we can compute sum_{x=start}^m floor(x / g) + 1\n        # = sum_{x=start}^m floor(x / g) + count\n        # sum_{x=start}^m floor(x / g) = sum_{k=0}^{floor(m/g)} k * (number of x such that floor(x/g) = k)\n        # Let's compute it directly\n        lower = start\n        upper = m\n        first_k = (lower + g - 1) // g\n        last_k = upper // g\n        total_k = last_k - first_k + 1\n        sum_k = (first_k + last_k) * total_k // 2\n        count = upper - lower + 1\n        total += sum_k + count\n\n    print(total)"}
{"task_id": "E2H_CF808E", "completion": "import sys\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    weight_cost = [[0, 0], [0, 0], [0, 0]]  # index 0: weight 1, index 1: weight 2, index 2: weight 3\n    \n    idx = 2\n    for _ in range(n):\n        w = int(data[idx])\n        c = int(data[idx + 1])\n        idx += 2\n        weight_cost[w - 1] = (weight_cost[w - 1][0] + 1, weight_cost[w - 1][1] + c)\n    \n    # Now we have counts and total costs for each weight category\n    # We will use a greedy approach to maximize the cost\n    \n    dp = [0] * (m + 1)\n    \n    # Process weight 1 items\n    count_1, cost_1 = weight_cost[0]\n    for i in range(1, m + 1):\n        if i >= 1:\n            dp[i] = max(dp[i], dp[i - 1] + cost_1)\n    \n    # Process weight 2 items\n    count_2, cost_2 = weight_cost[1]\n    for i in range(1, m + 1):\n        if i >= 2:\n            dp[i] = max(dp[i], dp[i - 2] + cost_2)\n    \n    # Process weight 3 items\n    count_3, cost_3 = weight_cost[2]\n    for i in range(1, m + 1):\n        if i >= 3:\n            dp[i] = max(dp[i], dp[i - 3] + cost_3)\n    \n    print(dp[m])"}
{"task_id": "E2H_CF980E", "completion": "import sys\nimport heapq\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    \n    from collections import defaultdict\n    \n    tree = defaultdict(list)\n    index = 2\n    \n    for _ in range(n - 1):\n        a = int(data[index])\n        b = int(data[index + 1])\n        tree[a].append(b)\n        tree[b].append(a)\n        index += 2\n    \n    # We want to keep the districts with the largest 2^i values, so we prioritize keeping higher-numbered districts\n    # We will use a priority queue (min-heap) to keep track of the districts we can remove\n    # We will perform a DFS to calculate the size of each subtree and decide which districts to remove\n    \n    removed = []\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                child_size = dfs(neighbor, node)\n                size += child_size\n        return size\n    \n    # We need to find the districts to remove such that the remaining districts form a connected component\n    # We will remove the districts with the smallest 2^i values first, starting from the leaves\n    # To do this efficiently, we will use a priority queue (min-heap) based on the value 2^i\n    \n    # We will perform a DFS to collect all nodes and their subtree sizes\n    # Then we will use a priority queue to select which nodes to remove\n    \n    # We will use a min-heap to store the districts to remove, prioritized by 2^i (smallest first)\n    # We will also keep track of the subtree sizes to ensure connectivity\n    \n    # We will simulate the process of removing nodes while maintaining connectivity\n    # Start with all nodes except the root (we can choose any node as root, say 1)\n    \n    # Let's pick node 1 as root and perform a post-order traversal to collect subtree sizes\n    # We will use a min-heap to store the nodes with their 2^i values and subtree sizes\n    \n    heap = []\n    \n    def dfs2(node, parent):\n        size = 1\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                child_size = dfs2(neighbor, node)\n                size += child_size\n        # Push the node into the heap with its 2^i value and subtree size\n        heapq.heappush(heap, (2 ** node, node, size))\n        return size\n    \n    dfs2(1, -1)\n    \n    result = []\n    \n    # We need to remove k nodes\n    for _ in range(k):\n        val, node, size = heapq.heappop(heap)\n        result.append(node)\n    \n    # Sort the result in increasing order\n    result.sort()\n    \n    print(' '.join(map(str, result)))"}
{"task_id": "E2H_CF409I", "completion": "def solve():\n    import sys\n    from itertools import product\n\n    name = sys.stdin.readline().strip()\n\n    # Extract the part of the name that represents the jaws\n    # Format: ?(...)[:-...>...]\n    # We need to extract the part inside the parentheses and the part after > (the sequence length)\n    start = name.find('(')\n    end = name.find(')')\n    if start == -1 or end == -1:\n        print(\"false\")\n        return\n\n    jaws = name[start + 1:end]\n    sequence_length_part = name[end + 1:]\n    if not sequence_length_part.startswith(':'):\n        print(\"false\")\n        return\n\n    # Extract the sequence length\n    sequence_length_str = sequence_length_part[1:].split('>')[0]\n    try:\n        sequence_length = int(sequence_length_str)\n    except ValueError:\n        print(\"false\")\n        return\n\n    # If sequence length is zero or negative, it's invalid\n    if sequence_length <= 0:\n        print(\"false\")\n        return\n\n    # Generate all possible sequences of digits of the required length\n    for digits in product('0123456789', repeat=sequence_length):\n        candidate = ''.join(digits)\n        # Check if the candidate fits the jaws pattern\n        if fits_pattern(jaws, candidate):\n            print(candidate)\n            return\n\n    print(\"false\")\n\ndef fits_pattern(jaws, candidate):\n    # This function checks if the candidate sequence fits the jaws pattern\n    # The jaws pattern uses the following symbols:\n    # '_' -> any digit\n    # '+' -> digit must be greater than previous\n    # '-' -> digit must be less than previous\n    # '*' -> digit must be equal to previous\n    # We'll simulate the process of feeding the sequence into the jaws\n\n    if len(candidate) != len(jaws):\n        return False\n\n    prev = None\n    for i in range(len(jaws)):\n        jaw = jaws[i]\n        digit = int(candidate[i])\n        if jaw == '_':\n            continue\n        elif jaw == '+':\n            if prev is None or digit <= prev:\n                return False\n        elif jaw == '-':\n            if prev is None or digit >= prev:\n                return False\n        elif jaw == '*':\n            if prev is None or digit != prev:\n                return False\n        prev = digit\n\n    return True"}
{"task_id": "E2H_CF1709F", "completion": "import sys\nimport math\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    n, k, f = map(int, input().split())\n\n    # Total number of binary strings of length from 1 to n\n    total_strings = 2 * (2**n - 1)\n\n    # We need to compute the number of ways to choose c_s such that the maximum beautiful multiset size is exactly f\n\n    # Let's think in terms of inclusion-exclusion\n    # We can use dynamic programming to compute the number of ways to have a maximum multiset size <= f\n    # Then subtract the number of ways to have maximum multiset size <= f-1\n\n    # dp[l] = number of ways to assign c_s for all strings of length up to l such that the max beautiful multiset size is <= f\n    # We will build this using a trie-like approach\n\n    # For each string s, the number of times it can appear as a prefix is limited by c_s\n    # The constraint is that for any string s, the number of strings in the multiset with s as a prefix is <= c_s\n\n    # This problem is similar to a trie where each node represents a binary string and has a capacity c_s\n    # The maximum number of strings in the multiset is bounded by the minimum capacities along the paths from root to leaves\n\n    # We can model this as a DP over the depth of the trie\n\n    # dp[depth][capacity] = number of ways to assign capacities to strings of length up to depth such that the max multiset size is <= capacity\n\n    # We use a bottom-up approach\n\n    # dp[0][c] = 1 if c >= 0, else 0\n    # dp[depth][c] = sum_{prev_c} dp[depth-1][prev_c] * ways_to_assign_capacities_at_depth_given_prev_c\n\n    # At each depth, we can assign capacities to the new strings (of length depth) such that they don't violate the constraints\n\n    # But since n is small (<=15), we can precompute the number of strings at each depth\n\n    # We'll use a DP table where dp[d][c] = number of ways to assign capacities for strings of length up to d with max multiset size <= c\n\n    # Initialize DP\n    dp = [defaultdict(int) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case: no strings, max size is 0\n\n    for d in range(1, n + 1):\n        # Number of strings of length d: 2^d\n        num_strings_d = 2 ** d\n\n        for prev_c in dp[d - 1]:\n            count = dp[d - 1][prev_c]\n            # For each string of length d, we can choose c_s from 0 to k\n            # However, we must ensure that the min(c_s, ...) does not exceed the previous capacity\n            # Since each string of length d is a leaf in the trie, its capacity must be >= the number of strings in the multiset that have it as a prefix\n            # But the max multiset size is constrained by the minimum of all capacities along the path from root to leaf\n            # So the capacity of each string of length d must be >= the current max multiset size\n\n            # Therefore, we can choose c_s for each string of length d to be at least the current max multiset size\n            # The number of choices is (k - prev_c + 1) if prev_c <= k, else 0\n            if prev_c > k:\n                continue\n            choices = k - prev_c + 1\n            dp[d][prev_c] = (dp[d][prev_c] + count * pow(choices, num_strings_d, MOD)) % MOD\n\n    # Now, the number of ways to have max size <= f is dp[n][f]\n    # The number of ways to have max size <= f-1 is dp[n][f-1]\n    # The answer is (dp[n][f] - dp[n][f-1]) % MOD\n\n    ans = (dp[n].get(f, 0) - dp[n].get(f - 1, 0)) % MOD\n    print(ans)"}
