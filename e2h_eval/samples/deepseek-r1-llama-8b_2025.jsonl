{"task_id": "E2H_CF1031A", "completion": "def golden_plate(w, h, k):\n    total_gilded = 0\n    for i in range(1, k + 1):\n        inner_width = w - 4 * (i - 1)\n        inner_height = h - 4 * (i - 1)\n        if inner_width > 0 and inner_height > 0:\n            total_gilded += (inner_width * inner_height) + (4 * i)\n\n    return total_gilded\n\n\nif __name__ == \"__main__\":\n    w, h, k = map(int, input().split())\n    print(golden_plate(w, h, k))"}
{"task_id": "E2H_CF404A", "completion": "def check_x(n, grid):\n    # Check the diagonals\n    diagonal1 = [grid[i][i] for i in range(n)]\n    diagonal2 = [grid[i][n-i-1] for i in range(n)]\n    \n    if len(set(diagonal1)) != 1 or len(set(diagonal2)) != 1:\n        return False\n    \n    # Check the rest of the grid\n    for i in range(n):\n        for j in range(n):\n            if (i != j and i != n-j-1) and grid[i][j] not in diagonal1:\n                return False\n    \n    return True\n\nn = int(input())\ngrid = []\nfor _ in range(n):\n    grid.append(input())\n\nresults = []\nfor grid_str in grid:\n    n = int(grid_str.split('\\n')[0])\n    grid = [list(row) for row in grid_str.split('\\n')]\n    results.append('YES' if check_x(n, grid) else 'NO')\n\nprint('\\n'.join(results))"}
{"task_id": "E2H_CF492B", "completion": "import math\n\ndef read_input():\n    n, l = map(int, input().split())\n    a = list(map(int, input().split()))\n    return n, l, a\n\ndef find_min_radius(n, l, a):\n    a.sort()\n    max_left = [0] * n\n    max_right = [0] * n\n    \n    for i in range(1, n):\n        max_left[i] = max(max_left[i-1], a[i-1])\n        \n    for i in range(n-2, -1, -1):\n        max_right[i] = max(max_right[i+1], a[i+1])\n        \n    min_radius = 0.0\n    for i in range(n):\n        left_covered = a[i] + max_left[i]\n        right_covered = l - (a[i] - max_right[i])\n        \n        if left_covered > right_covered:\n            min_radius = max(min_radius, left_covered - a[i])\n        else:\n            min_radius = max(min_radius, right_covered - (l - a[i]))\n            \n    return min_radius\n\ndef main():\n    n, l, a = read_input()\n    print(find_min_radius(n, l, a))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF173A", "completion": "import math\n\ndef gcd(a, b):\n    \"\"\"Compute the greatest common divisor of a and b\"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    \"\"\"Compute the lowest common multiple of a and b\"\"\"\n    return a * b // gcd(a, b)\n\ndef solve():\n    n = int(input())\n    m = len(input().strip())\n    k = len(input().strip())\n\n    g = lcm(m, k)\n    n %= g\n\n    nikephoros_spots = 0\n    polycarpus_spots = 0\n\n    for i in range(n):\n        if input().strip()[i % m] == input().strip()[i % k]:\n            continue\n        elif (input().strip()[i % m] == 'R' and input().strip()[i % k] == 'S') or \\\n             (input().strip()[i % m] == 'S' and input().strip()[i % k] == 'P') or \\\n             (input().strip()[i % m] == 'P' and input().strip()[i % k] == 'R'):\n            polycarpus_spots += 1\n        else:\n            nikephoros_spots += 1\n\n    print(f\"{nikephoros_spots} {polycarpus_spots}\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF1141D", "completion": "import sys\n\ndef read_input():\n    n = int(input())\n    left = input()\n    right = input()\n    return n, left, right\n\ndef solve(n, left, right):\n    pairs = []\n    def dfs(i, j, left, right, pairs):\n        if i == n:\n            return\n        if j == n:\n            dfs(i + 1, 0, left, right, pairs)\n            return\n        if left[i] != '?' and right[j] != '?' and left[i] != right[j]:\n            return\n        if left[i] == '?' or right[j] == '?':\n            pairs.append((i + 1, j + 1))\n            dfs(i, j + 1, left, right, pairs)\n            return\n        if left[i] == right[j]:\n            pairs.append((i + 1, j + 1))\n            dfs(i, j + 1, left, right, pairs)\n            return\n        dfs(i, j + 1, left, right, pairs)\n\n    dfs(-1, -1, left, right, pairs)\n    pairs.sort()\n    output = []\n    for i in range(len(pairs)):\n        output.append(f'{pairs[i][0]} {pairs[i][1]}')\n    return len(pairs), '\\n'.join(output)\n\nif __name__ == \"__main__\":\n    t = 1\n    for _ in range(t):\n        n, left, right = read_input()\n        k, output = solve(n, left, right)\n        print(k)\n        print(output)"}
{"task_id": "E2H_CF822C", "completion": "import sys\n\ndef read_input():\n    lines = sys.stdin.readlines()\n    n, x = map(int, lines[0].strip().split())\n    vouchers = []\n    for i in range(1, n + 1):\n        li, ri, costi = map(int, lines[i].strip().split())\n        vouchers.append((li, ri, costi))\n    return n, x, vouchers\n\ndef solve(n, x, vouchers):\n    vouchers.sort(key=lambda x: x[2])\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            li1, ri1, cost1 = vouchers[i]\n            li2, ri2, cost2 = vouchers[j]\n            if (ri1 < li2 or ri2 < li1) and (ri1 - li1 + 1 + ri2 - li2 + 1 == x):\n                min_cost = min(min_cost, cost1 + cost2)\n    return min_cost if min_cost != float('inf') else -1\n\ndef main():\n    n, x, vouchers = read_input()\n    result = solve(n, x, vouchers)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1846E2", "completion": "def check_snowflake(n, k):\n    if n <= 1:\n        return False\n    if n == 2:\n        return False\n    if n % 2 == 0 and k == 2:\n        return False\n\n    res = 1\n    while True:\n        new_res = res * (k - 1) + 1\n        if new_res > n:\n            break\n        res = new_res\n        if res == n:\n            return True\n    return False\n\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    k = 4\n    for i in range(3, 100):\n        if check_snowflake(n, i):\n            print(\"YES\")\n            break\n    else:\n        print(\"NO\")"}
{"task_id": "E2H_CF270E", "completion": "import sys\n\ndef read_input():\n    lines = sys.stdin.readlines()\n    n, m = map(int, lines[0].split())\n    edges = []\n    for i in range(1, m + 1):\n        u, v, c = map(int, lines[i].split())\n        edges.append((u, v, c))\n    return n, m, edges\n\ndef find_direction(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, c in edges:\n        graph[u].append((v, c))\n        graph[v].append((u, c))\n\n    visited = [False] * (n + 1)\n    stack = [1]\n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            visited[node] = True\n            for neighbor, _ in graph[node]:\n                if not visited[neighbor]:\n                    stack.append(neighbor)\n\n    max_flow = 0\n    parent = [-1] * (n + 1)\n    def bfs(graph, s, t, parent):\n        visited = [False] * (n + 1)\n        queue = [s]\n        visited[s] = True\n        while queue:\n            node = queue.pop(0)\n            for neighbor, capacity in graph[node]:\n                if not visited[neighbor] and capacity > 0:\n                    queue.append(neighbor)\n                    visited[neighbor] = True\n                    parent[neighbor] = node\n        return visited[t]\n\n    def dfs(graph, u, t, parent, flow):\n        if u == t:\n            return flow\n        for neighbor, capacity in graph[u]:\n            if parent[u] == neighbor and capacity > 0:\n                residual_capacity = dfs(graph, neighbor, t, parent, min(flow, capacity))\n                if residual_capacity > 0:\n                    graph[u][graph[u].index((neighbor, capacity))]=(neighbor, capacity-residual_capacity)\n                    graph[neighbor][graph[neighbor].index((u, capacity-residual_capacity))]=(u, capacity-residual_capacity)\n                    return residual_capacity\n        return 0\n\n    while bfs(graph, 1, n, parent):\n        flow = dfs(graph, 1, n, parent, float('inf'))\n        max_flow += flow\n\n    direction = [0] * len(edges)\n    for i, (u, v, c) in enumerate(edges):\n        if graph[u][graph[u].index((v, c))][1] == 0:\n            direction[i] = 1\n    return direction\n\ndef main():\n    n, m, edges = read_input()\n    direction = find_direction(n, edges)\n    print('\\n'.join(map(str, direction)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF808E", "completion": "import sys\n\ndef solve():\n    n, m = map(int, input().split())\n    souvenirs = []\n    for _ in range(n):\n        w, c = map(int, input().split())\n        souvenirs.append((w, c))\n\n    souvenirs.sort(key=lambda x: x[1] / x[0], reverse=True)\n\n    max_cost = 0\n    remaining_weight = m\n\n    for weight, cost in souvenirs:\n        if remaining_weight >= weight:\n            max_cost += cost\n            remaining_weight -= weight\n        else:\n            max_cost += (remaining_weight / weight) * cost\n            break\n\n    print(int(max_cost))\n\nif __name__ == \"__main__\":\n    t = 1\n    for _ in range(t):\n        solve()"}
{"task_id": "E2H_CF409I", "completion": "import sys\n\ndef feed_golorp(program):\n    program = list(program)\n    stack = []\n    directions = {'<': -1, '>': 1}\n    for i in range(len(program)):\n        if program[i] == '_':\n            stack.append((i, 0))\n        elif program[i] in directions:\n            j, value = stack.pop()\n            if program[i] == '>':\n                value = min(9, value + directions[program[i]])\n            else:\n                value = max(0, value + directions[program[i]])\n            stack[-1] = (j, value)\n        elif program[i] == '-':\n            if stack:\n                _, value = stack[-1]\n                stack[-1] = (stack[-1][0], max(0, value - 1))\n        elif program[i] == '+':\n            if stack:\n                _, value = stack[-1]\n                stack[-1] = (stack[-1][0], min(9, value + 1))\n        elif program[i] == '*':\n            if stack:\n                _, value = stack[-1]\n                stack[-1] = (stack[-1][0], value * 10 + stack[-1][1])\n        elif program[i] == '/':\n            if stack:\n                _, value = stack.pop()\n                stack[-1] = (stack[-1][0], stack[-1][1] // value)\n        elif program[i] == '?':\n            if stack:\n                _, value = stack.pop()\n                if value == 0:\n                    return 'false'\n        elif program[i] == ':':\n            if stack:\n                _, value = stack.pop()\n                if value == 9:\n                    return 'false'\n        elif program[i] == ',':\n            if stack:\n                _, value = stack.pop()\n                stack.append((i, value))\n        elif program[i] == '.':\n            if stack:\n                _, value = stack.pop()\n                result.append(str(value))\n    return ''.join(result)\n\nresult = []\nline = input().strip()\nprint(feed_golorp(line))"}
{"task_id": "E2H_CF151A", "completion": "def soft_drinking():\n    # Read input from standard input\n    n, k, l, c, d, p, nl, np = map(int, input().split())\n\n    # Calculate the total amount of drink, limes and salt\n    total_drink = k * l\n    total_limes = c * d\n    total_salt = p\n\n    # Calculate the maximum number of toasts for each resource\n    max_toasts_drink = total_drink // (nl * n)\n    max_toasts_limes = total_limes // n\n    max_toasts_salt = total_salt // (np * n)\n\n    # Return the minimum number of toasts that can be made\n    return min(max_toasts_drink, max_toasts_limes, max_toasts_salt)\n\n# Test the function with the provided examples\nprint(soft_drinking())\nprint(soft_drinking())\nprint(soft_drinking())"}
{"task_id": "E2H_CF339B", "completion": "import sys\n\ndef solve():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    last = 0\n    ans = 0\n    for i in range(m):\n        if a[i] > last:\n            ans += a[i] - last\n        else:\n            ans += n - last + a[i]\n        last = a[i]\n\n    ans += n - last\n    print(ans)\n\nif __name__ == \"__main__\":\n    t = 1\n    while t > 0:\n        solve()\n        t -= 1"}
{"task_id": "E2H_CF88A", "completion": "import sys\n\ndef distance(note1, note2):\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    idx1 = notes.index(note1)\n    idx2 = notes.index(note2)\n    if idx1 > idx2:\n        idx1 += 12\n    return (idx2 - idx1) % 12\n\ndef is_major(triad):\n    a, b, c = triad\n    d_ab = distance(a, b)\n    d_bc = distance(b, c)\n    d_ac = distance(a, c)\n    return d_ab == 4 and d_bc == 3 and d_ac == 7\n\ndef is_minor(triad):\n    a, b, c = triad\n    d_ab = distance(a, b)\n    d_bc = distance(b, c)\n    d_ac = distance(a, c)\n    return d_ab == 3 and d_bc == 4 and d_ac == 7\n\ndef solve():\n    notes = input().split()\n    triad = sorted(notes)\n    if is_major(triad):\n        print(\"major\")\n    elif is_minor(triad):\n        print(\"minor\")\n    else:\n        print(\"strange\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF633B", "completion": "import math\n\ndef count_trailing_zeroes(n):\n    \"\"\"\n    Count the number of trailing zeroes in n!\n    \"\"\"\n    count = 0\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n    return count\n\ndef find_n(m):\n    \"\"\"\n    Find all positive integers n such that the factorial of n ends with exactly m zeroes.\n    \"\"\"\n    count = 0\n    result = []\n    n = 1\n    while True:\n        if count_trailing_zeroes(n) == m:\n            result.append(n)\n            count += 1\n        elif count_trailing_zeroes(n) > m:\n            break\n        n += 1\n    return count, result\n\ndef main():\n    m = int(input())\n    count, result = find_n(m)\n    print(count)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1767D", "completion": "def solve():\n    n = int(input())\n    s = input()\n    count = 0\n    for c in s:\n        if c == '1':\n            count += 1\n    start = 2 ** (n - count)\n    end = 2 ** n\n    print(' '.join(map(str, range(start, end + 1))))\n\nt = 1\n\nfor _ in range(t):\n    solve()"}
{"task_id": "E2H_CF498A", "completion": "import sys\n\ndef cross_product(p1, p2):\n    return p1[0] * p2[1] - p1[1] * p2[0]\n\ndef orientation(p1, p2, p3):\n    return cross_product((p2[0] - p1[0], p2[1] - p1[1]), (p3[0] - p1[0], p3[1] - p1[1]))\n\ndef intersect(p1, p2, l1, l2):\n    d = cross_product(l1, l2)\n    if d == 0:\n        return None\n    t = cross_product((p2[0] - p1[0], p2[1] - p1[1]), l2) / d\n    return (p1[0] + l1[0] * t, p1[1] + l1[1] * t)\n\ndef on_segment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n            q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\ndef do_intersect(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if (o1 != o2 and o3 != o4):\n        return True\n\n    if (o1 == 0 and on_segment(p1, p2, q1)):\n        return True\n\n    if (o2 == 0 and on_segment(p1, q2, q1)):\n        return True\n\n    if (o3 == 0 and on_segment(p2, p1, q2)):\n        return True\n\n    if (o4 == 0 and on_segment(p2, q1, q2)):\n        return True\n\n    return False\n\ndef get_intersection(line1, line2):\n    a1, b1, c1 = line1\n    a2, b2, c2 = line2\n    if a1 * b2 == a2 * b1:\n        return None\n    x = (b2 * c1 - b1 * c2) / (a1 * b2 - a2 * b1)\n    y = (a1 * c2 - a2 * c1) / (a2 * b1 - a1 * b2)\n    return (x, y)\n\ndef solve():\n    home = [int(x) for x in input().split()]\n    university = [int(x) for x in input().split()]\n    n = int(input())\n    lines = []\n    for _ in range(n):\n        line = [int(x) for x in input().split()]\n        lines.append(line)\n\n    visited = set()\n    queue = [(home, 0)]\n\n    while queue:\n        point, dist = queue.pop(0)\n        if point == university:\n            print(dist)\n            return\n        for line in lines:\n            intersection = intersect(point, university, (-line[1], line[0]), line)\n            if intersection is not None and intersection not in visited:\n                visited.add(intersection)\n                queue.append((intersection, dist + 1))\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF1092C", "completion": "import sys\n\ndef read_input():\n    n = int(input())\n    prefixes = []\n    suffixes = []\n    for _ in range(2 * n - 2):\n        s = input()\n        if len(s) == n - 1:\n            prefixes.append(s)\n        else:\n            suffixes.append(s)\n    return n, prefixes, suffixes\n\ndef solve(n, prefixes, suffixes):\n    prefix_dict = {}\n    suffix_dict = {}\n    for prefix in prefixes:\n        if len(prefix) not in prefix_dict:\n            prefix_dict[len(prefix)] = [prefix]\n        else:\n            prefix_dict[len(prefix)].append(prefix)\n    for suffix in suffixes:\n        if len(suffix) not in suffix_dict:\n            suffix_dict[len(suffix)] = [suffix]\n        else:\n            suffix_dict[len(suffix)].append(suffix)\n\n    result = [''] * (2 * n - 2)\n    for i in range(1, n):\n        prefix = prefix_dict[i][0]\n        suffix = suffix_dict[i][0]\n        if prefix + suffix == prefix_dict[i + 1][0]:\n            result[prefixes.index(prefix)] = 'P'\n            result[suffixes.index(suffix)] = 'S'\n        else:\n            result[prefixes.index(prefix)] = 'S'\n            result[suffixes.index(suffix)] = 'P'\n\n    return ''.join(result)\n\ndef main():\n    n, prefixes, suffixes = read_input()\n    print(solve(n, prefixes, suffixes))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1146D", "completion": "def solve():\n    m, a, b = map(int, input().split())\n    dp = [0] * (m + 1)\n    dp[0] = 1\n\n    for i in range(1, m + 1):\n        if i - b >= 0:\n            dp[i] += dp[i - b]\n        if i - a >= 0:\n            dp[i] += dp[i - a]\n\n    ans = 0\n    for i in range(m + 1):\n        ans += dp[i]\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    t = 1\n    while t > 0:\n        solve()\n        t -= 1"}
{"task_id": "E2H_CF980E", "completion": "import sys\n\ndef read_input():\n    lines = sys.stdin.readlines()\n    n, k = map(int, lines[0].split())\n    graph = [[] for _ in range(n)]\n    for i in range(1, n):\n        u, v = map(int, lines[i].split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    return n, k, graph\n\ndef dfs(node, parent, visited, depth, graph):\n    visited[node] = True\n    max_depth = depth\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            max_depth = max(max_depth, dfs(neighbor, node, visited, depth + 1, graph))\n    return max_depth\n\ndef find_min_removal(n, k, graph):\n    visited = [False] * n\n    min_removal = []\n    for i in range(n):\n        if not visited[i]:\n            max_depth = dfs(i, -1, visited, 0, graph)\n            removal_count = max_depth - 1\n            while removal_count > 0 and len(min_removal) < k:\n                min_removal.append(i + 1)\n                removal_count -= 1\n                i = graph[i][-1]\n                visited[i] = True\n    return ' '.join(map(str, sorted(min_removal)))\n\ndef main():\n    n, k, graph = read_input()\n    print(find_min_removal(n, k, graph))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1709F", "completion": "import sys\n\ndef read_input():\n    return map(int, input().split())\n\nMOD = 998244353\n\ndef solve(n, k, f):\n    if n > 20:\n        return 0\n\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        cur_sum = 0\n        for j in range(k + 1):\n            cur_sum += dp[i - 1][j]\n            cur_sum %= MOD\n            dp[i][j] = cur_sum\n\n        for j in range(k + 1):\n            for prev_j in range(max(0, j - i), j):\n                dp[i][j] -= dp[i - 1][prev_j]\n                if dp[i][j] < 0:\n                    dp[i][j] += MOD\n\n    ans = 0\n    for c in range(f - 1, k + 1):\n        ans += dp[n][c]\n\n    return ans % MOD\n\nif __name__ == \"__main__\":\n    t = 1\n    for _ in range(t):\n        n, k, f = read_input()\n        print(solve(n, k, f))"}
