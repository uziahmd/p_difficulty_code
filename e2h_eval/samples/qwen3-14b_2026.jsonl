{"task_id": "E2H_CF1031A", "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    w, h, k = map(int, input().split())\n    \n    total = 0\n    for i in range(k):\n        width = w - 4 * i\n        height = h - 4 * i\n        perimeter = 2 * (width + height - 2)\n        total += perimeter\n    print(total)"}
{"task_id": "E2H_CF151A", "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    l = int(data[2])\n    c = int(data[3])\n    d = int(data[4])\n    p = int(data[5])\n    nl = int(data[6])\n    np = int(data[7])\n    \n    total_drink = k * l\n    total_lime_slices = c * d\n    total_salt = p\n    \n    toasts_by_drink = total_drink // nl\n    toasts_by_lime = total_lime_slices // n\n    toasts_by_salt = total_salt // np\n    \n    print(min(toasts_by_drink, toasts_by_lime, toasts_by_salt))"}
{"task_id": "E2H_CF404A", "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    grid = data[1:]\n    \n    # Check if n is odd (as per problem statement, it should be)\n    if n % 2 == 0:\n        print(\"NO\")\n        return\n    \n    # Get the two diagonal characters\n    diag1_char = grid[0][0]\n    diag2_char = grid[0][n - 1]\n    \n    # If diagonals are not the same, it's not an X\n    if diag1_char != diag2_char:\n        print(\"NO\")\n        return\n    \n    # Character for non-diagonal cells\n    other_char = None\n    \n    for i in range(n):\n        for j in range(n):\n            if i == j or i + j == n - 1:\n                # On diagonal\n                if grid[i][j] != diag1_char:\n                    print(\"NO\")\n                    return\n            else:\n                # Not on diagonal\n                if other_char is None:\n                    other_char = grid[i][j]\n                elif grid[i][j] != other_char:\n                    print(\"NO\")\n                    return\n    \n    # Ensure that the diagonal character is different from the other character\n    if diag1_char == other_char:\n        print(\"NO\")\n    else:\n        print(\"YES\")"}
{"task_id": "E2H_CF339B", "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    tasks = list(map(int, data[2:2 + m]))\n    \n    current_position = 1\n    total_time = 0\n    \n    for task in tasks:\n        if task == current_position:\n            continue\n        elif task > current_position:\n            total_time += task - current_position\n            current_position = task\n        else:\n            total_time += (n - current_position + task)\n            current_position = task\n    \n    print(total_time)"}
{"task_id": "E2H_CF492B", "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    l = int(data[1])\n    a = list(map(int, data[2:2 + n]))\n    \n    a.sort()\n    \n    max_distance = 0.0\n    \n    # Check the distance from the first lantern to the start of the street\n    max_distance = max(max_distance, a[0])\n    \n    # Check the distance from the last lantern to the end of the street\n    max_distance = max(max_distance, l - a[-1])\n    \n    # Check the maximum gap between consecutive lanterns\n    for i in range(1, n):\n        gap = (a[i] - a[i - 1]) / 2.0\n        max_distance = max(max_distance, gap)\n    \n    print(\"{0:.10f}\".format(max_distance))"}
{"task_id": "E2H_CF88A", "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n\n    # Define the order of notes\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\n    # Map each note to its index\n    note_to_index = {note: idx for idx, note in enumerate(notes)}\n\n    # Read input\n    data = input().strip()\n    chord = data.split()\n\n    # Generate all permutations of the three notes\n    from itertools import permutations\n    perms = permutations(chord)\n\n    is_major = False\n    is_minor = False\n\n    for perm in perms:\n        x, y, z = perm\n        x_idx = note_to_index[x]\n        y_idx = note_to_index[y]\n        z_idx = note_to_index[z]\n\n        # Calculate distances considering cyclic nature\n        def distance(a, b):\n            return (b - a) % 12\n\n        d1 = distance(x_idx, y_idx)\n        d2 = distance(y_idx, z_idx)\n\n        if d1 == 4 and d2 == 3:\n            is_major = True\n        elif d1 == 3 and d2 == 4:\n            is_minor = True\n\n    if is_major:\n        print(\"major\")\n    elif is_minor:\n        print(\"minor\")\n    else:\n        print(\"strange\")"}
{"task_id": "E2H_CF173A", "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    A = data[1]\n    B = data[2]\n    \n    m = len(A)\n    k = len(B)\n    \n    # Precompute the results for one full cycle of A and B\n    # We'll simulate min(m * k, n) rounds to find a pattern\n    max_cycle = min(m * k, n)\n    \n    red_nike = 0\n    red_poly = 0\n    \n    for i in range(max_cycle):\n        a = A[i % m]\n        b = B[i % k]\n        if a == b:\n            continue\n        if (a == 'R' and b == 'S') or (a == 'S' and b == 'P') or (a == 'P' and b == 'R'):\n            red_poly += 1\n        else:\n            red_nike += 1\n    \n    # If n is larger than max_cycle, compute how many full cycles and remaining rounds\n    full_cycles = n // max_cycle\n    remainder = n % max_cycle\n    \n    red_nike_total = red_nike * full_cycles\n    red_poly_total = red_poly * full_cycles\n    \n    # Add results from the remaining rounds\n    for i in range(remainder):\n        a = A[i % m]\n        b = B[i % k]\n        if a == b:\n            continue\n        if (a == 'R' and b == 'S') or (a == 'S' and b == 'P') or (a == 'P' and b == 'R'):\n            red_poly_total += 1\n        else:\n            red_nike_total += 1\n    \n    print(red_nike_total, red_poly_total)"}
{"task_id": "E2H_CF633B", "completion": "import sys\n\ndef count_trailing_zeros(n):\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n\ndef solve():\n    m = int(sys.stdin.readline())\n    \n    # Binary search to find the smallest n such that count_trailing_zeros(n) == m\n    low, high = 0, 5 * m\n    answer = -1\n    while low <= high:\n        mid = (low + high) // 2\n        tz = count_trailing_zeros(mid)\n        if tz == m:\n            answer = mid\n            break\n        elif tz < m:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    if answer == -1:\n        print(0)\n        return\n\n    # Find all n such that count_trailing_zeros(n) == m\n    # These n's are consecutive numbers from answer to answer + 4 (or until trailing zeros increase)\n    res = []\n    for i in range(answer, answer + 5):\n        if count_trailing_zeros(i) == m:\n            res.append(i)\n        else:\n            break\n\n    print(len(res))\n    print(' '.join(map(str, res)))"}
{"task_id": "E2H_CF1141D", "completion": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split('\\n')\n    \n    n = int(data[0])\n    l = data[1]\n    r = data[2]\n\n    # Map to store count of each color for left and right boots\n    left_count = defaultdict(int)\n    right_count = defaultdict(int)\n\n    # Count the number of each color in left and right boots\n    for c in l:\n        if c != '?':\n            left_count[c] += 1\n    for c in r:\n        if c != '?':\n            right_count[c] += 1\n\n    # Match specific colors first\n    matched = 0\n    pairs = []\n\n    # Try to match specific colors\n    for color in left_count:\n        if color in right_count:\n            match = min(left_count[color], right_count[color])\n            matched += match\n            # We'll record the actual indices later\n            # For now, just reduce the counts\n            left_count[color] -= match\n            right_count[color] -= match\n\n    # Now handle question marks\n    # Match left '?' with right non-?\n    q_left = left_count['?']\n    for color in right_count:\n        if color != '?':\n            match = min(q_left, right_count[color])\n            matched += match\n            q_left -= match\n\n    # Match right '?' with left non-?\n    q_right = right_count['?']\n    for color in left_count:\n        if color != '?':\n            match = min(q_right, left_count[color])\n            matched += match\n            q_right -= match\n\n    # Match remaining '?' with '?'\n    matched += min(q_left, q_right)\n\n    # Now, we need to output the actual pairs\n    # We will build two lists: used_left and used_right\n    used_left = [False] * n\n    used_right = [False] * n\n\n    # First, match specific colors\n    left_color_map = defaultdict(list)\n    right_color_map = defaultdict(list)\n\n    for i in range(n):\n        if l[i] != '?':\n            left_color_map[l[i]].append(i)\n        if r[i] != '?':\n            right_color_map[r[i]].append(i)\n\n    # Match specific colors\n    for color in left_color_map:\n        if color in right_color_map:\n            left_indices = left_color_map[color]\n            right_indices = right_color_map[color]\n            for i in range(min(len(left_indices), len(right_indices))):\n                a = left_indices[i]\n                b = right_indices[i]\n                if not used_left[a] and not used_right[b]:\n                    pairs.append((a + 1, b + 1))\n                    used_left[a] = True\n                    used_right[b] = True\n\n    # Match left '?' with right non-?\n    left_q = []\n    for i in range(n):\n        if l[i] == '?':\n            left_q.append(i)\n\n    for color in right_color_map:\n        if color != '?':\n            right_indices = right_color_map[color]\n            for idx in right_indices:\n                if not used_right[idx]:\n                    for i in range(len(left_q)):\n                        if not used_left[left_q[i]]:\n                            pairs.append((left_q[i] + 1, idx + 1))\n                            used_left[left_q[i]] = True\n                            used_right[idx] = True\n                            break\n\n    # Match right '?' with left non-?\n    right_q = []\n    for i in range(n):\n        if r[i] == '?':\n            right_q.append(i)\n\n    for color in left_color_map:\n        if color != '?':\n            left_indices = left_color_map[color]\n            for idx in left_indices:\n                if not used_left[idx]:\n                    for i in range(len(right_q)):\n                        if not used_right[right_q[i]]:\n                            pairs.append((idx + 1, right_q[i] + 1))\n                            used_left[idx] = True\n                            used_right[right_q[i]] = True\n                            break\n\n    # Match remaining '?' with '?'\n    left_q_remaining = [i for i in range(n) if l[i] == '?' and not used_left[i]]\n    right_q_remaining = [i for i in range(n) if r[i] == '?' and not used_right[i]]\n\n    for i in range(min(len(left_q_remaining), len(right_q_remaining))):\n        a = left_q_remaining[i]\n        b = right_q_remaining[i]\n        pairs.append((a + 1, b + 1))\n\n    print(len(pairs))\n    for pair in pairs:\n        print(pair[0], pair[1])"}
{"task_id": "E2H_CF1767D", "completion": "import sys\nimport math\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    s = data[1]\n    \n    total_teams = 2 ** n\n    \n    # We will simulate the tournament for each possible x from 1 to total_teams\n    # and check if x can be the champion under the given rules.\n    \n    def can_win(x):\n        # Create a list of teams with their skill levels\n        teams = list(range(1, total_teams + 1))\n        \n        # Simulate each phase of the tournament\n        for i in range(n):\n            phase = s[i]\n            num_games = 2 ** (n - i - 1)\n            new_teams = []\n            \n            for j in range(num_games):\n                team1 = teams[2 * j]\n                team2 = teams[2 * j + 1]\n                \n                if phase == '0':\n                    # Lower skill level wins\n                    winner = team1 if team1 < team2 else team2\n                else:\n                    # Higher skill level wins\n                    winner = team1 if team1 > team2 else team2\n                \n                new_teams.append(winner)\n            \n            teams = new_teams\n        \n        return teams[0] == x\n    \n    winning_numbers = [x for x in range(1, total_teams + 1) if can_win(x)]\n    \n    print(' '.join(map(str, winning_numbers)))"}
{"task_id": "E2H_CF822C", "completion": "import sys\nimport bisect\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    \n    vouchers = []\n    idx = 2\n    for _ in range(n):\n        l = int(data[idx])\n        r = int(data[idx+1])\n        cost = int(data[idx+2])\n        vouchers.append((l, r, cost))\n        idx += 3\n    \n    # Sort vouchers by their end date\n    vouchers.sort(key=lambda v: v[1])\n    \n    # Preprocess: For each voucher, store the minimum cost for each duration\n    # We will use two arrays:\n    # left_min: min cost for a voucher ending at or before day i with duration d\n    # right_min: min cost for a voucher starting at or after day i with duration d\n    \n    max_day = 2 * 10**5 + 2\n    left_min = [float('inf')] * (max_day + 2)\n    right_min = [float('inf')] * (max_day + 2)\n    \n    # Fill left_min\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if duration > x:\n            continue\n        if left_min[r] > cost:\n            left_min[r] = cost\n    \n    # Fill right_min\n    for l, r, cost in reversed(vouchers):\n        duration = r - l + 1\n        if duration > x:\n            continue\n        if right_min[l] > cost:\n            right_min[l] = cost\n    \n    # Now, for each voucher, check if there's a compatible voucher on the other side\n    min_cost = float('inf')\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if duration > x:\n            continue\n        \n        needed_duration = x - duration\n        # Check for a voucher that starts after r\n        start = r + 1\n        if start <= max_day and right_min[start] != float('inf'):\n            total_cost = cost + right_min[start]\n            if total_cost < min_cost:\n                min_cost = total_cost\n        \n        # Check for a voucher that ends before l\n        end = l - 1\n        if end >= 0 and left_min[end] != float('inf'):\n            total_cost = cost + left_min[end]\n            if total_cost < min_cost:\n                min_cost = total_cost\n    \n    if min_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_cost)"}
{"task_id": "E2H_CF498A", "completion": "import sys\nfrom collections import deque\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split('\\n')\n    \n    x1, y1 = map(int, data[0].split())\n    x2, y2 = map(int, data[1].split())\n    n = int(data[2])\n    roads = []\n    for i in range(3, 3 + n):\n        a, b, c = map(int, data[i].split())\n        roads.append((a, b, c))\n    \n    # Function to determine which side of the line (a, b, c) a point (x, y) is on\n    def side(a, b, c, x, y):\n        return a * x + b * y + c\n    \n    # Function to check if two lines are parallel\n    def are_parallel(a1, b1, a2, b2):\n        return a1 * b2 == a2 * b1\n    \n    # Function to check if two lines intersect at a point\n    def intersect(a1, b1, c1, a2, b2, c2):\n        # Check if they are parallel\n        if are_parallel(a1, b1, a2, b2):\n            return False\n        # Solve the system of equations\n        det = a1 * b2 - a2 * b1\n        x = (b1 * c2 - b2 * c1) / det\n        y = (a2 * c1 - a1 * c2) / det\n        return (x, y)\n    \n    # Function to compute the sign of a point with respect to a line\n    def sign(a, b, c, x, y):\n        return a * x + b * y + c\n    \n    # Function to get the region ID for a point\n    def get_region(point):\n        signs = []\n        for a, b, c in roads:\n            s = sign(a, b, c, *point)\n            signs.append(s)\n        return tuple(signs)\n    \n    home_region = get_region((x1, y1))\n    univ_region = get_region((x2, y2))\n    \n    if home_region == univ_region:\n        print(0)\n        return\n    \n    # BFS to find minimum steps\n    from collections import defaultdict\n\n    graph = defaultdict(list)\n\n    # For each line, determine which regions are adjacent\n    # We'll use the sign pattern as a key\n    regions = set()\n    for a, b, c in roads:\n        for point in [(x1, y1), (x2, y2)]:\n            regions.add(get_region(point))\n    \n    # To avoid infinite loops, we need to generate all possible regions\n    # But that's not feasible directly. Instead, we'll build the graph dynamically\n    # by checking adjacent regions through each line\n\n    visited = set()\n    queue = deque()\n    queue.append((home_region, 0))\n    visited.add(home_region)\n\n    while queue:\n        current_region, steps = queue.popleft()\n        if current_region == univ_region:\n            print(steps)\n            return\n        for a, b, c in roads:\n            # For this line, find all regions that are on the opposite side\n            for other_region in list(visited):  # This is not efficient, but for small n it works\n                if current_region == other_region:\n                    continue\n                # Check if they are separated by this line\n                s1 = sign(a, b, c, *current_region)\n                s2 = sign(a, b, c, *other_region)\n                if s1 * s2 < 0:\n                    # They are on different sides of this line, so they are adjacent\n                    if other_region not in visited:\n                        visited.add(other_region)\n                        queue.append((other_region, steps + 1))\n\n    print(-1)  # Should not happen per problem statement"}
{"task_id": "E2H_CF1846E2", "completion": "import sys\nimport math\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    cases = list(map(int, data[1:t+1]))\n    \n    def is_snowflake(n):\n        if n == 1:\n            return False\n        # Check if n can be represented as (k^d - 1) // (k - 1) for some k > 1 and d >= 2\n        # We iterate over possible depths d from 2 to log2(n) + 1\n        max_depth = int(math.log(n, 2)) + 2\n        for d in range(2, max_depth + 1):\n            # Try to find k such that (k^d - 1) // (k - 1) == n\n            low = 2\n            high = int(n ** (1.0 / (d - 1))) + 2\n            while low <= high:\n                mid = (low + high) // 2\n                total = 1\n                for _ in range(d):\n                    total = total * mid + 1\n                if total == n:\n                    return True\n                elif total < n:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n        return False\n    \n    results = []\n    for n in cases:\n        if is_snowflake(n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))"}
{"task_id": "E2H_CF1092C", "completion": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    strings = data[1:]\n    \n    # We need to find the correct string s of length n\n    # that has all the given strings as its prefixes or suffixes\n    \n    # Try each string as a candidate for the full string s\n    for candidate in strings:\n        if len(candidate) == n:\n            s = candidate\n            break\n    else:\n        # If no string of length n is found, build it from prefixes\n        # Take the longest prefix (length n-1) and add one character\n        # This is a heuristic since the input guarantees a valid string exists\n        for candidate in strings:\n            if len(candidate) == n - 1:\n                s = candidate + 'a'  # arbitrary character, will be validated\n                break\n\n    # Now determine which of the input strings are prefixes and which are suffixes\n    result = []\n    for string in strings:\n        if s.startswith(string):\n            result.append('P')\n        elif s.endswith(string):\n            result.append('S')\n        else:\n            # This should not happen due to problem constraints\n            result.append('P')  # fallback, though it's guaranteed to be valid\n\n    print(''.join(result))"}
{"task_id": "E2H_CF270E", "completion": "import sys\nimport threading\nfrom collections import deque\n\ndef solve():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b, c = map(int, sys.stdin.readline().split())\n        edges.append((a, b, c))\n        graph[a].append((b, i))\n        graph[b].append((a, i))\n\n    # We will perform a DFS to assign directions and ensure no cycles\n    # We need to build a directed acyclic graph (DAG) with vertex 1 as the root\n    # and all other vertices having in-degree equal to out-degree except for source and sink\n\n    # To ensure no cycles, we can perform a topological sort or use DFS with a visited set\n    # Here, we'll use DFS and assign directions accordingly\n\n    direction = [0] * m  # 0 means ai -> bi, 1 means bi -> ai\n    visited = [False] * (n + 1)\n\n    def dfs(u):\n        visited[u] = True\n        for v, idx in graph[u]:\n            if not visited[v]:\n                # Assign direction from u to v\n                a, b, c = edges[idx]\n                if a == u and b == v:\n                    direction[idx] = 0\n                elif b == u and a == v:\n                    direction[idx] = 1\n                else:\n                    # This should not happen since the graph is undirected and we are traversing it properly\n                    pass\n                dfs(v)\n\n    dfs(1)\n\n    for d in direction:\n        print(d)"}
{"task_id": "E2H_CF1146D", "completion": "import sys\nimport math\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    m, a, b = map(int, input().split())\n\n    # If a and b are not coprime, then the frog can only reach positions that are multiples of gcd(a, b)\n    g = math.gcd(a, b)\n    a //= g\n    b //= g\n\n    # Now a and b are coprime\n\n    # The frog can reach any position that is a multiple of gcd(a, b) and within [0, x]\n    # So we need to count how many such positions are reachable for each x from 0 to m\n\n    # The number of reachable positions for x is floor(x / g) + 1 if x >= 0\n    # But we have to consider that the frog cannot go below 0 or above x\n\n    # However, since the frog can move forward by a and backward by b, it can reach any position that is congruent to 0 mod g\n    # And since a and b are coprime, the frog can reach any such position\n\n    # So for each x in [0, m], f(x) = floor(x / g) + 1\n    # Therefore, the sum is sum_{x=0}^m (floor(x / g) + 1)\n\n    # Sum of floor(x / g) from x=0 to m is equal to sum_{k=0}^{floor(m/g)} k * g\n    # But more accurately: sum_{x=0}^m floor(x / g) = sum_{k=0}^{floor(m/g)} k * (number of x with floor(x/g) = k)\n    # Which simplifies to sum_{k=0}^{floor(m/g)} k * g if m >= k*g and < (k+1)*g\n\n    # We can compute it as:\n    # Let q = m // g\n    # sum_{x=0}^m floor(x / g) = sum_{k=0}^{q-1} k * g + q * (m - q * g + 1)\n    # But there's a simpler formula: sum_{x=0}^m floor(x / g) = (q * (q - 1) // 2) * g + q * (m - q * g + 1)\n\n    # However, we can use the formula:\n    # sum_{x=0}^m floor(x / g) = (m - r) * (m - r + 1) // (2 * g) - r * (r + 1) // (2 * g)\n    # where r = m % g\n    # But this is complicated. Instead, use the formula:\n    # sum_{x=0}^m floor(x / g) = (m // g) * (m // g - 1) // 2 * g + (m % g + 1) * (m // g)\n\n    q = m // g\n    r = m % g\n    sum_floor = q * (q - 1) // 2 * g + (r + 1) * q\n\n    # Sum of 1 from x=0 to m is m + 1\n    total_sum = sum_floor + (m + 1)\n    print(total_sum)"}
{"task_id": "E2H_CF808E", "completion": "import sys\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    weight1 = []\n    weight2 = []\n    weight3 = []\n    \n    index = 2\n    for _ in range(n):\n        w = int(data[index])\n        c = int(data[index + 1])\n        index += 2\n        if w == 1:\n            weight1.append(c)\n        elif w == 2:\n            weight2.append(c)\n        else:\n            weight3.append(c)\n    \n    # Sort the lists in descending order of cost\n    weight1.sort(reverse=True)\n    weight2.sort(reverse=True)\n    weight3.sort(reverse=True)\n    \n    # Count how many of each weight we can take\n    count1 = len(weight1)\n    count2 = len(weight2)\n    count3 = len(weight3)\n    \n    # Try all possible combinations of weight3 items\n    # Since weight3 items are heavy (weight 3), we can try taking up to m // 3 of them\n    max_cost = 0\n    for i in range(min(count3, m // 3) + 1):\n        remaining_weight = m - i * 3\n        # Now use weight2 items\n        j = min(count2, remaining_weight // 2)\n        remaining_weight -= j * 2\n        # Now use weight1 items\n        k = min(count1, remaining_weight)\n        total_cost = sum(weight1[:k]) + sum(weight2[:j]) + sum(weight3[:i])\n        if total_cost > max_cost:\n            max_cost = total_cost\n    \n    print(max_cost)"}
{"task_id": "E2H_CF980E", "completion": "import sys\nimport heapq\n\ndef solve():\n    import sys\n    sys.setrecursionlimit(1 << 25)\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    \n    from collections import defaultdict\n    \n    tree = defaultdict(list)\n    index = 2\n    for _ in range(n - 1):\n        a = int(data[index])\n        b = int(data[index + 1])\n        tree[a].append(b)\n        tree[b].append(a)\n        index += 2\n    \n    # We will use a priority queue to select which nodes to remove\n    # We want to keep the nodes with the highest 2^i values\n    # So we will remove the nodes with the smallest 2^i values first\n    # But we must ensure that the remaining nodes form a connected component\n    \n    # We need to find the subtree with the maximum sum of 2^i values\n    # This is equivalent to finding the subtree with the maximum number of high-numbered nodes\n    # We can do this using a greedy approach with DFS and a priority queue\n    \n    # We'll perform a DFS starting from node 1, and for each node, we'll keep track of the size of the subtree\n    # and the total value of the subtree. We'll use a priority queue to decide which subtrees to prune\n    \n    # We'll use a max-heap (simulated with negative values) to keep track of the best subtrees to keep\n    # We'll use a list to store the nodes to remove\n    \n    removed = []\n    \n    def dfs(node, parent):\n        total = 2 ** node\n        size = 1\n        heap = []\n        for neighbor in tree[node]:\n            if neighbor == parent:\n                continue\n            child_total, child_size = dfs(neighbor, node)\n            total += child_total\n            size += child_size\n            heapq.heappush(heap, (-child_total, -child_size, neighbor))\n        \n        # Now, we try to remove up to k nodes\n        while len(removed) < k and heap:\n            neg_total, neg_size, child = heapq.heappop(heap)\n            total -= (-neg_total)\n            size -= (-neg_size)\n            removed.append(child)\n        \n        return total, size\n    \n    dfs(1, -1)\n    \n    # Sort the removed nodes in increasing order\n    removed.sort()\n    print(' '.join(map(str, removed)))"}
{"task_id": "E2H_CF409I", "completion": "def solve():\n    import sys\n    from itertools import product\n\n    name = sys.stdin.readline().strip()\n\n    # Extract the part of the name that defines the jaws\n    jaws_part = name.split('):-')[0].split('?(')[1]\n\n    # Count the number of variables needed (each '_' is a variable)\n    num_vars = jaws_part.count('_')\n\n    # Determine the operations between variables\n    ops = []\n    i = 0\n    while i < len(jaws_part):\n        if jaws_part[i] == '_':\n            ops.append('var')\n            i += 1\n        elif jaws_part[i] in '+-*':\n            ops.append(jaws_part[i])\n            i += 1\n        else:\n            i += 1\n\n    # If there are no variables, it's impossible to feed\n    if num_vars == 0:\n        print(\"false\")\n        return\n\n    # Generate all possible sequences of digits with length num_vars\n    for digits in product(map(str, range(10)), repeat=num_vars):\n        sequence = ''.join(digits)\n        # Simulate the feeding process\n        stack = []\n        i = 0\n        valid = True\n        while i < len(ops):\n            if ops[i] == 'var':\n                stack.append(int(sequence[len(stack)]))\n                i += 1\n            else:\n                if len(stack) < 2:\n                    valid = False\n                    break\n                b = stack.pop()\n                a = stack.pop()\n                if ops[i] == '+':\n                    stack.append(a + b)\n                elif ops[i] == '-':\n                    stack.append(a - b)\n                elif ops[i] == '*':\n                    stack.append(a * b)\n                i += 1\n        if valid and len(stack) == 1 and stack[0] >= 0:\n            print(sequence)\n            return\n\n    print(\"false\")"}
{"task_id": "E2H_CF1709F", "completion": "import sys\nimport math\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef solve():\n    input = sys.stdin.read\n    n, k, f = map(int, input().split())\n\n    # Total number of binary strings of length from 1 to n\n    total_strings = (1 << n) - 1\n\n    # dp[i]: number of ways to assign c_s for all strings of length <= i such that the maximum size of beautiful multiset is exactly f\n    dp = [0] * (n + 1)\n    dp[0] = 1  # base case: no strings, trivially satisfies\n\n    # For each length l from 1 to n\n    for l in range(1, n + 1):\n        # Number of binary strings of length l\n        num_strings_l = 1 << l\n\n        # We need to ensure that the max beautiful multiset size is exactly f\n        # This is equivalent to ensuring that the sum of c_s for all strings of length l is <= f\n        # But we also have to consider the constraints from previous levels\n\n        # The number of ways to choose c_s for all strings of length l such that their sum is <= f\n        # and the previous dp[l-1] ways are valid\n        # So we compute the number of ways to assign values to c_s for strings of length l such that sum(c_s) <= f\n\n        # Let's compute the number of ways to choose c_s for all strings of length l with sum(c_s) <= f\n        # Each c_s can be from 0 to k\n        # So we use a 1D DP for this subproblem\n\n        # dp_sub[i]: number of ways to assign c_s for strings of length l with sum <= i\n        dp_sub = [0] * (f + 1)\n        dp_sub[0] = 1\n\n        for _ in range(num_strings_l):\n            new_dp = [0] * (f + 1)\n            for j in range(f + 1):\n                for c in range(0, min(k, f - j) + 1):\n                    new_dp[j + c] = (new_dp[j + c] + dp_sub[j]) % MOD\n            dp_sub = new_dp\n\n        # Now dp_sub[f] is the number of ways to assign c_s for strings of length l with sum <= f\n        # Multiply by dp[l-1] to get the total number of ways for length l\n        dp[l] = (dp[l - 1] * dp_sub[f]) % MOD\n\n    # The answer is dp[n]\n    print(dp[n])"}
