{"task_id": "E2H_CF1031A", "completion": "def solve():\n    w, h, k = map(int, input().split())\n\n    total_gilded_cells = 0\n\n    for i in range(k):\n        current_w = w - 4 * i\n        current_h = h - 4 * i\n\n        if current_w <= 0 or current_h <= 0:\n            break\n\n        # Calculate cells for the current ring\n        # A rectangle of size current_w x current_h has a perimeter of 2*(current_w + current_h) - 4\n        # This formula works for any current_w, current_h >= 1\n        # If current_w or current_h is 1, it's a line or a single cell\n        # For example, 1x5: 2*(1+5)-4 = 8 cells. (Correct)\n        # For 5x1: 2*(5+1)-4 = 8 cells. (Correct)\n        # For 1x1: 2*(1+1)-4 = 0 cells. (Incorrect, should be 1)\n        # The problem states rings, which implies a border.\n        # If current_w or current_h is 1, the \"bordering cells\" are all cells.\n        # Let's consider the general case:\n        # A ring of width 1 cell on a current_w x current_h rectangle.\n        # This means all cells on the perimeter.\n        # If current_w = 1, all 'h' cells are gilded.\n        # If current_h = 1, all 'w' cells are gilded.\n        # If current_w > 1 and current_h > 1:\n        # Number of cells = 2 * current_w + 2 * (current_h - 2)\n        # This simplifies to 2 * current_w + 2 * current_h - 4\n\n        if current_w == 1 and current_h == 1:\n            gilded_cells_current_ring = 1\n        elif current_w == 1:\n            gilded_cells_current_ring = current_h\n        elif current_h == 1:\n            gilded_cells_current_ring = current_w\n        else:\n            gilded_cells_current_ring = 2 * current_w + 2 * current_h - 4\n\n        total_gilded_cells += gilded_cells_current_ring\n\n    print(total_gilded_cells)\n\nsolve()"}
{"task_id": "E2H_CF404A", "completion": "def solve():\n    n = int(input())\n    grid = [input() for _ in range(n)]\n\n    if n == 0:\n        print(\"NO\")\n        return\n\n    diag_char = grid[0][0]\n    other_char = ''\n    \n    is_first_other = True\n\n    for r in range(n):\n        for c in range(n):\n            if r == c or r + c == n - 1:  # On a diagonal\n                if grid[r][c] != diag_char:\n                    print(\"NO\")\n                    return\n            else:  # Not on a diagonal\n                if is_first_other:\n                    other_char = grid[r][c]\n                    is_first_other = False\n                elif grid[r][c] != other_char:\n                    print(\"NO\")\n                    return\n\n    if diag_char == other_char:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n\nsolve()"}
{"task_id": "E2H_CF492B", "completion": "def solve():\n    n, l = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n\n    max_gap = 0\n    for i in range(1, n):\n        gap = a[i] - a[i-1]\n        if gap > max_gap:\n            max_gap = gap\n\n    d1 = max_gap / 2.0\n    d2 = a[0] - 0\n    d3 = l - a[n-1]\n\n    result = max(d1, d2, d3)\n    print(f\"{result:.10f}\")\n\nsolve()"}
{"task_id": "E2H_CF173A", "completion": "import sys\n\ndef solve():\n    lines = sys.stdin.readlines()\n    n = int(lines[0].strip())\n    a_str = lines[1].strip()\n    b_str = lines[2].strip()\n\n    m = len(a_str)\n    k = len(b_str)\n\n    def get_winner(choice1, choice2):\n        if choice1 == choice2:\n            return 0  # Draw\n        if (choice1 == 'R' and choice2 == 'S') or \\\n           (choice1 == 'S' and choice2 == 'P') or \\\n           (choice1 == 'P' and choice2 == 'R'):\n            return 1  # Player 1 wins\n        return 2  # Player 2 wins\n\n    nikephoros_losses = 0\n    polycarpus_losses = 0\n\n    # Calculate losses in one full cycle of (a_str, b_str)\n    # The length of one full cycle is LCM(m, k)\n    from math import gcd\n    lcm = (m * k) // gcd(m, k)\n\n    nikephoros_losses_cycle = 0\n    polycarpus_losses_cycle = 0\n\n    for i in range(lcm):\n        nikephoros_choice = a_str[i % m]\n        polycarpus_choice = b_str[i % k]\n        winner = get_winner(nikephoros_choice, polycarpus_choice)\n        if winner == 1:\n            polycarpus_losses_cycle += 1\n        elif winner == 2:\n            nikephoros_losses_cycle += 1\n\n    # Calculate losses for full cycles\n    num_full_cycles = n // lcm\n    nikephoros_losses += num_full_cycles * nikephoros_losses_cycle\n    polycarpus_losses += num_full_cycles * polycarpus_losses_cycle\n\n    # Calculate losses for the remaining rounds\n    remaining_rounds = n % lcm\n    for i in range(remaining_rounds):\n        nikephoros_choice = a_str[i % m]\n        polycarpus_choice = b_str[i % k]\n        winner = get_winner(nikephoros_choice, polycarpus_choice)\n        if winner == 1:\n            polycarpus_losses += 1\n        elif winner == 2:\n            nikephoros_losses += 1\n\n    sys.stdout.write(f\"{nikephoros_losses} {polycarpus_losses}\\n\")\n\nsolve()"}
{"task_id": "E2H_CF1141D", "completion": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    l_str = sys.stdin.readline().strip()\n    r_str = sys.stdin.readline().strip()\n\n    left_boots = [[] for _ in range(27)]  # 'a'-'z' -> 0-25, '?' -> 26\n    right_boots = [[] for _ in range(27)]\n\n    for i in range(n):\n        if l_str[i] == '?':\n            left_boots[26].append(i + 1)\n        else:\n            left_boots[ord(l_str[i]) - ord('a')].append(i + 1)\n\n    for i in range(n):\n        if r_str[i] == '?':\n            right_boots[26].append(i + 1)\n        else:\n            right_boots[ord(r_str[i]) - ord('a')].append(i + 1)\n\n    pairs = []\n\n    # 1. Match specific colors\n    for i in range(26):\n        while left_boots[i] and right_boots[i]:\n            pairs.append((left_boots[i].pop(), right_boots[i].pop()))\n\n    # 2. Match specific left with '?' right\n    for i in range(26):\n        while left_boots[i] and right_boots[26]:\n            pairs.append((left_boots[i].pop(), right_boots[26].pop()))\n\n    # 3. Match '?' left with specific right\n    for i in range(26):\n        while left_boots[26] and right_boots[i]:\n            pairs.append((left_boots[26].pop(), right_boots[i].pop()))\n\n    # 4. Match '?' left with '?' right\n    while left_boots[26] and right_boots[26]:\n        pairs.append((left_boots[26].pop(), right_boots[26].pop()))\n\n    sys.stdout.write(str(len(pairs)) + '\\n')\n    for l_idx, r_idx in pairs:\n        sys.stdout.write(f\"{l_idx} {r_idx}\\n\")\n\nif __name__ == '__main__':\n    solve()"}
{"task_id": "E2H_CF822C", "completion": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    min_cost = float('inf')\n    \n    # max_coord = 2 * 10**5\n    # The maximum possible r is 2 * 10^5.\n    # The maximum possible l is 2 * 10^5.\n    # The maximum possible duration is 2 * 10^5.\n    # The sum of durations is x, which can be up to 2 * 10^5.\n    # So, we need to store costs for durations up to x.\n    # The maximum coordinate for l and r is 2 * 10^5.\n    # We need to store minimum costs for a given duration ending at a specific day.\n    # Or minimum costs for a given duration starting at a specific day.\n\n    # Option 1: Iterate through all pairs (N^2) - too slow (2*10^5)^2 = 4*10^10\n    # Option 2: Sort and use a data structure.\n\n    # Let's group vouchers by their start day `l`.\n    # `vouchers_by_start[l]` will contain a list of (r, cost) for vouchers starting on day `l`.\n    vouchers_by_start = [[] for _ in range(2 * 10**5 + 2)]\n    for l, r, cost in vouchers:\n        vouchers_by_start[l].append((r, cost))\n\n    # `min_cost_for_duration_ending_on_day[duration][day]`\n    # This would be too large.\n    # Instead, let's keep track of `min_cost_for_duration[duration]`\n    # and update it as we sweep through days.\n\n    # `min_cost_for_len[duration]` stores the minimum cost of a single voucher\n    # with that `duration` seen so far.\n    # Initialize with infinity.\n    min_cost_for_len = [float('inf')] * (x + 1)\n\n    # `events` list to store (day, type, voucher_index)\n    # type 0: start of voucher\n    # type 1: end of voucher\n    events = []\n    for i, (l, r, cost) in enumerate(vouchers):\n        events.append((l, 0, i)) # Start event\n        events.append((r, 1, i)) # End event (processed after all starts on the same day)\n\n    # Sort events primarily by day, then by type (start before end)\n    events.sort()\n\n    # The max possible day is 2 * 10^5.\n    # We need to store min_cost_for_duration for vouchers ending on a specific day.\n    # `min_cost_ending_on_day[day]` will store a dictionary or list of (duration, cost)\n    # This is also too complex.\n\n    # Let's iterate through all possible split points.\n    # We need to find two vouchers (l1, r1, c1) and (l2, r2, c2) such that:\n    # 1. r1 < l2 OR r2 < l1 (disjoint)\n    # 2. (r1 - l1 + 1) + (r2 - l2 + 1) == x\n    # 3. c1 + c2 is minimized.\n\n    # One approach: Iterate through all vouchers (l1, r1, c1).\n    # For each voucher, calculate its duration d1 = r1 - l1 + 1.\n    # We need a second voucher with duration d2 = x - d1.\n    # The second voucher must satisfy r1 < l2 OR r2 < l1.\n\n    # If r1 < l2:\n    # We need to find a voucher (l2, r2, c2) such that l2 > r1 and r2 - l2 + 1 = x - d1.\n    # To do this efficiently, we can precompute, for each day `s` and duration `d`,\n    # the minimum cost of a voucher that starts on or after `s` and has duration `d`.\n    # This is still too complex.\n\n    # Let's try iterating through the vouchers sorted by `l`.\n    # We can maintain a data structure that stores minimum costs for available durations.\n\n    # `min_cost_for_duration_ending_before_day[duration]`\n    # This array will store the minimum cost of a voucher with `duration`\n    # that has ended *before* the current `l` we are considering.\n    # The index `d` stores the minimum cost for a voucher of length `d`.\n    min_cost_for_duration_ending_before_day = [float('inf')] * (x + 1)\n\n    # We can iterate through days from 1 to 2*10^5.\n    # For each day `d`:\n    # 1. Update `min_cost_for_duration_ending_before_day` with vouchers that end on `d-1`.\n    # 2. Consider vouchers that start on `d`. For each such voucher `v_curr = (l_curr, r_curr, cost_curr)`:\n    #    a. Calculate its duration `d_curr = r_curr - l_curr + 1`.\n    #    b. If `d_curr < x`:\n    #       i. The required duration for the second voucher is `d_req = x - d_curr`.\n    #       ii. If `min_cost_for_duration_ending_before_day[d_req]` is not infinity,\n    #           we can form a pair: `cost_curr + min_cost_for_duration_ending_before_day[d_req]`.\n    #           Update `min_cost`.\n    # This covers the `r_prev < l_curr` condition.\n\n    # To handle `r_curr < l_prev` efficiently, we can do another pass or\n    # consider all vouchers in one pass.\n\n    # Let's process vouchers sorted by their start day `l`.\n    # `vouchers_by_l[l]` stores list of (r, cost) for vouchers starting on day `l`.\n    # `vouchers_by_r[r]` stores list of (l, cost) for vouchers ending on day `r`.\n\n    max_coord = 2 * 10**5 + 1\n    vouchers_by_l = [[] for _ in range(max_coord + 1)]\n    vouchers_by_r = [[] for _ in range(max_coord + 1)]\n\n    for l, r, cost in vouchers:\n        vouchers_by_l[l].append((r, cost))\n        vouchers_by_r[r].append((l, cost))\n\n    current_min_cost_for_duration = [float('inf')] * (x + 1) # min cost for a voucher of specific duration ending *before or on* current day\n\n    ans = float('inf')\n\n    # Iterate through days from 1 to max_coord\n    for day in range(1, max_coord + 1):\n        # Phase 1: Update `current_min_cost_for_duration` with vouchers ending on `day - 1`.\n        # These vouchers are now \"available\" to be paired with vouchers starting on `day` or later.\n        if day > 1:\n            for l_prev, cost_prev in vouchers_by_r[day - 1]:\n                duration_prev = (day - 1) - l_prev + 1\n                if duration_prev <= x:\n                    current_min_cost_for_duration[duration_prev] = min(\n                        current_min_cost_for_duration[duration_prev], cost_prev\n                    )\n\n        # Phase 2: Consider vouchers starting on `day`.\n        for r_curr, cost_curr in vouchers_by_l[day]:\n            duration_curr = r_curr - day + 1\n            if duration_curr < x: # If duration_curr == x, then d_req = 0, which is not possible for a voucher.\n                required_duration = x - duration_curr\n                if required_duration > 0 and required_duration <= x:\n                    if current_min_cost_for_duration[required_duration] != float('inf'):\n                        ans = min(ans, cost_curr + current_min_cost_for_duration[required_duration])\n\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nsolve()"}
{"task_id": "E2H_CF1846E2", "completion": "import math\n\ndef solve():\n    n = int(input())\n\n    if n <= 6:\n        print(\"NO\")\n        return\n\n    # Case 1: Snowflake with 2 levels (root + k children)\n    # Total vertices = 1 (root) + k (children) = k + 1\n    # n = k + 1 => k = n - 1\n    # Since k > 1, n - 1 > 1 => n > 2.\n    # This is a valid snowflake if n > 2.\n    # However, the problem statement says \"This step should be done at least once.\"\n    # which implies there's at least one layer of \"grandchildren\".\n    # So, the smallest snowflake has 3 levels.\n    # 1 (root) + k (children) + k*k (grandchildren) = 1 + k + k^2\n    # So, we are looking for solutions where n = 1 + k + k^2 + ... + k^(d-1)\n    # for some d >= 3 (number of levels) and k > 1.\n\n    # Check for d = 3 (3 levels: root, k children, k*k grandchildren)\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # Using quadratic formula: k = (-1 + sqrt(1 - 4*(1 - n))) / 2\n    # k = (-1 + sqrt(1 - 4 + 4n)) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    # For k to be an integer > 1:\n    # 1. 4n - 3 must be a perfect square.\n    # 2. sqrt(4n - 3) must be odd (so -1 + sqrt is even).\n    # 3. (-1 + sqrt(4n - 3)) / 2 must be > 1.\n    \n    # Check if 4n - 3 is a perfect square\n    discriminant = 4 * n - 3\n    if discriminant >= 0:\n        sqrt_discriminant = int(math.isqrt(discriminant))\n        if sqrt_discriminant * sqrt_discriminant == discriminant:\n            # Check if sqrt_discriminant is odd\n            if sqrt_discriminant % 2 == 1:\n                k_candidate = (-1 + sqrt_discriminant) // 2\n                if k_candidate > 1:\n                    print(\"YES\")\n                    return\n\n    # Check for d >= 4\n    # n = 1 + k + k^2 + ... + k^(d-1)\n    # This is a geometric series sum: n = (k^d - 1) / (k - 1)\n    # We need to find if there exists k > 1 and d >= 4 such that this holds.\n    # For a fixed d, we need to find an integer k > 1.\n    # k^d - 1 = n * (k - 1)\n    # k^d - n*k + n - 1 = 0\n\n    # The maximum possible d for n = 10^18:\n    # For k=2, n = 2^d - 1. 2^d approx 10^18 => d approx log2(10^18) = 18 * log2(10) approx 18 * 3.32 approx 59.79. So d <= 60.\n    # For larger k, d will be smaller.\n    # For k=3, 3^d approx 10^18 => d approx 18 * log3(10) approx 18 * 2.09 approx 37.7.\n    # For k=10^3, d approx 6.\n    # For k=10^6, d approx 3. (already handled by quadratic)\n    # So d ranges from 4 to about 60.\n\n    # Iterate through possible values of d\n    for d in range(4, 61):\n        # We need to find k such that k^d - 1 = n * (k - 1)\n        # We can use binary search for k.\n        # Lower bound for k is 2.\n        # Upper bound for k: k^(d-1) < n => k < n^(1/(d-1)).\n        # A slightly tighter upper bound: (k^d - 1)/(k-1) = k^(d-1) + k^(d-2) + ... + 1 approx k^(d-1).\n        # So k^(d-1) < n.\n        # k < n^(1/(d-1)).\n        \n        low = 2\n        # Calculate high more carefully to avoid overflow for n^(1/(d-1))\n        # high = int(n**(1/(d-1))) + 2  # Add a small buffer\n        # A safer upper bound for k: if k^d > n, then it's too large.\n        # For d=4, k^3 < n => k < n^(1/3). Max k is around 10^6.\n        # For d=60, k < n^(1/59). Max k is around 2.\n        \n        # Upper bound for k: k^d - 1 = n(k-1). If k-1 is small, k^d approx n(k-1).\n        # k^(d-1) approx n. So k approx n^(1/(d-1)).\n        # Since k > 1, k^d > n.\n        # max_k_val = int(math.pow(n, 1.0 / (d - 1))) + 2\n        # A simple upper bound is 2 * 10^9 because (2*10^9)^2 > 10^18.\n        # For d=4, k^3 < n, so k < n^(1/3). n^(1/3) for 10^18 is 10^6.\n        # A safe upper bound for k is 10^6 + 7.\n        # For larger d, k will be smaller.\n        # So 10^6 + 7 is a good upper bound for all d >= 4.\n        high = 10**6 + 7 \n\n        # Binary search for k\n        while low <= high:\n            mid = (low + high) // 2\n            if mid == 1: # k must be > 1\n                low = 2\n                continue\n\n            # Calculate sum = 1 + mid + mid^2 + ... + mid^(d-1)\n            # This can overflow if mid is large and d is large.\n            # Instead, check mid^d - 1 == n * (mid - 1)\n            # Or, more robustly, check (mid^d - 1) / (mid - 1) == n\n            \n            # Use a helper function for power to check for overflow\n            current_term = 1\n            current_sum = 1\n            overflow = False\n            for _ in range(1, d):\n                if n // mid < current_term: # current_term * mid would exceed n, so current_sum will exceed n\n                    overflow = True\n                    break\n                current_term *= mid\n                if n - current_term < current_sum: # current_sum + current_term would exceed n\n                    overflow = True\n                    break\n                current_sum += current_term\n            \n            if overflow:\n                high = mid - 1\n            elif current_sum == n:\n                print(\"YES\")\n                return\n            elif current_sum < n:\n                low = mid + 1\n            else: # current_sum > n\n                high = mid - 1\n\n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()"}
{"task_id": "E2H_CF270E", "completion": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_input = []\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_input.append((u, v, c))\n\n    ans = [-1] * m\n    visited_edges = [False] * m\n    balance = [0] * (n + 1)\n    \n    # DFS to determine flow directions\n    # The key idea is that for any vertex v (1 < v < n), its net flow must be 0.\n    # We can perform a DFS starting from node 1 (source).\n    # When we traverse an edge (u, v) with flow c, we can tentatively assume flow from u to v.\n    # This adds c to balance[v] and subtracts c from balance[u].\n    # When we return from a DFS call for a node v, if balance[v] is not 0,\n    # it means there's a net flow that needs to be \"sent back\" to its parent in the DFS tree.\n    # This is done by reversing the direction of the edge to the parent.\n\n    # This approach is suitable for a tree structure.\n    # For a general graph, we can use a similar idea.\n    # The problem statement guarantees a solution exists and the resulting graph\n    # does not have cycles. This implies that the flow can be represented as a DAG.\n    # The \"no incoming edges for vertex 1\" condition is important.\n\n    # Let's try a different approach based on the \"no cycles\" condition.\n    # A DAG can be topologically sorted.\n    # If we consider the residual graph, a max flow implies that there's no augmenting path from s to t.\n    # The problem statement implies that we can use the given flow values directly to form a DAG.\n\n    # The condition \"vertex with number 1 has no incoming edges\" and \"no cycles\"\n    # suggests that node 1 must be a source in the directed graph.\n    # The condition \"for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges\"\n    # means that these are conservation nodes.\n    # Node n is the sink.\n\n    # Let's use a DFS-based approach where we maintain the \"balance\" of flow for each node.\n    # For nodes 1 and n, the balance condition doesn't apply directly.\n    # Node 1 is a pure source, node n is a pure sink.\n    # For 1 < v < n, sum(in) = sum(out).\n    # This means for these nodes, balance[v] should eventually be 0.\n\n    # We can do a DFS from node 1.\n    # When we traverse an edge (u, v) with flow c for the first time,\n    # we can tentatively direct it u -> v.\n    # This adds c to balance[v] and subtracts c from balance[u].\n    # After visiting all children of u and returning, if balance[u] is not 0,\n    # it means u has a net outgoing flow. This flow must be directed to its parent in the DFS tree.\n    # This is the standard approach for finding Eulerian paths or similar problems on trees.\n\n    # Let's refine the DFS approach:\n    # We need to ensure balance[v] = 0 for 1 < v < n.\n    # We can use a DFS traversal. When we traverse an edge (u, v) for the first time,\n    # we mark it as visited and tentatively assign direction u -> v.\n    # We add c to balance[v] and subtract c from balance[u].\n    # When the DFS returns from v to u, if balance[v] is negative, it means v has\n    # a net outgoing flow that needs to be satisfied. This flow must have come from u.\n    # This implies that the edge (u, v) should actually be v -> u.\n    # This is a bit tricky because balance[v] could be positive if it received more flow than it sent out.\n\n    # Let's use the given property: \"vertex with number 1 has no incoming edges\".\n    # This means all edges connected to 1 must be directed 1 -> v.\n    # We can start by processing edges connected to 1.\n    # This sets initial balance values.\n    # Then we can use a queue-based approach (like Kahn's algorithm for topological sort)\n    # or another DFS.\n\n    # A more robust DFS approach for flow direction:\n    # We want to make sure that for each node v (1 < v < n), its net flow is 0.\n    # We can do a DFS starting from node 1.\n    # For each edge (u, v) with flow c:\n    #   If it's the first time we visit v from u:\n    #     Recursively call DFS(v, u).\n    #     After the recursive call returns, check the balance of v.\n    #     If balance[v] is negative, it means v has a deficit.\n    #     This deficit must be satisfied by flow from u to v. So, direct u -> v.\n    #     Update balance[u] -= c, balance[v] += c.\n    #     If balance[v] is positive, it means v has a surplus.\n    #     This surplus must be sent to u. So, direct v -> u.\n    #     Update balance[u] += c, balance[v] -= c.\n    #     If balance[v] is zero, we can choose arbitrarily, say u -> v.\n    #     Update balance[u] -= c, balance[v] += c.\n\n    # This approach is usually used for finding Eulerian paths/circuits where edge directions are determined to satisfy degree constraints.\n    # The crucial part is that the balance for any node (except 1 and n) must be 0.\n\n    # Let's use a standard DFS with a twist:\n    # We will compute the total flow that *must* leave a subtree rooted at `u` (excluding flow to its parent).\n    # This is often called \"demand\" or \"supply\".\n\n    # Let's maintain `current_flow_out[v]` for each node `v`. This represents the net flow that has been directed *out* of `v`\n    # through edges processed so far within the DFS subtree.\n    # When DFS visits `u` from `parent`:\n    #   For each neighbor `v` of `u` (excluding `parent`):\n    #     If edge (u, v) is not visited:\n    #       Mark edge (u, v) as visited.\n    #       Call DFS(v, u).\n    #       After DFS(v, u) returns, `current_flow_out[v]` holds the net flow that `v` has sent out\n    #       to its children in the DFS tree, minus what it received from them.\n    #       The remaining flow `c_uv - current_flow_out[v]` (if `current_flow_out[v]` is the *flow that has already left v towards children*)\n    #       or `current_flow_out[v]` (if it's the *net flow to be satisfied from u*) needs to be handled by edge (u,v).\n\n    # The problem is simpler: for each node v (1 < v < n), sum(in) = sum(out).\n    # This means the net flow for these nodes must be zero.\n    # For node 1, all edges must be outgoing.\n    # For node n, all edges can be incoming, or outgoing (if it's a source for some path to another sink, but problem says n is the sink).\n\n    # The \"no cycles\" condition is key. This implies that if we build a graph with edges directed\n    # according to our solution, it must be a DAG.\n    # And \"vertex 1 has no incoming edges\".\n\n    # Consider a DFS traversal starting from node 1.\n    # `dfs_parent[v]` stores the parent of `v` in the DFS tree.\n    # `dfs_edge_idx[v]` stores the index of the edge connecting `v` to `dfs_parent[v]`.\n    # `visited[v]` marks if `v` has been visited.\n    # `flow_balance[v]` will store the net flow into `v` from its children in the DFS tree.\n    # This balance needs to be zero for `1 < v < n`.\n\n    visited = [False] * (n + 1)\n    flow_balance = [0] * (n + 1) # net flow into this node from its children in DFS tree\n\n    def dfs(u, p_edge_idx):\n        visited[u] = True\n\n        for v, c, edge_idx in adj[u]:\n            if edge_idx == p_edge_idx: # Skip the edge to parent\n                continue\n\n            if not visited_edges[edge_idx]:\n                visited_edges[edge_idx] = True\n\n                if not visited[v]:\n                    # This is a tree edge (u, v)\n                    dfs(v, edge_idx)\n                    \n                    # After returning from DFS(v), flow_balance[v] holds the net flow\n                    # that v needs to send *up* to u (if positive) or receive *from* u (if negative)\n                    # to satisfy its internal balance.\n                    \n                    # If flow_balance[v] > 0, v has a surplus that needs to go to u. So v -> u.\n                    # If flow_balance[v] < 0, v has a deficit that needs to come from u. So u -> v.\n                    # If flow_balance[v] == 0, we can direct u -> v (arbitrary choice for tree edges, or consider it as a \"forward\" edge)\n\n                    # For the purpose of determining direction, we need to decide if flow c goes u->v or v->u.\n                    # If the edge is (u,v) with original nodes (a_i, b_i),\n                    # ans[edge_idx] = 0 means a_i -> b_i\n                    # ans[edge_idx] = 1 means b_i -> a_i\n\n                    # Let's say we assume flow goes u -> v for tree edges initially.\n                    # Then flow_balance[v] accumulates flow from its children.\n                    # If flow_balance[v] becomes positive, it means v has received more flow from its children\n                    # than it has sent out. This surplus must be sent to its parent `u`.\n                    # So, the edge direction must be v -> u.\n                    # If flow_balance[v] becomes negative, it means v has sent out more flow to its children\n                    # than it received. This deficit must be received from its parent `u`.\n                    # So, the edge direction must be u -> v.\n\n                    # Let's keep `flow_balance[v]` as the sum of flows that `v` needs to send *up* to its parent.\n                    # Initially, when we enter DFS(v), flow_balance[v] is 0.\n                    # When we process a child `w` of `v`, and `dfs(w)` returns:\n                    #   If `flow_balance[w]` is positive, `w` sends `flow_balance[w]` to `v`. So `w -> v`.\n                    #     `flow_balance[v] += flow_balance[w]`.\n                    #   If `flow_balance[w]` is negative, `w` receives `|flow_balance[w]|` from `v`. So `v -> w`.\n                    #     `flow_balance[v] += flow_balance[w]`.\n                    # This way, `flow_balance[v]` will accumulate the net flow `v` needs to send to its parent `u`.\n\n                    # This is the correct logic for flow conservation:\n                    # After DFS(v) returns, `flow_balance[v]` contains the net flow that `v` has received\n                    # from its children (positive if received more, negative if sent more).\n                    # This net flow must be resolved by the edge (u, v).\n\n                    # If `v` is the sink `n`, it can have any net flow. We don't need to balance it.\n                    # If `v` is a conservation node (`1 < v < n`), its net flow must be zero.\n                    # The flow `c` on edge (u, v) is available.\n                    # If `flow_balance[v]` (net flow from children to `v`) is 0, we can choose direction.\n                    # Let's always try to direct towards `v` (u -> v) for consistency, unless forced otherwise.\n\n                    # The actual flow that `v` must \"send up\" to `u` to balance its subtree is `flow_balance[v]`.\n                    # If `u` is `1`, it cannot receive flow. So if `flow_balance[u]` is non-zero, it's an error in logic.\n                    # If `v` is `n`, it can receive flow.\n\n                    # For a node `v` (1 < v < n), its net flow must be 0.\n                    # `flow_balance[v]` after DFS(v) returns represents the net flow from the subtree rooted at `v`\n                    # that must pass through the edge (parent[v], v).\n                    # If `flow_balance[v]` is positive, `v` must send `flow_balance[v]` units to `parent[v]`.\n                    # If `flow_balance[v]` is negative, `v` must receive `|flow_balance[v]|` units from `parent[v]`.\n\n                    # If `v == n`, we don't care about its balance, it's the sink.\n                    # We can direct the edge (u, n) as u -> n.\n                    # The total flow to n will be sum of all c_i for edges directed into n.\n                    # This is a bit problematic because we need to determine direction for all edges.\n\n                    # Let's re-think the balance: `flow_balance[v]` is the net flow that `v` has *received* from its children.\n                    # When DFS(v) returns to u:\n                    #   `flow_balance[v]` is the sum of `c` for edges `w->v` minus sum of `c` for edges `v->w`\n                    #   where `w` are children of `v` in the DFS tree.\n                    #   This `flow_balance[v]` needs to be balanced by the edge (u, v).\n                    #   If `flow_balance[v]` is positive, `v` has a surplus. It must send `flow_balance[v]` to `u`.\n                    #     So, direct `v -> u`.\n                    #     Update `flow_balance[u] += flow_balance[v]`.\n                    #   If `flow_balance[v]` is negative, `v` has a deficit. It must receive `|flow_balance[v]|` from `u`.\n                    #     So, direct `u -> v`.\n                    #     Update `flow_balance[u] += flow_balance[v]`.\n                    #   The flow `c` on edge (u, v) is also part of this.\n                    #   This means `flow_balance[v]` should be `flow_balance[v] + c` if `u -> v` or `flow_balance[v] - c` if `v -> u`.\n\n                    # Corrected DFS logic for flow conservation (for nodes 1 < v < n):\n                    # `flow_balance[v]` stores the net flow that *must* leave `v` and go towards its parent `u`\n                    # to balance the flows within the subtree rooted at `v`.\n                    # A positive `flow_balance[v]` means `v` needs to send `flow_balance[v]` units to `u`.\n                    # A negative `flow_balance[v]` means `v` needs to receive `|flow_balance[v]|` units from `u`.\n\n                    # After `dfs(v, edge_idx)` returns, `flow_balance[v]` contains the net flow that `v` needs to send to its parent `u`.\n                    # This flow must be exactly `c` (the capacity of edge (u,v)) or `-c`.\n                    # If `flow_balance[v]` is 0 (and `v != n`), it means `v` and its subtree are perfectly balanced,\n                    # and no flow needs to pass through (u,v) to satisfy `v`'s internal balance.\n                    # This implies that `flow_balance[v]` should be `0` for `1 < v < n`.\n                    # If `v == n`, `flow_balance[n]` can be anything.\n\n                    # Let's consider the total incoming flow to `v` from its children in the DFS tree.\n                    # `flow_balance[v]` = sum of `c_wv` for `w` child of `v` where `w -> v`\n                    #                   - sum of `c_vw` for `w` child of `v` where `v -> w`.\n                    # We want `flow_balance[v]` to be 0 for `1 < v < n`.\n                    # And `flow_balance[1]` should be the total flow from source to sink.\n\n                    # Initialize `flow_balance` to 0.\n                    # When we traverse `u -> v` (edge `(u, v, c, edge_idx)`):\n                    #   `flow_balance[u] -= c`\n                    #   `flow_balance[v] += c`\n                    # When `dfs(v)` returns to `u`:\n                    #   If `v == n`:\n                    #     We must direct `u -> n`. `ans[edge_idx]` depends on `edges_input[edge_idx]`.\n                    #     If `edges_input[edge_idx]` is `(u, n, c)`, then `ans[edge_idx] = 0`.\n                    #     If `edges_input[edge_idx]` is `(n, u, c)`, then `ans[edge_idx] = 1`.\n                    #     This adds `c` to `flow_balance[n]` and subtracts `c` from `flow_balance[u]`.\n                    #     (This is not quite right, `flow_balance[u]` should represent the total flow `u` sends out).\n\n                    # Let's use `current_excess[v]` to track the sum of `c` values of edges\n                    # directed *into* `v` minus sum of `c` values of edges directed *out of* `v`\n                    # for edges within `v`'s subtree (excluding the edge to parent).\n                    # When `dfs(u, parent_edge_idx)` is called:\n                    #   `current_excess[u]` is initialized to 0.\n                    #   For each neighbor `v` of `u` (not parent, not visited):\n                    #     `dfs(v, edge_idx)`\n                    #     After `dfs(v)` returns, `current_excess[v]` contains the net flow that `v` has\n                    #     received from its subtree.\n                    #     If `current_excess[v]` is positive, `v` has a surplus. It needs to send `current_excess[v]`\n                    #     units to `u`. So, direct `v -> u`.\n                    #       `current_excess[u] += current_excess[v]`.\n                    #       If `edges_input[edge_idx]` is `(u, v, c)`, then `ans[edge_idx] = 1`.\n                    #       If `edges_input[edge_idx]` is `(v, u, c)`, then `ans[edge_idx] = 0`.\n                    #     If `current_excess[v]` is negative, `v` has a deficit. It needs to receive `|current_excess[v]|`\n                    #     units from `u`. So, direct `u -> v`.\n                    #       `current_excess[u] += current_excess[v]`.\n                    #       If `edges_input[edge_idx]` is `(u, v, c)`, then `ans[edge_idx] = 0`.\n                    #       If `edges_input[edge_idx]` is `(v, u, c)`, then `ans[edge_idx] = 1`.\n                    #     If `current_excess[v]` is 0, we can choose arbitrarily, say `u -> v`.\n                    #       `current_excess[u] -= c`.\n                    #       If `edges_input[edge_idx]` is `(u, v, c)`, then `ans[edge_idx] = 0`.\n                    #       If `edges_input[edge_idx]` is `(v, u, c)`, then `ans[edge_idx] = 1`.\n                    #       (This arbitrary choice is problematic. The balance must be 0 for internal nodes.)\n\n                    # The crucial observation for this problem is that if we consider the graph as a tree\n                    # (by ignoring back-edges for now), we can propagate flow up the tree.\n                    # For any node `v` (1 < v < n), its total incoming flow must equal its total outgoing flow.\n                    # Let `S_v` be the sum of flow values of edges within the subtree rooted at `v` that are directed\n                    # towards `v`, minus the sum of flow values of edges within the subtree rooted at `v` that are directed\n                    # away from `v`.\n                    # When DFS returns from `v` to `u`:\n                    #   If `v = n`: The sink node can accumulate flow. We direct `u -> n`.\n                    #     `ans[edge_idx]` is set accordingly. `flow_balance[u] -= c`.\n                    #   If `v != n`: `S_v` must be zero for `v` to be balanced.\n                    #     The flow `c` on edge (u, v) must be used to make `S_v` zero.\n                    #     If `flow_balance[v]` (the sum of flows from children of `v` directed towards `v` minus flow from `v` to children)\n                    #     is positive, it means `v` has a surplus. It must send `flow_balance[v]` to `u`. So `v -> u`.\n                    #       `flow_balance[u] += flow_balance[v]`.\n                    #       Set `ans[edge_idx]` for `v -> u`.\n                    #     If `flow_balance[v]` is negative, it means `v` has a deficit. It must receive `|flow_balance[v]|` from `u`. So `u -> v`.\n                    #       `flow_balance[u] += flow_balance[v]`.\n                    #       Set `ans[edge_idx]` for `u -> v`.\n\n                    # This is the standard \"Eulerian path\" trick:\n                    # `flow_balance[u]` accumulates the net flow that needs to be sent *out* of `u`\n                    # to balance its subtree, including the flow through the edge to its parent.\n                    # Initial call: `dfs(1, -1)`\n                    # `flow_balance[1]` will represent the total flow from source to sink.\n\n                    # Let `flow_balance[v]` be the net flow *out* of `v` from its children's subtrees.\n                    # So, if `w` is a child of `v`:\n                    #   If `flow_balance[w] > 0`, `w` sends `flow_balance[w]` to `v`. (So `w -> v`). This reduces `flow_balance[v]`.\n                    #   If `flow_balance[w] < 0`, `w` receives `|flow_balance[w]|` from `v`. (So `v -> w`). This increases `flow_balance[v]`.\n                    # This is confusing. Let's use `net_flow_from_subtree[v]`.\n                    # `net_flow_from_subtree[v]` = sum of flows from children of `v` that are directed *into* `v`\n                    #                             - sum of flows from `v` to its children.\n                    # We want `net_flow_from_subtree[v]` to be 0 for `1 < v < n`.\n\n                    # Let's define `net_flow_out_of_subtree[v]` as the total flow that leaves the subtree rooted at `v`\n                    # through the edge connecting `v` to its parent `u`.\n                    # When `dfs(v, edge_idx)` returns:\n                    #   `net_flow_out_of_subtree[v]` is the sum of flows that `v` sent to its children\n                    #   minus the sum of flows that `v` received from its children.\n                    #   Plus, if `v == n`, it can receive flow.\n                    #   If `v == n`, we direct `u -> n`. `net_flow_out_of_subtree[v] += c`.\n                    #   If `v != n` (and `v != 1`), `net_flow_out_of_subtree[v]` must be 0.\n                    #   So, the flow `c` on edge (u, v) must be directed to make `net_flow_out_of_subtree[v]` zero.\n                    #   If `net_flow_out_of_subtree[v]` (after considering children) is positive,\n                    #   it means `v` has sent out more flow than it received from its children.\n                    #   It needs to receive `net_flow_out_of_subtree[v]` from `u`. So, `u -> v`.\n                    #     `net_flow_out_of_subtree[u] += net_flow_out_of_subtree[v]`.\n                    #   If `net_flow_out_of_subtree[v]` is negative,\n                    #   it means `v` has received more flow than it sent out to its children.\n                    #   It needs to send `|net_flow_out_of_subtree[v]|` to `u`. So, `v -> u`.\n                    #     `net_flow_out_of_subtree[u] += net_flow_out_of_subtree[v]`.\n                    #   The flow `c` itself also contributes to `net_flow_out_of_subtree[u]`.\n                    #   So, `net_flow_out_of_subtree[u]` is the flow `u` sends to `v` (if `u->v`) or receives from `v` (if `v->u`).\n\n                    # This logic is for `flow_balance[v]` representing the total flow that `v` needs to send *up* to its parent.\n                    # If `flow_balance[v] > 0`: `v` has a surplus from its subtree, sends `flow_balance[v]` to `u`. `v -> u`.\n                    #   `flow_balance[u] += flow_balance[v]`.\n                    #   Set `ans[edge_idx]` to `v -> u`.\n                    # If `flow_balance[v] < 0`: `v` has a deficit in its subtree, needs `|flow_balance[v]|` from `u`. `u -> v`.\n                    #   `flow_balance[u] += flow_balance[v]`.\n                    #   Set `ans[edge_idx]` to `u -> v`.\n                    # If `flow_balance[v] == 0`: `v` is perfectly balanced.\n                    #   If `v == n`, we can direct `u -> n`. `flow_balance[u] -= c`.\n                    #   If `v != n`, this means the total flow from children of `v` to `v` equals total flow from `v` to children.\n                    #   But `v` itself needs to be balanced. This means the edge `(u,v)` must carry `0` flow, which is not possible.\n                    #   So `flow_balance[v]` should not be 0 for `v != n`.\n\n                    # Let's use `current_flow_out[v]` to be the net flow that `v` has sent out to its children.\n                    # `current_flow_out[v] = sum(c_vw for v->w) - sum(c_wv for w->v)`.\n                    # We want `current_flow_out[v]` to be 0 for `1 < v < n`.\n                    # For `v=n`, `current_flow_out[n]` can be anything (total flow leaving `n` through its children).\n                    #\n                    # `dfs(u, p_edge_idx)`:\n                    #   `visited[u] = True`\n                    #   For each `(v, c, edge_idx)` adjacent to `u`:\n                    #     If `edge_idx == p_edge_idx`: continue\n                    #     If `not visited_edges[edge_idx]`:\n                    #       `visited_edges[edge_idx] = True`\n                    #       If `not visited[v]`: (Tree edge)\n                    #         `dfs(v, edge_idx)`\n                    #         # After returning from DFS(v), `current_flow_out[v]` is the net flow `v` sent to its children.\n                    #         # For `1 < v < n`, `v` must have net flow 0.\n                    #         # The flow `c` on edge (u, v) must balance `current_flow_out[v]`.\n                    #         # If `v == n`:\n                    #         #   We must direct `u -> n`. This is the only way to get flow to the sink.\n                    #         #   `current_flow_out[u] += c`.\n                    #         #   Set `ans[edge_idx]` to `u -> n`.\n                    #         # Else (`1 < v < n`):\n                    #         #   If `current_flow_out[v]` is positive, `v` sent out too much. It needs `current_flow_out[v]` from `u`. So `u -> v`.\n                    #         #     `current_flow_out[u] += c`.\n                    #         #     Set `ans[edge_idx]` to `u -> v`.\n                    #         #   If `current_flow_out[v]` is negative, `v` received too much. It needs to send `|current_flow_out[v]|` to `u`. So `v -> u`.\n                    #         #     `current_flow_out[u] -= c`.\n                    #         #     Set `ans[edge_idx]` to `v -> u`.\n                    #         #   If `current_flow_out[v]` is 0, this means `v` is perfectly balanced by its children.\n                    #         #   This means edge (u,v) should not carry any flow, which is wrong.\n                    #         #   The problem is that `current_flow_out[v]` should be `0` only after considering the edge `(u,v)`.\n\n                    # This means the `flow_balance` variable should represent the sum of flows that *entered* `v`\n                    # from its children's subtrees, minus flows that *left* `v` to its children's subtrees.\n                    # This is `incoming - outgoing` from children.\n                    # We want this to be 0 for `1 < v < n` after considering the parent edge.\n\n                    # Let `flow_deficit[v]` be the amount of flow `v` needs to receive from its parent `u`\n                    # to balance its subtree. A positive `flow_deficit[v]` means `v` needs to receive flow from `u`.\n                    # A negative `flow_deficit[v]` means `v` has a surplus and needs to send flow to `u`.\n                    # When `dfs(v, edge_idx)` returns:\n                    #   `flow_deficit[v]` contains the net flow `v` needs to receive from `u`.\n                    #   If `v == n`:\n                    #     `flow_deficit[n]` can be anything. We direct `u -> n`.\n                    #     `flow_deficit[u] += c`. (u sends c to n)\n                    #     Set `ans[edge_idx]` for `u -> n`.\n                    #   Else (`1 < v < n`):\n                    #     If `flow_deficit[v] == 0`:\n                    #       This is the base case. The subtree of `v` is balanced.\n                    #       We can direct `u -> v`.\n                    #       `flow_deficit[u] += c`. (u sends c to v)\n                    #       Set `ans[edge_idx]` for `u -> v`.\n                    #     If `flow_deficit[v] > 0`: (`v` needs flow from `u`)\n                    #       Direct `u -> v`.\n                    #       `flow_deficit[u] += c`. (u sends c to v)\n                    #       Set `ans[edge_idx]` for `u -> v`.\n                    #     If `flow_deficit[v] < 0`: (`v` has surplus, needs to send to `u`)\n                    #       Direct `v -> u`.\n                    #       `flow_deficit[u] -= c`. (u receives c from v)\n                    #       Set `ans[edge_idx]` for `v -> u`.\n                    # This seems more consistent. `flow_deficit[u]` will represent the total flow `u` needs to receive from its parent.\n\n                    # Let's use `flow_balance[v]` to store the net flow that `v` has received from its children.\n                    # `flow_balance[v] = sum(c_wv for w->v) - sum(c_vw for v->w)` for children `w`.\n                    # When `dfs(v, edge_idx)` returns to `u`:\n                    #   If `v == n`:\n                    #     We must direct `u -> n`.\n                    #     `flow_balance[u] += c`. (u sends c to n, so u's balance decreases, but we want balance of what u received from children).\n                    #     This is `flow_balance[u] -= c`.\n                    #     Let `edges_input[edge_idx]` be `(orig_u, orig_v, c)`.\n                    #     If `orig_u == u` and `orig_v == n`: `ans[edge_idx] = 0`.\n                    #     If `orig_u == n` and `orig_v == u`: `ans[edge_idx] = 1`.\n                    #   Else (`1 < v < n`):\n                    #     We need to make `flow_balance[v]` zero after considering edge `(u, v)`.\n                    #     If `flow_balance[v] > 0`: `v` has a surplus. It must send `flow_balance[v]` to `u`. So `v -> u`.\n                    #       `flow_balance[u] -= c`. (u receives c from v, so u's balance increases).\n                    #       Let `edges_input[edge_idx]` be `(orig_u, orig_v, c)`.\n                    #       If `orig_u == v` and `orig_v == u`: `ans[edge_idx] = 0`.\n                    #       If `orig_u == u` and `orig_v == v`: `ans[edge_idx] = 1`.\n                    #     If `flow_balance[v] < 0`: `v` has a deficit. It must receive `|flow_balance[v]|` from `u`. So `u -> v`.\n                    #       `flow_balance[u] += c`. (u sends c to v, so u's balance decreases).\n                    #       Let `edges_input[edge_idx]` be `(orig_u, orig_v, c)`.\n                    #       If `orig_u == u` and `orig_v == v`: `ans[edge_idx] = 0`.\n                    #       If `orig_u == v` and `orig_v == u`: `ans[edge_idx] = 1`.\n                    #     If `flow_balance[v] == 0`: This is tricky. We need to direct the edge.\n                    #       The problem states a solution always exists.\n                    #       Maybe `flow_balance[v]` will never be zero for `1 < v < n` before processing parent edge.\n                    #       If it is zero, we can just direct `u -> v`. `flow_balance[u] -= c`.\n                    #       If `edges_input[edge_idx]` is `(orig_u, orig_v, c)`.\n                    #       If `orig_u == u` and `orig_v == v`: `ans[edge_idx] = 0`.\n                    #       If `orig_u == v` and `orig_v == u`: `ans[edge_idx] = 1`.\n\n                    # Let's try to maintain `flow_balance[v]` as `total_flow_out - total_flow_in` for node `v`.\n                    # For `1 < v < n`, we want `flow_balance[v]` to be 0.\n                    # For `v = 1`, `flow_balance[1]` will be total max flow.\n                    # For `v = n`, `flow_balance[n]` will be `-total_max_flow`.\n\n                    # `dfs(u, p_edge_idx)`:\n                    #   `visited[u] = True`\n                    #   For each `(v, c, edge_idx)` adjacent to `u`:\n                    #     If `edge_idx == p_edge_idx`: continue\n                    #     If `not visited_edges[edge_idx]`:\n                    #       `visited_edges[edge_idx] = True`\n                    #       If `not visited[v]`: (Tree edge)\n                    #         `dfs(v, edge_idx)`\n                    #         # After `dfs(v)` returns, `flow_balance[v]` contains `total_flow_out - total_flow_in`\n                    #         # from `v`'s children's subtrees.\n                    #         # Now we need to decide direction for `(u, v, c)`.\n                    #         if u == 1: # Source node. All edges must be outgoing from 1.\n                    #             # This edge must be 1 -> v.\n                    #             # `flow_balance[1]` increases by `c`. `flow_balance[v]` decreases by `c`.\n                    #             flow_balance[1] += c\n                    #             flow_balance[v] -= c\n                    #             orig_u, orig_v, _ = edges_input[edge_idx]\n                    #             ans[edge_idx] = 0 if orig_u == u else 1\n                    #         elif v == n: # Sink node. All edges must be incoming to n.\n                    #             # This edge must be u -> n.\n                    #             # `flow_balance[u]` increases by `c`. `flow_balance[n]` decreases by `c`.\n                    #             flow_balance[u] += c\n                    #             flow_balance[n] -= c\n                    #             orig_u, orig_v, _ = edges_input[edge_idx]\n                    #             ans[edge_idx] = 0 if orig_u == u else 1\n                    #         else: # `1 < u, v < n`. Conservation nodes.\n                    #             # `flow_balance[v]` is currently `(out_from_children - in_from_children)`.\n                    #             # We need `flow_balance[v]` to be 0 after considering `(u,v)`.\n                    #             # If `flow_balance[v] > 0`: `v` has sent out too much. It needs `flow_balance[v]` from `u`. So `u -> v`.\n                    #             #   `flow_balance[u]` increases by `c`. `flow_balance[v]` decreases by `c`.\n                    #             if flow_balance[v] > 0:\n                    #                 flow_balance[u] += c\n                    #                 flow_balance[v] -= c\n                    #                 orig_u, orig_v, _ = edges_input[edge_idx]\n                    #                 ans[edge_idx] = 0 if orig_u == u else 1\n                    #             # If `flow_balance[v] < 0`: `v` has received too much. It needs to send `|flow_balance[v]|` to `u`. So `v -> u`.\n                    #             #   `flow_balance[u]` decreases by `c`. `flow_balance[v]` increases by `c`.\n                    #             elif flow_balance[v] < 0:\n                    #                 flow_balance[u] -= c\n                    #                 flow_balance[v] += c\n                    #                 orig_u, orig_v, _ = edges_input[edge_idx]\n                    #                 ans[edge_idx] = 0 if orig_u == v else 1\n                    #             # If `flow_balance[v] == 0`: `v` is balanced. We can choose `u -> v`.\n                    #             #   `flow_balance[u]` increases by `c`. `flow_balance[v]` decreases by `c`.\n                    #             else: # flow_balance[v] == 0\n                    #                 flow_balance[u] += c\n                    #                 flow_balance[v] -= c\n                    #                 orig_u, orig_v, _ = edges_input[edge_idx]\n                    #                 ans[edge_idx] = 0 if orig_u == u else 1\n                    #       else: # Back edge (u, v) where v is already visited.\n                    #         # This edge cannot be part of the DFS tree. It connects `u` to an ancestor `v`.\n                    #         # The problem states \"no cycles\". This means there are no back edges in the final directed graph.\n                    #         # This implies that all edges must be directed \"down\" the DFS tree, or \"up\" to satisfy balance.\n                    #         # But the condition \"no cycles\" applies to the final *directed* graph.\n                    #         # Our DFS tree is undirected. Back edges are possible.\n                    #         # If `v` is an ancestor of `u` (or visited earlier), we must direct `u -> v`.\n                    #         # This contributes to `flow_balance[u]` and `flow_balance[v]`.\n                    #         # This is the \"flow from source to sink\" path.\n                    #         # Direct `u -> v`.\n                    #         flow_balance[u] += c\n                    #         flow_balance[v] -= c\n                    #         orig_u, orig_v, _ = edges_input[edge_idx]\n                    #         ans[edge_idx] = 0 if orig_u == u else 1\n\n    # The problem constraints are crucial: \"vertex with number 1 has no incoming edges\", \"no cycles\".\n    # This means 1 is the unique source in the final DAG.\n    # All edges connected to 1 must be outgoing from 1.\n    # This implies that we can start a DFS from 1.\n    # For any edge (u, v, c) where `u` is the parent in the DFS tree and `v` is a child:\n    #   When `dfs(v)` returns, we know the net flow that needs to leave `v`'s subtree via the edge (u, v).\n    #   Let `flow_out_of_subtree[v]` be the net flow that `v` has sent out to its children.\n    #   (i.e., `sum(c_vw for v->w) - sum(c_wv for w->v)` for `w` children of `v`).\n    #   We need to determine the direction of `(u, v, c)` such that `v` is balanced (if `v != 1, n`).\n    #   `flow_out_of_subtree[v]` should be 0 for `1 < v < n`.\n\n    # Let `balance[v]` store the net flow that has been directed *into* `v` so far from edges\n    # whose direction has already been determined.\n    # We want `balance[v]` to be 0 for `1 < v < n`.\n    # `balance[1]` should be 0 (no incoming edges).\n    # `balance[n]` will be the total flow.\n\n    # This is a bit like finding an Eulerian circuit where edge directions are determined.\n    # The condition \"no cycles\" means the resulting graph is a DAG.\n    # The condition \"1 has no incoming edges\" means 1 is a source.\n    # The condition \"1 < v < n, sum(in) = sum(out)\" means these are conservation nodes.\n\n    # Let's use a DFS that determines the \"excess flow\" for each node.\n    # `excess[v]` = sum of flow values of edges directed into `v` - sum of flow values of edges directed out of `v`.\n    # We want `excess[v] = 0` for `1 < v < n`.\n    # `excess[1]` should be 0 (no incoming edges).\n    # `excess[n]` will be the total flow.\n\n    # `dfs(u, p_edge_idx)`:\n    #   `visited[u] = True`\n    #   For each `(v, c, edge_idx)` adjacent to `u`:\n    #     If `edge_idx == p_edge_idx`: continue\n    #     If `not visited_edges[edge_idx]`:\n    #       `visited_edges[edge_idx] = True`\n    #       If `not visited[v]`: (Tree edge)\n    #         `dfs(v, edge_idx)`\n    #         # After `dfs(v)` returns, `balance[v]` is the net flow into `v` from its children.\n    #         # We need to decide direction of (u, v, c).\n    #         # If `u == 1`:\n    #         #   This edge must be `1 -> v`.\n    #         #   `balance[1] -= c` (1 sends flow out)\n    #         #   `balance[v] += c` (v receives flow in)\n    #         #   Set `ans[edge_idx]` for `1 -> v`.\n    #         # Else if `v == n`:\n    #         #   This edge must be `u -> n`.\n    #         #   `balance[u] -= c`\n    #         #   `balance[n] += c`\n    #         #   Set `ans[edge_idx]` for `u -> n`.\n    #         # Else (`1 < u, v < n`):\n    #         #   We want `balance[v]` to be 0 after considering edge `(u, v)`.\n    #         #   `balance[v]` currently holds `sum(in_from_children) - sum(out_to_children)`.\n    #         #   If `balance[v] > 0`: `v` has a surplus from its children. It must send `balance[v]` to `u`. So `v -> u`.\n    #         #     `balance[u] += c` (u receives flow)\n    #         #     `balance[v] -= c` (v sends flow out)\n    #         #     Set `ans[edge_idx]` for `v -> u`.\n    #         #   If `balance[v] < 0`: `v` has a deficit. It must receive `|balance[v]|` from `u`. So `u -> v`.\n    #         #     `balance[u] -= c` (u sends flow out)\n    #         #     `balance[v] += c` (v receives flow)\n    #         #     Set `ans[edge_idx]` for `u -> v`.\n    #         #   If `balance[v] == 0`:\n    #         #     This means `v` is perfectly balanced by its children.\n    #         #     The edge `(u,v)` must carry 0 flow, which is not allowed.\n    #         #     The problem implies that a unique choice for direction is forced.\n    #         #     The only case where `balance[v]` could be 0 before processing `(u,v)` is if `v` is a leaf in the DFS tree.\n    #         #     If `v` is a leaf and `v != n`, then `balance[v]` is 0. We must direct `u -> v`.\n    #         #     `balance[u] -= c`. `balance[v] += c`. Set `ans[edge_idx]` for `u -> v`.\n    #         #     This looks like the correct logic.\n\n    # Final attempt at DFS logic:\n    # `flow_sum[v]` stores the sum of flows that *must* exit `v` via its parent edge `(u,v)`\n    # to balance `v` and its subtree. A positive value means `v` sends flow to `u`.\n    # A negative value means `v` receives flow from `u`.\n\n    # `dfs(u, p_edge_idx)`:\n    #   `visited[u] = True`\n    #   `current_out_flow_from_children = 0` (sum of flows children send to u, or u sends to children)\n    #   For each `(v, c, edge_idx)` adjacent to `u`:\n    #     If `edge_idx == p_edge_idx`: continue\n    #     If `not visited_edges[edge_idx]`:\n    #       `visited_edges[edge_idx] = True`\n    #       If `not visited[v]`: (Tree edge)\n    #         `child_flow = dfs(v, edge_idx)` # `child_flow` is `flow_sum[v]`\n    #         # `child_flow` is the net flow `v` needs to send to `u`.\n    #         # If `child_flow > 0`: `v` sends `child_flow` to `u`.\n    #         #   Since `child_flow` must be exactly `c`, then `v -> u`.\n    #         #   `current_out_flow_from_children += c`.\n    #         #   Set `ans[edge_idx]` for `v -> u`.\n    #         # If `child_flow < 0`: `v` needs `|child_flow|` from `u`.\n    #         #   Since `|child_flow|` must be exactly `c`, then `u -> v`.\n    #         #   `current_out_flow_from_children -= c`.\n    #         #   Set `ans[edge_idx]` for `u -> v`.\n    #         # If `child_flow == 0`: This means `v` is balanced by its children.\n    #         #   If `v == n`, we can direct `u -> n`. `current_out_flow_from_children -= c`.\n    #         #   If `v != n`, this should not happen.\n    #         #   The problem states \"a solution always exists\".\n    #         #   The crucial insight might be that the total flow into `n` from `1` is fixed.\n    #         #   And for `1 < v < n`, `sum(in) = sum(out)`.\n    #         #   This means that for `v != n`, `child_flow` must be `c` or `-c`.\n    #         #   If `v == n`, `child_flow` is the total flow into `n` from its children.\n    #         #   So, for `v == n`, we direct `u -> n`. This is always correct.\n    #         #   `current_out_flow_from_children -= c`.\n    #         #   Set `ans[edge_idx]` for `u -> n`.\n    #         #   For `v != n`:\n    #         #     If `child_flow > 0`: `v -> u`. `current_out_flow_from_children += c`.\n    #         #     Else (`child_flow <= 0`): `u -> v`. `current_out_flow_from_children -= c`.\n    #         #     This `child_flow` is the net flow that `v` has received from its children.\n    #         #     Let `flow_needed_from_parent[v]` be the flow `v` needs from `u`.\n    #         #     `flow_needed_from_parent[v] = sum(c_vw for v->w) - sum(c_wv for w->v)` from children.\n    #         #     If `flow_needed_from_parent[v] > 0`: `v` sent out too much. It needs `flow_needed_from_parent[v]` from `u`. So `u -> v`.\n    #         #       `flow_needed_from_parent[u] += c`.\n    #         #     If `flow_needed_from_parent[v] < 0`: `v` received too much. It needs to send `|flow_needed_from_parent[v]|` to `u`. So `v -> u`.\n    #         #       `flow_needed_from_parent[u] -= c`.\n    #         #     If `flow_needed_from_parent[v] == 0`: `u -> v`. `flow_needed_from_parent[u] += c`.\n    #         #     This `flow_needed_from_parent` is exactly `flow_balance` from previous attempts.\n\n    # Let's define `balance[v]` as the net flow that *must* leave `v` via its parent edge to satisfy flow conservation\n    # within `v`'s subtree (excluding `v`'s parent edge).\n    # Positive `balance[v]` means `v` sends flow to its parent.\n    # Negative `balance[v]` means `v` receives flow from its parent.\n\n    # `dfs(u, p_edge_idx)`:\n    #   `visited[u] = True`\n    #   `current_node_balance = 0` # This accumulates flow for `u`. Positive means `u` has a surplus to send up.\n    #   For each `(v, c, edge_idx)` adjacent to `u`:\n    #     If `edge_idx == p_edge_idx`: continue\n    #     If `not visited_edges[edge_idx]`:\n    #       `visited_edges[edge_idx] = True`\n    #       If `not visited[v]`: (Tree edge)\n    #         `child_balance = dfs(v, edge_idx)` # `child_balance` is `balance[v]` for `v`.\n    #         # `child_balance` is the net flow `v` needs to send up to `u`.\n    #         if child_balance > 0: # `v` has a surplus, sends `child_balance` to `u`.\n    #           # This means flow `v -> u`.\n    #           current_node_balance += c\n    #           orig_u, orig_v, _ = edges_input[edge_idx]\n    #           ans[edge_idx] = 0 if orig_u == v else 1\n    #         else: # `child_balance <= 0`. `v` has a deficit or is balanced. It needs flow from `u`.\n    #           # This means flow `u -> v`.\n    #           current_node_balance -= c\n    #           orig_u, orig_v, _ = edges_input[edge_idx]\n    #           ans[edge_idx] = 0 if orig_u == u else 1\n    #       else: # Back edge (u, v) where `v` is already visited.\n    #         # Since 1 has no incoming edges, and no cycles, all back edges must be `u -> v`\n    #         # where `v` is an ancestor of `u` or `v` is node 1.\n    #         # If `v == 1`, then `u -> 1` is not allowed. So `v` must be an ancestor of `u`.\n    #         # This edge must be `u -> v`.\n    #         current_node_balance -= c\n    #         orig_u, orig_v, _ = edges_input[edge_idx]\n    #         ans[edge_idx] = 0 if orig_u == u else 1\n    #   # For node `n`, its balance doesn't need to be 0.\n    #   # For node `1`, its balance must be 0 (no incoming edges, so all flow goes out).\n    #   # The `current_node_balance` returned from `dfs(u, ...)` is the net flow `u` needs to send to its parent.\n    #   if u == n:\n    #       return 0 # Sink node does not need to balance flow to its parent\n    #   else:\n    #       return current_node_balance\n\n    # The condition \"vertex with number 1 has no incoming edges\" means all edges from 1 must be outgoing.\n    # The condition \"the obtained directed graph does not have cycles\" is key.\n    # This means we can perform a topological sort.\n    # We can use a modified DFS. The `balance` array will store the \"deficit\" of flow for each node.\n    # `balance[v]` = sum of flow *into* `v` - sum of flow *out of* `v`.\n    # We want `balance[v] = 0` for `1 < v < n`.\n    # `balance[1]` should be 0 (no incoming edges, it's a source).\n    # `balance[n]` will be the total flow (positive, as it receives flow).\n\n    # `dfs(u, p_edge_idx)`:\n    #   `visited[u] = True`\n    #   For each `(v, c, edge_idx)` adjacent to `u`:\n    #     If `edge_idx == p_edge_idx`: continue\n    #     If `not visited_edges[edge_idx]`:\n    #       `visited_edges[edge_idx] = True`\n    #       If `not visited[v]`: (Tree edge)\n    #         `dfs(v, edge_idx)`\n    #         # After `dfs(v)` returns, `balance[v]` contains the net flow that `v` has received\n    #         # from its children's subtrees.\n    #         # Now decide direction of `(u, v, c)`.\n    #         # If `u == 1`:\n    #         #   All edges from 1 must be outgoing. So `1 -> v`.\n    #         #   `balance[v] += c`.\n    #         #   Set `ans[edge_idx]` for `1 -> v`.\n    #         # Else if `v == n`:\n    #         #   All edges to n must be incoming. So `u -> n`.\n    #         #   `balance[u] -= c`.\n    #         #   Set `ans[edge_idx]` for `u -> n`.\n    #         # Else (`1 < u, v < n`):\n    #         #   We want `balance[v]` to be 0 after considering `(u,v)`.\n    #         #   If `balance[v] > 0`: `v` has a surplus. It must send `balance[v]` to `u`. So `v -> u`.\n    #         #     `balance[u] += c`.\n    #         #     Set `ans[edge_idx]` for `v -> u`.\n    #         #   If `balance[v] < 0`: `v` has a deficit. It must receive `|balance[v]|` from `u`. So `u -> v`.\n    #         #     `balance[u] -= c`.\n    #         #     Set `ans[edge_idx]` for `u -> v`.\n    #         #   If `balance[v] == 0`:\n    #         #     This means `v` is perfectly balanced by its children.\n    #         #     This implies `(u,v)` must carry 0 flow, which is not possible for given `c > 0`.\n    #         #     This case should not happen for `1 < v < n`.\n    #         #     The only way `balance[v]` can be 0 before considering `(u,v)` is if `v` is a leaf in the DFS tree.\n    #         #     If `v` is a leaf and `v != n`, then `balance[v]` is 0.\n    #         #     We must direct `u -> v`. `balance[u] -= c`. Set `ans[edge_idx]` for `u -> v`.\n    #         #     This choice makes `balance[v]` become `c`. This is wrong.\n    #         #     `balance[v]` should become 0. So `u -> v` implies `balance[v] += c`.\n    #         #     Then `balance[v]` becomes `c`. This is not 0.\n\n    # The problem is that the `balance` variable is not global. It's specific to the current node.\n    # Let `balance[v]` be the net flow *out* of `v` that needs to be satisfied by its parent `u`.\n    # `dfs(u, p_edge_idx)`:\n    #   `visited[u] = True`\n    #   `current_excess_out = 0` # Accumulates net flow that `u` sends out to its children.\n    #   For each `(v, c, edge_idx)` adjacent to `u`:\n    #     If `edge_idx == p_edge_idx`: continue\n    #     If `not visited_edges[edge_idx]`:\n    #       `visited_edges[edge_idx] = True`\n    #       If `not visited[v]`: (Tree edge)\n    #         `child_excess_out = dfs(v, edge_idx)` # `child_excess_out` is `balance[v]` for `v`.\n    #         # `child_excess_out` is the net flow `v` sent to its children.\n    #         # If `v == n`:\n    #         #   All edges to `n` must be incoming. So `u -> n`.\n    #         #   `current_excess_out += c`. (u sends c to n)\n    #         #   Set `ans[edge_idx]` for `u -> n`.\n    #         # Else (`1 < v < n`):\n    #         #   We need `v` to be balanced. `child_excess_out` is `sum(v->w) - sum(w->v)` for children `w`.\n    #         #   If `child_excess_out > 0`: `v` sent too much. It needs `child_excess_out` from `u`. So `u -> v`.\n    #         #     `current_excess_out += c`. (u sends c to v)\n    #         #     Set `ans[edge_idx]` for `u -> v`.\n    #         #   If `child_excess_out < 0`: `v` received too much. It needs to send `|child_excess_out|` to `u`. So `v -> u`.\n    #         #     `current_excess_out -= c`. (u receives c from v)\n    #         #     Set `ans[edge_idx]` for `v -> u`.\n    #         #   If `child_excess_out == 0`:\n    #         #     `v` is balanced by its children. We can direct `u -> v`.\n    #         #     `current_excess_out += c`.\n    #         #     Set `ans[edge_idx]` for `u -> v`.\n    #       else: # Back edge (u, v) where `v` is already visited.\n    #         # These edges must be `u -> v` to avoid cycles and satisfy 1's no-incoming.\n    #         # (Unless v is 1, which means u -> 1, which is forbidden).\n    #         # This implies `v` is an ancestor of `u`.\n    #         # So, `u -> v`.\n    #         `current_excess_out += c`.\n    #         orig_u, orig_v, _ = edges_input[edge_idx]\n    #         ans[edge_idx] = 0 if orig_u == u else 1\n    #   return current_excess_out # This is the net flow `u` sent to its children.\n\n    # This is the correct logic for `flow_balance[v]` representing the total flow that `v` has received\n    # from its children (positive if received more, negative if sent more).\n    # When DFS(v) returns to u:\n    #   `flow_balance[v]` is the sum of `c` for edges `w->v` minus sum of `c` for edges `v->w`\n    #   where `w` are children of `v` in the DFS tree.\n    #   This `flow_balance[v]` needs to be balanced by the edge (u, v).\n\n    # Let's use `current_balance[v]` as the net flow that *has entered* `v` from its subtree.\n    # So `current_balance[v] = sum(c_wv for w->v) - sum(c_vw for v->w)`.\n    # We want `current_balance[v]` to be 0 for `1 < v < n`.\n    # `current_balance[1]` should be 0 (no incoming).\n    # `current_balance[n]` should be total flow (all incoming).\n\n    # `dfs(u, p_edge_idx)`:\n    #   `visited[u] = True`\n    #   For each `(v, c, edge_idx)` adjacent to `u`:\n    #     If `edge_idx == p_edge_idx`: continue\n    #     If `not visited_edges[edge_idx]`:\n    #       `visited_edges[edge_idx] = True`\n    #       If `not visited[v]`: (Tree edge)\n    #         `dfs(v, edge_idx)`\n    #         # After `dfs(v)` returns, `current_balance[v]` holds the net flow `v` received from its children.\n    #         # Now decide direction of `(u, v, c)`.\n    #         orig_u, orig_v, _ = edges_input[edge_idx]\n    #         if u == 1: # Source node. All edges from 1 must be outgoing.\n    #             # So, 1 -> v.\n    #             ans[edge_idx] = 0 if orig_u == u else 1\n    #             current_balance[u] -= c # 1 sends flow out\n    #             current_balance[v] += c # v receives flow in\n    #         elif v == n: # Sink node. All edges to n must be incoming.\n    #             # So, u -> n.\n    #             ans[edge_idx] = 0 if orig_u == u else 1\n    #             current_balance[u] -= c # u sends flow out\n    #             current_balance[n] += c # n receives flow in\n    #         else: # `1 < u, v < n`. Conservation nodes.\n    #             # We want `current_balance[v]` to be 0 after considering edge `(u,v)`.\n    #             if current_balance[v] > 0: # `v` has a surplus. It must send `current_balance[v]` to `u`. So `v -> u`.\n    #                 ans[edge_idx] = 0 if orig_u == v else 1\n    #                 current_balance[u] += c # u receives flow\n    #                 current_balance[v] -= c # v sends flow out\n    #             elif current_balance[v] < 0: # `v` has a deficit. It must receive `|current_balance[v]|` from `u`. So `u -> v`.\n    #                 ans[edge_idx] = 0 if orig_u == u else 1\n    #                 current_balance[u] -= c # u sends flow out\n    #                 current_balance[v] += c # v receives flow\n    #             else: # `current_balance[v] == 0`. `v` is perfectly balanced by its children.\n    #                   # This means the edge `(u,v)` must carry 0 flow to maintain `v`'s balance.\n    #                   # This is only possible if `v` is a leaf and `v != n`.\n    #                   # If `v` is a leaf and `v != n`, then `current_balance[v]` is 0.\n    #                   # The problem implies a unique choice is forced.\n    #                   # The \"no cycles\" condition is important.\n    #                   # If `current_balance[v] == 0`, we must direct `u -> v`.\n    #                   # This is a forward edge in the DFS tree.\n    #                   ans[edge_idx] = 0 if orig_u == u else 1\n    #                   current_balance[u] -= c\n    #                   current_balance[v] += c\n    #       else: # Back edge (u, v) where `v` is already visited.\n    #         # This edge must be directed `u -> v` to avoid cycles.\n    #         # `v` must be an ancestor of `u`.\n    #         # If `v == 1`, `u -> 1` is forbidden. This implies `v` cannot be 1.\n    #         # So `u -> v`.\n    #         orig_u, orig_v, _ = edges_input[edge_idx]\n    #         ans[edge_idx] = 0 if orig_u == u else 1\n    #         current_balance[u] -= c\n    #         current_balance[v] += c\n\n    # This DFS logic still has an issue with `current_balance[v] == 0` for `1 < v < n`.\n    # If `current_balance[v]` is 0, and we direct `u -> v`, then `current_balance[v]` becomes `c`, not 0.\n    # This implies that `current_balance[v]` should NOT be 0 for `1 < v < n` when returning from `dfs(v)`.\n    # It should be `c` or `-c`.\n\n    # Let's try again with the `balance` variable representing the net flow that needs to be sent *up* the DFS tree.\n    # `balance[v]` = sum of flows from children of `v` that `v` needs to send up to `u`\n    #                - sum of flows from `v` to children that `v` needs to receive from `u`.\n    # So, positive `balance[v]` means `v` has a surplus and sends `balance[v]` to `u`.\n    # Negative `balance[v]` means `v` has a deficit and receives `|balance[v]|` from `u`.\n\n    def dfs(u, p_edge_idx):\n        visited[u] = True\n        \n        # current_balance_for_u: net flow that u needs to send up to its parent.\n        # Positive means u has a surplus from its children/back-edges, needs to send up.\n        # Negative means u has a deficit from its children/back-edges, needs to receive from parent.\n        current_balance_for_u = 0\n\n        for v, c, edge_idx in adj[u]:\n            if edge_idx == p_edge_idx:\n                continue\n            \n            if not visited_edges[edge_idx]:\n                visited_edges[edge_idx] = True\n                orig_u_edge, orig_v_edge, _ = edges_input[edge_idx]\n\n                if not visited[v]: # Tree edge (u, v)\n                    child_balance = dfs(v, edge_idx)\n                    \n                    if v == n: # If child is sink, flow must go u -> n.\n                        ans[edge_idx] = 0 if orig_u_edge == u else 1\n                        current_balance_for_u += c # u sends c to v\n                    elif child_balance > 0: # v has surplus, sends flow to u. So v -> u.\n                        ans[edge_idx] = 0 if orig_u_edge == v else 1\n                        current_balance_for_u += c # u receives c from v\n                    else: # v has deficit (child_balance <= 0), receives flow from u. So u -> v.\n                        ans[edge_idx] = 0 if orig_u_edge == u else 1\n                        current_balance_for_u -= c # u sends c to v\n                else: # Back edge (u, v) where v is already visited.\n                    # This edge must be directed u -> v to avoid cycles and satisfy 1's no-incoming.\n                    # If v is 1, u -> 1 is forbidden. The problem guarantees a solution exists,\n                    # so this case won't create an issue.\n                    ans[edge_idx] = 0 if orig_u_edge == u else 1\n                    current_balance_for_u -= c # u sends c to v\n        \n        # After processing all children and back-edges from u,\n        # `current_balance_for_u` is the net flow `u` has sent out to its children/back-edges.\n        # For node `u` (1 < u < n), its net flow must be 0.\n        # So, if `current_balance_for_u` is positive, `u` has sent out too much flow.\n        # It needs to receive `current_balance_for_u` from its parent.\n        # If `current_balance_for_u` is negative, `u` has received too much flow.\n        # It needs to send `|current_balance_for_u|` to its parent.\n        \n        # The return value is the flow `u` needs to send up to its parent.\n        # If `u == 1`, it cannot receive flow, so its `current_balance_for_u` should represent the total flow.\n        # If `u == n`, it doesn't need to send flow up. Its balance can be anything.\n        \n        if u == n:\n            return 0 # Sink node doesn't need to balance with parent\n        else:\n            return current_balance_for_u\n\n    # Start DFS from node 1.\n    dfs(1, -1)\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + \"\\n\")\n\nsolve()"}
{"task_id": "E2H_CF808E", "completion": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    items_w1 = []\n    items_w2 = []\n    items_w3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            items_w1.append(c)\n        elif w == 2:\n            items_w2.append(c)\n        else:\n            items_w3.append(c)\n\n    items_w1.sort(reverse=True)\n    items_w2.sort(reverse=True)\n    items_w3.sort(reverse=True)\n\n    prefix_sum_w1 = [0] * (len(items_w1) + 1)\n    for i in range(len(items_w1)):\n        prefix_sum_w1[i+1] = prefix_sum_w1[i] + items_w1[i]\n\n    prefix_sum_w2 = [0] * (len(items_w2) + 1)\n    for i in range(len(items_w2)):\n        prefix_sum_w2[i+1] = prefix_sum_w2[i] + items_w2[i]\n\n    prefix_sum_w3 = [0] * (len(items_w3) + 1)\n    for i in range(len(items_w3)):\n        prefix_sum_w3[i+1] = prefix_sum_w3[i] + items_w3[i]\n\n    max_cost = 0\n\n    # Iterate through possible counts of items with weight 3\n    for count3 in range(len(items_w3) + 1):\n        weight_used_by_w3 = count3 * 3\n        cost_by_w3 = prefix_sum_w3[count3]\n\n        if weight_used_by_w3 > m:\n            break\n\n        remaining_weight = m - weight_used_by_w3\n        \n        # Iterate through possible counts of items with weight 2\n        for count2 in range(len(items_w2) + 1):\n            weight_used_by_w2 = count2 * 2\n            cost_by_w2 = prefix_sum_w2[count2]\n\n            if weight_used_by_w2 > remaining_weight:\n                break\n\n            remaining_weight_for_w1 = remaining_weight - weight_used_by_w2\n            \n            # Use as many items with weight 1 as possible\n            count1 = min(remaining_weight_for_w1, len(items_w1))\n            cost_by_w1 = prefix_sum_w1[count1]\n\n            current_total_cost = cost_by_w3 + cost_by_w2 + cost_by_w1\n            max_cost = max(max_cost, current_total_cost)\n\n    sys.stdout.write(str(max_cost) + '\\n')\n\nsolve()"}
{"task_id": "E2H_CF409I", "completion": "import sys\n\ndef solve():\n    name = sys.stdin.readline().strip()\n\n    def parse_expression(s):\n        balance = 0\n        operators = []\n        operands = []\n        i = 0\n        while i < len(s):\n            if s[i] == '(':\n                balance += 1\n                i += 1\n            elif s[i] == ')':\n                balance -= 1\n                i += 1\n            elif s[i] == '_':\n                operands.append(('_', balance))\n                i += 1\n            elif s[i] in ['+', '-', '*', '/']:\n                operators.append((s[i], balance))\n                i += 1\n            else:\n                i += 1\n        return operands, operators\n\n    def evaluate(expression, values):\n        stack = []\n        var_idx = 0\n        for char_type, _ in expression:\n            if char_type == '_':\n                if var_idx >= len(values):\n                    return None\n                stack.append(values[var_idx])\n                var_idx += 1\n            else:\n                if len(stack) < 2:\n                    return None\n                b = stack.pop()\n                a = stack.pop()\n                if char_type == '+':\n                    stack.append(a + b)\n                elif char_type == '-':\n                    stack.append(a - b)\n                elif char_type == '*':\n                    stack.append(a * b)\n                elif char_type == '/':\n                    if b == 0:\n                        return None\n                    stack.append(a // b)\n        if len(stack) == 1:\n            return stack[0]\n        return None\n\n    parts = name.split(':-')\n    jaws_part = parts[0]\n    stomach_part = parts[1]\n\n    jaws_expression_str = jaws_part[1:-1] # Remove ?()\n    \n    jaws_operands_raw = []\n    jaws_operators_raw = []\n    \n    balance = 0\n    i = 0\n    while i < len(jaws_expression_str):\n        if jaws_expression_str[i] == '(':\n            balance += 1\n            i += 1\n        elif jaws_expression_str[i] == ')':\n            balance -= 1\n            i += 1\n        elif jaws_expression_str[i] == '_':\n            jaws_operands_raw.append(('_', balance))\n            i += 1\n        elif jaws_expression_str[i] in ['+', '-', '*', '/']:\n            jaws_operators_raw.append((jaws_expression_str[i], balance))\n            i += 1\n        else:\n            i += 1\n\n    num_variables = len(jaws_operands_raw)\n    \n    # Convert to RPN for evaluation\n    def to_rpn(operands_raw, operators_raw):\n        output = []\n        op_stack = []\n        \n        # Combine and sort by balance and then by original order\n        all_tokens = []\n        op_idx = 0\n        var_idx = 0\n        \n        s_idx = 0\n        while s_idx < len(jaws_expression_str):\n            if jaws_expression_str[s_idx] == '_':\n                all_tokens.append((jaws_operands_raw[var_idx][0], jaws_operands_raw[var_idx][1], s_idx))\n                var_idx += 1\n            elif jaws_expression_str[s_idx] in ['+', '-', '*', '/']:\n                all_tokens.append((jaws_operators_raw[op_idx][0], jaws_operators_raw[op_idx][1], s_idx))\n                op_idx += 1\n            s_idx += 1\n        \n        # Sort by original index to maintain order\n        all_tokens.sort(key=lambda x: x[2])\n        \n        precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n\n        for token, bal, _ in all_tokens:\n            if token == '_':\n                output.append((token, bal))\n            elif token in precedence:\n                while (op_stack and op_stack[-1][0] != '(' and\n                       (precedence.get(op_stack[-1][0], 0) > precedence[token] or\n                        (precedence.get(op_stack[-1][0], 0) == precedence[token] and token in ['+', '*'])) and\n                       op_stack[-1][1] >= bal): # Consider balance for operator precedence\n                    output.append(op_stack.pop())\n                op_stack.append((token, bal))\n            elif token == '(':\n                op_stack.append((token, bal))\n            elif token == ')':\n                while op_stack and op_stack[-1][0] != '(':\n                    output.append(op_stack.pop())\n                if op_stack and op_stack[-1][0] == '(':\n                    op_stack.pop()\n        \n        while op_stack:\n            output.append(op_stack.pop())\n        return output\n\n    jaws_rpn = to_rpn(jaws_operands_raw, jaws_operators_raw)\n\n    stomach_conditions_str = stomach_part.split(',')\n    \n    stomach_conditions = []\n    for cond_str in stomach_conditions_str:\n        if '>' in cond_str:\n            op = '>'\n        elif '<' in cond_str:\n            op = '<'\n        else:\n            sys.stderr.write(f\"Unknown operator in condition: {cond_str}\\n\")\n            return\n        \n        left_str, right_str = cond_str.split(op)\n        \n        # Count underscores to determine number of variables for each side\n        left_vars = left_str.count('_')\n        right_vars = right_str.count('_')\n        \n        stomach_conditions.append((left_vars, op, right_vars))\n\n    def check_conditions(jaws_result, values):\n        var_idx = 0\n        for left_vars, op, right_vars in stomach_conditions:\n            if var_idx + left_vars + right_vars > len(values):\n                return False # Not enough values for this condition\n            \n            left_val_list = values[var_idx : var_idx + left_vars]\n            var_idx += left_vars\n            right_val_list = values[var_idx : var_idx + right_vars]\n            var_idx += right_vars\n\n            left_val = int(\"\".join(map(str, left_val_list))) if left_val_list else 0\n            right_val = int(\"\".join(map(str, right_val_list))) if right_val_list else 0\n\n            if op == '>':\n                if not (left_val > right_val):\n                    return False\n            elif op == '<':\n                if not (left_val < right_val):\n                    return False\n        return True\n\n    min_length = num_variables\n    for left_vars, _, right_vars in stomach_conditions:\n        min_length += left_vars + right_vars\n\n    best_solution = \"false\"\n\n    # Iterate through all possible variable lengths for the stomach part\n    # The minimum total number of variables is num_variables (for jaws) + sum of variables in conditions\n    \n    # The maximum total number of variables is harder to define without constraints,\n    # but for competitive programming, it's usually small enough (e.g., 10-15)\n    # Let's try up to 15 variables in total for now.\n    \n    # The total number of variables for the entire problem is the sum of variables in jaws and variables in stomach conditions.\n    total_vars_needed = num_variables\n    for lv, op, rv in stomach_conditions:\n        total_vars_needed += lv + rv\n        \n    if total_vars_needed > 10: # A heuristic limit to prevent excessive computation\n        sys.stdout.write(\"false\\n\")\n        return\n\n    # Generate all possible sequences of digits\n    # The number of digits is fixed by the problem structure (num_variables for jaws + sum of underscores in conditions)\n    \n    import itertools\n\n    for values_tuple in itertools.product(range(10), repeat=total_vars_needed):\n        values_list = list(values_tuple)\n\n        jaws_input_values = values_list[:num_variables]\n        \n        jaws_result = evaluate(jaws_rpn, jaws_input_values)\n\n        if jaws_result is not None and jaws_result >= 0: # Golorp only eats non-negative results\n            stomach_input_values = values_list[num_variables:]\n            if check_conditions(jaws_result, stomach_input_values):\n                current_solution = \"\".join(map(str, values_list))\n                if best_solution == \"false\" or current_solution < best_solution:\n                    best_solution = current_solution\n    \n    sys.stdout.write(best_solution + \"\\n\")\n\nsolve()"}
{"task_id": "E2H_CF151A", "completion": "def solve():\n    line = input().split()\n    n, k, l, c, d, p, nl, np = map(int, line)\n\n    # Calculate total milliliters of drink available\n    total_drink_ml = k * l\n    # Calculate how many toasts can be made based on drink\n    toasts_from_drink = total_drink_ml // (n * nl)\n\n    # Calculate total slices of lime available\n    total_lime_slices = c * d\n    # Calculate how many toasts can be made based on lime\n    toasts_from_lime = total_lime_slices // n\n\n    # Calculate how many toasts can be made based on salt\n    toasts_from_salt = p // (n * np)\n\n    # The number of toasts each friend can make is limited by the minimum of these three\n    result = min(toasts_from_drink, toasts_from_lime, toasts_from_salt)\n\n    print(result)\n\nif __name__ == '__main__':\n    solve()"}
{"task_id": "E2H_CF339B", "completion": "def solve():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    current_house = 1\n    total_time = 0\n\n    for task_house in a:\n        if task_house >= current_house:\n            total_time += (task_house - current_house)\n        else:\n            total_time += (n - current_house + task_house)\n        current_house = task_house\n    \n    print(total_time)\n\nsolve()"}
{"task_id": "E2H_CF88A", "completion": "def solve():\n    notes_input = input().split()\n\n    note_to_semitone = {\n        \"C\": 0, \"C#\": 1, \"D\": 2, \"D#\": 3, \"E\": 4, \"F\": 5,\n        \"F#\": 6, \"G\": 7, \"G#\": 8, \"A\": 9, \"B\": 10, \"H\": 11\n    }\n\n    semitones = [note_to_semitone[n] for n in notes_input]\n\n    def is_major(s1, s2, s3):\n        diff1 = (s2 - s1 + 12) % 12\n        diff2 = (s3 - s2 + 12) % 12\n        return diff1 == 4 and diff2 == 3\n\n    def is_minor(s1, s2, s3):\n        diff1 = (s2 - s1 + 12) % 12\n        diff2 = (s3 - s2 + 12) % 12\n        return diff1 == 3 and diff2 == 4\n\n    def check_chord_type(semis):\n        # Sort the semitones to make checking easier for a fixed root\n        # However, the problem states \"if we can order the notes\",\n        # so we need to try all permutations as roots.\n        \n        # Consider each note as the potential root (X)\n        for i in range(3):\n            s1 = semis[i]\n            remaining = [semis[j] for j in range(3) if j != i]\n            \n            # Try both permutations of the remaining two notes as Y and Z\n            # Permutation 1: Y = remaining[0], Z = remaining[1]\n            s2_p1 = remaining[0]\n            s3_p1 = remaining[1]\n            \n            # Permutation 2: Y = remaining[1], Z = remaining[0]\n            s2_p2 = remaining[1]\n            s3_p2 = remaining[0]\n\n            # Check major\n            if is_major(s1, s2_p1, s3_p1) or is_major(s1, s2_p2, s3_p2):\n                return \"major\"\n            \n            # Check minor\n            if is_minor(s1, s2_p1, s3_p1) or is_minor(s1, s2_p2, s3_p2):\n                return \"minor\"\n        \n        return \"strange\"\n\n    print(check_chord_type(semitones))\n\nif __name__ == '__main__':\n    solve()"}
{"task_id": "E2H_CF633B", "completion": "def solve():\n    m = int(input())\n\n    def count_trailing_zeros(n):\n        count = 0\n        i = 5\n        while n // i >= 1:\n            count += n // i\n            i *= 5\n        return count\n\n    # We are looking for n such that count_trailing_zeros(n) == m.\n    # The function count_trailing_zeros(n) is non-decreasing.\n    # We can use binary search to find the smallest n for which count_trailing_zeros(n) >= m.\n\n    # A rough upper bound for n:\n    # m = n/5 + n/25 + ... approx n/4\n    # So n approx 4m.\n    # Let's set a safe upper bound, e.g., 5 * m + 10 (or even larger, 5 * m is usually enough)\n    # For m = 100,000, n could be around 400,000.\n    # A safe upper bound for binary search: 5 * 100,000 = 500,000.\n    # Let's use a slightly larger one like 5 * m + 5.\n    # The maximum m is 100,000, so max n could be around 400,000.\n    # A search range up to 500,000 or 600,000 is safe.\n    \n    low = 1\n    high = 5 * m + 5  # A safe upper bound, as n is roughly 4m\n    \n    ans_start = -1\n\n    while low <= high:\n        mid = (low + high) // 2\n        zeros = count_trailing_zeros(mid)\n        if zeros >= m:\n            ans_start = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n\n    if ans_start == -1 or count_trailing_zeros(ans_start) != m:\n        print(0)\n        print()\n    else:\n        # If count_trailing_zeros(ans_start) == m, then\n        # count_trailing_zeros(ans_start+1), count_trailing_zeros(ans_start+2), count_trailing_zeros(ans_start+3), count_trailing_zeros(ans_start+4)\n        # will also be m, because the number of trailing zeros only increases when n is a multiple of 5.\n        # So, for n = ans_start, ans_start+1, ans_start+2, ans_start+3, ans_start+4, the number of zeros will be m.\n        # For n = ans_start+5, the number of zeros will be m+1 (or more).\n        \n        results = []\n        current_n = ans_start\n        while count_trailing_zeros(current_n) == m:\n            results.append(current_n)\n            current_n += 1\n        \n        print(len(results))\n        print(*results)\n\nsolve()"}
{"task_id": "E2H_CF1767D", "completion": "def solve():\n    n = int(input())\n    s = input()\n\n    count_zeros = s.count('0')\n    count_ones = s.count('1')\n\n    min_winning_skill = (1 << count_zeros)\n    max_winning_skill = (1 << n) - (1 << count_ones) + 1\n\n    winning_skills = []\n    for i in range(min_winning_skill, max_winning_skill + 1):\n        winning_skills.append(i)\n\n    print(*(sorted(winning_skills)))\n\nif __name__ == '__main__':\n    solve()"}
{"task_id": "E2H_CF498A", "completion": "def solve():\n    x1, y1 = map(int, input().split())\n    x2, y2 = map(int, input().split())\n    n = int(input())\n\n    count = 0\n    for _ in range(n):\n        a, b, c = map(int, input().split())\n\n        val1 = a * x1 + b * y1 + c\n        val2 = a * x2 + b * y2 + c\n\n        if (val1 > 0 and val2 < 0) or (val1 < 0 and val2 > 0):\n            count += 1\n    print(count)\n\nif __name__ == '__main__\":\n    solve()"}
{"task_id": "E2H_CF1092C", "completion": "def solve():\n    n = int(input())\n    lines = [input() for _ in range(2 * n - 2)]\n\n    # Group strings by length\n    grouped_strings = [[] for _ in range(n)]\n    for s in lines:\n        grouped_strings[len(s)].append(s)\n\n    # Find the two strings of length n-1\n    s1_len_n_minus_1 = grouped_strings[n - 1][0]\n    s2_len_n_minus_1 = grouped_strings[n - 1][1]\n\n    # Candidate original strings\n    # Candidate 1: s1_len_n_minus_1 is prefix, s2_len_n_minus_1 is suffix\n    # The original string would be s1_len_n_minus_1 + s2_len_n_minus_1[-1]\n    # And s2_len_n_minus_1 must be a suffix of this, meaning\n    # s1_len_n_minus_1[0] + s2_len_n_minus_1 should be the original string\n    # So, s1_len_n_minus_1[0] == s2_len_n_minus_1[0]\n    # and s1_len_n_minus_1[-1] == s2_len_n_minus_1[-1]\n    # No, this is not how it works.\n    # If P = s1_len_n_minus_1 and S = s2_len_n_minus_1\n    # Then the original string s must be P + char, where char is the last char of S.\n    # And s must also be char + S, where char is the first char of P.\n    # So, s = P + S[0] (if S is the suffix of length n-1)\n    # or s = S[0] + P (if P is the suffix of length n-1)\n    # Let's try to construct the full string s.\n    # If s1_len_n_minus_1 is the prefix of length n-1, and s2_len_n_minus_1 is the suffix of length n-1.\n    # Then s = s1_len_n_minus_1 + s2_len_n_minus_1[-1]\n    # Also, s = s2_len_n_minus_1[0] + s2_len_n_minus_1\n    # So, s1_len_n_minus_1[1:] must be equal to s2_len_n_minus_1[:-1]\n    # This means s1_len_n_minus_1[0] + s1_len_n_minus_1[1:] == s2_len_n_minus_1[0] + s2_len_n_minus_1[1:]\n    # And s1_len_n_minus_1[0] + s1_len_n_minus_1[1:] == s1_len_n_minus_1[0] + s2_len_n_minus_1[:-1]\n    # No, this is getting confusing.\n    # Let the full string be S_full.\n    # If s1_len_n_minus_1 is P and s2_len_n_minus_1 is S:\n    # S_full = s1_len_n_minus_1 + s2_len_n_minus_1[-1]\n    # S_full = s2_len_n_minus_1[0] + s2_len_n_minus_1\n    # These two must be consistent.\n    # This implies s1_len_n_minus_1[1:] must be equal to s2_len_n_minus_1[:-1].\n    # So, s1_len_n_minus_1[0] + s1_len_n_minus_1[1:] == s2_len_n_minus_1[0] + s2_len_n_minus_1[1:]\n    # And s1_len_n_minus_1[0] + s1_len_n_minus_1[1:] == s1_len_n_minus_1[0] + s2_len_n_minus_1[:-1]\n    # So, s1_len_n_minus_1[0] + s1_len_n_minus_1[1:] == s1_len_n_minus_1[0] + s2_len_n_minus_1[:-1]\n    # And s2_len_n_minus_1[0] + s2_len_n_minus_1[1:] == s1_len_n_minus_1[0] + s2_len_n_minus_1[1:]\n    # This means s1_len_n_minus_1[0] == s2_len_n_minus_1[0]\n    # and s1_len_n_minus_1[1:] == s2_len_n_minus_1[:-1]\n    # No, this is incorrect.\n    # The common part of P and S is the substring of length n-2.\n    # S_full = P + S[-1]\n    # S_full = S[0] + S\n    # So, P[1:] must be equal to S[:-1] for the construction to be valid.\n    # If this condition holds, then S_full = P[0] + P[1:] + S[-1] = P[0] + S[:-1] + S[-1]\n    # And S_full = S[0] + S[1:] + S[-1] = S[0] + P[1:] + S[-1]\n    # So, P[0] must be equal to S[0].\n    # No, this is still not right.\n    # Let P_n_minus_1 be the prefix of length n-1.\n    # Let S_n_minus_1 be the suffix of length n-1.\n    # Then the full string s must be P_n_minus_1 + S_n_minus_1[-1]\n    # And the full string s must also be S_n_minus_1[0] + S_n_minus_1\n    # For these two to be consistent, P_n_minus_1[1:] must be equal to S_n_minus_1[:-1].\n    # If this condition is met, then candidate_s = P_n_minus_1 + S_n_minus_1[-1].\n\n    candidate_s_1 = \"\"\n    candidate_s_2 = \"\"\n\n    # Case 1: s1_len_n_minus_1 is prefix, s2_len_n_minus_1 is suffix\n    if s1_len_n_minus_1[1:] == s2_len_n_minus_1[:-1]:\n        candidate_s_1 = s1_len_n_minus_1 + s2_len_n_minus_1[-1]\n\n    # Case 2: s2_len_n_minus_1 is prefix, s1_len_n_minus_1 is suffix\n    if s2_len_n_minus_1[1:] == s1_len_n_minus_1[:-1]:\n        candidate_s_2 = s2_len_n_minus_1 + s1_len_n_minus_1[-1]\n\n    # Check which candidate string works\n    def check_string(full_s, original_lines):\n        if not full_s:\n            return None, None\n\n        n_val = len(full_s)\n        \n        # Generate expected prefixes and suffixes\n        expected_prefixes = set()\n        expected_suffixes = set()\n        for i in range(1, n_val):\n            expected_prefixes.add(full_s[:i])\n            expected_suffixes.add(full_s[n_val-i:])\n\n        # Count occurrences of each string in input\n        input_counts = {}\n        for s in original_lines:\n            input_counts[s] = input_counts.get(s, 0) + 1\n\n        # Check if expected prefixes and suffixes match input\n        temp_input_counts = input_counts.copy()\n        \n        # Try to match all prefixes\n        for p in expected_prefixes:\n            if p in temp_input_counts and temp_input_counts[p] > 0:\n                temp_input_counts[p] -= 1\n            else:\n                return None, None # Missing prefix\n\n        # Try to match all suffixes\n        for s in expected_suffixes:\n            if s in temp_input_counts and temp_input_counts[s] > 0:\n                temp_input_counts[s] -= 1\n            else:\n                return None, None # Missing suffix\n\n        # All counts should be zero if everything matched perfectly\n        if all(count == 0 for count in temp_input_counts.values()):\n            return full_s, expected_prefixes\n\n        return None, None\n\n    # Try candidate_s_1\n    found_s, prefixes_set = check_string(candidate_s_1, lines)\n    if found_s:\n        result = []\n        prefix_assigned_counts = {p: 0 for p in prefixes_set}\n        \n        for s in lines:\n            if s in prefixes_set and prefix_assigned_counts[s] == 0:\n                result.append('P')\n                prefix_assigned_counts[s] = 1\n            else:\n                result.append('S')\n        print(\"\".join(result))\n        return\n\n    # Try candidate_s_2\n    found_s, prefixes_set = check_string(candidate_s_2, lines)\n    if found_s:\n        result = []\n        prefix_assigned_counts = {p: 0 for p in prefixes_set}\n        \n        for s in lines:\n            if s in prefixes_set and prefix_assigned_counts[s] == 0:\n                result.append('P')\n                prefix_assigned_counts[s] = 1\n            else:\n                result.append('S')\n        print(\"\".join(result))\n        return\n\nsolve()"}
{"task_id": "E2H_CF1146D", "completion": "import sys\nimport collections\n\ndef solve():\n    m, a, b = map(int, sys.stdin.readline().split())\n\n    # dp[rem] stores the minimum position reachable that has remainder 'rem' when divided by gcd(a, b)\n    # We are interested in positions reachable from 0, so all reachable positions are multiples of gcd(a, b).\n    # Since we can always scale down, let's work with a' = a/g, b' = b/g, and x' = x/g.\n    # The problem statement implies we are looking for actual positions, so we need to be careful.\n    # A position k is reachable if k = c1*a - c2*b for some non-negative integers c1, c2.\n    # This means k must be a multiple of g = gcd(a, b).\n    # If k is reachable, then k = c * g for some integer c.\n    # The question is about distinct integers, not distinct multiples of g.\n\n    # Let g = gcd(a, b). All reachable positions must be multiples of g.\n    # If a position k is reachable, then k = c_1 * a - c_2 * b.\n    # This means k % g == 0.\n    # We can effectively divide a, b, and x by g.\n    # Let a' = a/g, b' = b/g. Now gcd(a', b') = 1.\n    # Any reachable position k must be a multiple of g.\n    # The number of distinct integers reachable in [0, x] is the number of multiples of g reachable in [0, x].\n    # This is equivalent to finding the number of distinct integers reachable in [0, x/g] using jumps a' and b'.\n    # After finding f'(x') for a', b', we have f(x) = f'(x/g).\n    # The sum would be sum_{i=0 to m} f(i).\n    # This transformation is tricky because f(i) only counts if i is a multiple of g.\n    # If i is not a multiple of g, f(i) = f(i-1) if the maximum reachable point is less than i.\n    # This is not correct. f(i) is defined based on the interval [0, i].\n\n    # Let's re-evaluate.\n    # The frog can reach any position k = c1*a - c2*b such that c1, c2 >= 0, and all intermediate positions\n    # visited are within [0, x]. This definition is slightly ambiguous.\n    # \"an integer is counted if the frog can somehow reach it if it starts from 0.\"\n    # This means, for a given x, we find the set S_x of all integers k that can be reached from 0\n    # such that there exists a path from 0 to k where all intermediate points are in [0, x].\n    # Then f(x) = |S_x|.\n\n    # The maximum reachable point from 0 is always 0.\n    # We are considering a path from 0 to k where all points are in [0, x].\n    # This implies that k itself must be in [0, x].\n    # So S_x = { k | k can be reached from 0, k in [0, x], and all intermediate points in path are in [0, x] }.\n    # This is equivalent to finding all reachable points k in [0, x] such that k can be reached without ever going below 0 or above x.\n    # This is a standard BFS/Dijkstra type problem.\n\n    # Let g = gcd(a, b). All reachable points must be multiples of g.\n    # Let min_pos[r] be the minimum reachable position k >= 0 such that k % a == r.\n    # We are interested in positions modulo a.\n    # Why modulo a? Because if we are at k, we can jump to k+a or k-b.\n    # Jumping k+a doesn't change k % a.\n    # Jumping k-b changes k % a to (k-b) % a.\n    # This structure suggests Dijkstra on remainders.\n\n    # min_dist[r] = minimum non-negative position k such that k % a == r and k is reachable from 0.\n    # Initialize min_dist with infinity, min_dist[0] = 0.\n    # Use a deque for 0-1 BFS.\n    # Nodes are remainders 0 to a-1.\n    # Edge (u, (u+a)%a) has weight 0 (effectively, we stay at same remainder, jump k+a).\n    # Edge (u, (u-b)%a) has weight b (we jump k-b, effectively changing k to k-b, distance increases by b).\n    # This is not quite right. min_dist[r] is the value k itself, not a cost.\n\n    # Let's use a BFS/Dijkstra approach to find all reachable points.\n    # reachable[k] = True if k is reachable.\n    # max_reachable_val[k] = maximum value encountered on a path from 0 to k, assuming k is reachable.\n    # min_reachable_val[k] = minimum value encountered on a path from 0 to k, assuming k is reachable.\n    # This is too complex. The problem states \"if it never jumps on an integer outside the interval [0, x]\".\n    # This means for a fixed x, we can only reach points k in [0, x] such that there's a path from 0 to k,\n    # and all intermediate points on this path are also in [0, x].\n\n    # Let's consider the set of all reachable points from 0 without any upper bound.\n    # These are points of the form c1*a - c2*b where c1, c2 >= 0.\n    # All such points must be multiples of g = gcd(a, b).\n    # Let's define `dp[r]` as the minimum non-negative integer `k` such that `k % g == 0` and `k % a == r`, and `k` is reachable from 0.\n    # This is not correct. `k % a == r` is the state in Dijkstra.\n    # Let `dp[r]` be the minimum non-negative integer `k` such that `k % a == r` and `k` is reachable from 0.\n    # We are looking for `k` such that `k >= 0`.\n    # Initialize `dp` array of size `a` with infinity. `dp[0] = 0`.\n    # Use a deque for 0-1 BFS.\n    # `q = collections.deque([(0, 0)])` where (position, remainder_mod_a)\n    # No, this is `(min_k, remainder_mod_a)`.\n    # `q = collections.deque([(0, 0)])` where `(value, remainder)`\n    # `dp[r]` stores the minimum value `v` such that `v % a == r` and `v` is reachable.\n\n    dp = [float('inf')] * a\n    dp[0] = 0\n    q = collections.deque([(0, 0)]) # (min_val_k, k_mod_a)\n\n    while q:\n        curr_val, curr_rem = q.popleft()\n\n        if curr_val > dp[curr_rem]:\n            continue\n\n        # Option 1: Jump +a\n        # new_val = curr_val + a\n        # new_rem = curr_rem (since (curr_val + a) % a == curr_val % a)\n        # This jump doesn't change the remainder. It increases the value by 'a'.\n        # This is a bit tricky. If we are at 'curr_val', we can reach 'curr_val + a'.\n        # The 'dp' state should be minimum value.\n        # So, if we are at 'curr_val', we can reach 'curr_val + a'.\n        # (curr_val + a) % a == curr_rem.\n        # If dp[curr_rem] is curr_val, then we can reach curr_val.\n        # From curr_val, we can reach curr_val + a.\n        # This means we found another way to reach a point with remainder curr_rem.\n        # This is not a 0-1 BFS for costs. This is finding minimum values.\n\n        # Let's use a standard Dijkstra.\n        # `dist[r]` = minimum non-negative value `k` such that `k % a == r` and `k` is reachable.\n        dist = [float('inf')] * a\n        dist[0] = 0\n        pq = [(0, 0)] # (distance, remainder)\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            if d > dist[u]:\n                continue\n\n            # Jump +a\n            # From u, we can reach u + a. The remainder is still u.\n            # The value becomes d + a.\n            # If d + a < dist[u]: this should not happen, because we are always adding a positive 'a'.\n            # dist[u] is the minimum value for remainder u.\n            # So, if we are at `d` for `u`, we can reach `d+a` for `u`.\n            # This is not a state transition. This is just finding the minimum reachable for each remainder.\n\n            # The states are the remainders `r` modulo `a`.\n            # From `r`, we can jump to `(r-b)%a`. The \"cost\" of this jump is `b`.\n            # From `r`, we can jump to `(r+a)%a` which is `r`. The \"cost\" of this jump is `0`.\n            # We want to find the minimum `k` for each `r` such that `k % a == r` and `k` is reachable.\n            # `dist[r]` = minimum `k`.\n            # Initial: `dist[0] = 0`, others `inf`.\n            # When we extract `(d, u)` from PQ, it means `d` is the minimum `k` such that `k % a == u`.\n\n            # Transition 1: Jump `+a`.\n            # From `d` (current minimum for `u`), we can reach `d + a`.\n            # This `d + a` also has remainder `u`.\n            # If `d + a` is a smaller value than `dist[u]` (which is `d`), this is impossible.\n            # This is not how Dijkstra works for this problem.\n\n            # The correct Dijkstra formulation:\n            # `dp[r]` is the minimum non-negative value `k` such that `k % a == r` and `k` is reachable from 0.\n            # States are `r` in `[0, a-1]`.\n            # `dp[0] = 0`, all others `inf`.\n            # Priority queue `pq` stores `(value, remainder)`. Initially `pq = [(0, 0)]`.\n\n            # When we extract `(val, r)` from `pq`:\n            # If `val > dp[r]`, skip (already found a shorter path).\n            #\n            # 1. Consider jumping `+a`:\n            # We can reach `val + a`. This new point also has remainder `r`.\n            # If `val + a < dp[r]` (this should not happen, `dp[r]` is already `val`),\n            # then update `dp[r] = val + a` and push `(val + a, r)` to `pq`.\n            # This is effectively saying, if we can reach `val`, we can also reach `val+a, val+2a, ...`\n            # The minimum for remainder `r` is `val`. So we don't need to consider `val+a` as a new minimum for `r`.\n            # But these `val+ka` points are reachable.\n            # The `dp[r]` value is the *smallest* reachable point for that remainder.\n            # So `dp[r]` is `val`. All `val + k*a` are also reachable.\n            #\n            # 2. Consider jumping `-b`:\n            # We can reach `val - b`.\n            # This new point has remainder `(val - b) % a`. Let this be `new_r`.\n            # If `val - b >= 0`:\n            #   If `val - b < dp[new_r]`:\n            #     `dp[new_r] = val - b`\n            #     Push `(val - b, new_r)` to `pq`.\n            #\n            # This is the correct Dijkstra. `dp[r]` will store the minimum non-negative reachable value `k` for each `r`.\n            # Once `dp` array is filled, `dp[r]` contains the minimum reachable `k` for `k % a == r`.\n            # All other reachable points for that remainder `r` are `dp[r] + c*a` for `c >= 0`.\n\n            # Import heapq for Dijkstra\n            import heapq\n\n            dp = [float('inf')] * a\n            dp[0] = 0\n            pq = [(0, 0)] # (min_reachable_value, remainder_mod_a)\n\n            while pq:\n                val, r = heapq.heappop(pq)\n\n                if val > dp[r]:\n                    continue\n\n                # Jump -b\n                next_val = val - b\n                next_r = (r - b) % a # This is (val - b) % a\n\n                if next_val >= 0: # Ensure we don't go below 0\n                    if next_val < dp[next_r]:\n                        dp[next_r] = next_val\n                        heapq.heappush(pq, (next_val, next_r))\n                # Note: We don't need to consider jump +a explicitly here.\n                # If we are at `val` with remainder `r`, we can reach `val + k*a` for any `k >= 0`.\n                # These `val + k*a` also have remainder `r`.\n                # The minimum for `r` is `val`.\n                # The `dp` values represent the \"base\" reachable points for each remainder.\n\n    # After Dijkstra, `dp[r]` stores the minimum non-negative reachable point `k` such that `k % a == r`.\n    # All reachable points are of the form `dp[r] + c*a` for some `c >= 0`.\n    # And `dp[r]` itself must be reachable.\n    # Also, `dp[r]` must be a multiple of `g = gcd(a, b)`.\n    # If `dp[r]` is infinity, then no point with remainder `r` is reachable.\n\n    # Now, let's calculate `f(x)` for a given `x`.\n    # `f(x)` is the number of distinct integers `k` such that `0 <= k <= x`, `k` is reachable,\n    # AND there is a path from `0` to `k` where all intermediate points are in `[0, x]`.\n\n    # The condition \"never jumps on an integer outside the interval [0, x]\" is critical.\n    # If we only consider jumps `+a` and `-b` that keep us in `[0, x]`, then this is a simple BFS.\n    # But the problem wording \"an integer is counted if the frog can somehow reach it\" suggests\n    # that the path can temporarily go outside `[0, x]` but eventually lands on `k` in `[0, x]`.\n    # No, \"if it never jumps on an integer outside the interval [0, x]\". This is a strict constraint.\n    # So for a given `x`, we find all reachable points `k` in `[0, x]` using only jumps that keep us in `[0, x]`.\n\n    # Let's re-read carefully: \"if it never jumps on an integer outside the interval [0, x]\".\n    # This means, for a specific `x`, we can only make jumps `k -> k+a` if `k+a <= x`, and `k -> k-b` if `k-b >= 0`.\n    # This is a standard BFS for each `x`. But `x` goes up to `10^9`, so we can't do BFS for each `x`.\n\n    # Let `S_x` be the set of reachable points for a given `x`.\n    # `f(x) = |S_x|`.\n    # `S_x` is the set of points `k` in `[0, x]` reachable from `0` using only valid jumps.\n    # `reachable_points[i]` is a boolean indicating if `i` is reachable from `0` using only jumps in `[0, x]`.\n    # For a fixed `x`, we can run a BFS.\n    # `q = collections.deque([0])`\n    # `visited = {0}`\n    # While `q`:\n    #   `curr = q.popleft()`\n    #   `next_a = curr + a`\n    #   If `next_a <= x` and `next_a` not in `visited`:\n    #     `visited.add(next_a)`\n    #     `q.append(next_a)`\n    #   `next_b = curr - b`\n    #   If `next_b >= 0` and `next_b` not in `visited`:\n    #     `visited.add(next_b)`\n    #     `q.append(next_b)`\n    # `f(x) = len(visited)`.\n\n    # The maximum value `x` for which `f(x)` might change is `max(a, b)`.\n    # If `x` is large enough, the set of reachable points will stabilize.\n    # The set of reachable points from 0 (without upper bound) is `R = {c1*a - c2*b | c1, c2 >= 0}`.\n    # All points in `R` are multiples of `g = gcd(a, b)`.\n    # The smallest positive integer in `R` is `g`.\n    # All multiples of `g` from some point onwards are reachable.\n    # Specifically, all `k*g` for `k >= K` are reachable for some `K`.\n    # The Frobenius coin problem states that for coprime `a, b`, the largest number not representable as `c1*a + c2*b` is `ab - a - b`.\n    # Here, we have `c1*a - c2*b`. This is different.\n    # With `+a` and `-b`, we can reach any `k*g` as long as we don't go below 0.\n\n    # Let's consider the points `k` such that `k % a == r`.\n    # `dp[r]` is the minimum non-negative `k` such that `k % a == r` and `k` is reachable from 0.\n    # The Dijkstra computes this correctly.\n    # The maximum value `dp[r]` can take is `a * b / g - a - b` (Frobenius number for `a/g, b/g` multiplied by `g`).\n    # No, it's `a * b / g - (a/g) - (b/g)` multiplied by `g`.\n    # It is `(a/g - 1)(b/g - 1) * g - (a/g) * g`... this is wrong.\n    # The maximum `dp[r]` can be around `a * b / g`.\n    # The max value of `dp[r]` is `a * (b/g - 1)`. If `a` is very large, `b` is small.\n    # Max `dp[r]` is roughly `a * (b/g)`.\n    # If `a=10^5, b=10^5`, `g=1`, max `dp[r]` is `10^5 * 10^5 = 10^{10}`. This is too large.\n    # The `dp` values are modulo `a`. So `dp[r]` is at most `a-1 + (b-1)*a`.\n    # No, `dp[r]` is the minimum value `k`.\n    # `dp[r]` is at most `a * (b/g - 1)`.\n    # `dp[r]` is the smallest non-negative integer `x` such that `x % a == r` and `x` is reachable.\n    # The maximum possible value for `dp[r]` is `a * (b/g - 1) - (a-r)`? No.\n    # The maximum `dp[r]` is bounded by `a * b`. More precisely, `a * (b/g - 1)`.\n    # This is roughly `10^5 * 10^5 = 10^{10}`. This is too large for an array.\n    # Wait, the `dp` array is of size `a`. `a` is up to `10^5`.\n    # The values `dp[r]` can be large.\n\n    # Example: a=5, b=3. g=1.\n    # dp = [inf, inf, inf, inf, inf]\n    # dp[0] = 0. pq = [(0,0)]\n    # Pop (0,0).\n    #   next_val = 0-3 = -3. Not >=0.\n    # Pop from PQ.\n    # This is incorrect. The Dijkstra finds the minimum `k` for `k % a == r`.\n    # From `(val, r)`, we can reach `val + a` (same `r`) and `val - b` (new `r`).\n    # The `+a` jump should be handled as an edge of weight `a` to `(r, r)`.\n    # The `-b` jump should be handled as an edge of weight `b` to `((r-b)%a, r)`.\n    # This is `dist[r]` = min cost to reach `r`.\n    # This is `dist[r]` = minimum value `k` such that `k % a == r`.\n    # `dist[r]` is the state.\n    # `dist[0] = 0`.\n    # `pq = [(0,0)]`\n    # Pop `(0,0)`. `d=0, u=0`.\n    #   Neighbor `(u+a)%a = 0`. New value `d+a = a`. If `a < dist[0]` (impossible, `dist[0]` is `0`), update.\n    #   Neighbor `(u-b)%a = (0-3)%5 = 2`. New value `d-b = -3`. Not >=0.\n    # This Dijkstra computes `dp[r]` = minimum non-negative `k` such that `k % a == r` and `k` is reachable from 0.\n    # This is correct. The maximum `dp[r]` is bounded by `a * (b/g - 1)`.\n    # For `a=10^5, b=10^5, g=10^5`, `a=1, b=1`. `dp[0]=0`.\n    # For `a=10^5, b=1`, `g=1`. `dp[r]` could be `10^5 * (1-1) = 0`.\n    # For `a=10^5, b=10^5-1`, `g=1`. `dp[r]` could be `10^5 * (10^5-1-1)`. This is too large.\n    # The maximum value `dp[r]` can take is `a * (b/g - 1)`.\n    # `a, b <= 10^5`. `g >= 1`.\n    # Max `dp[r]` is roughly `a * b`.\n    # This value can be `10^5 * 10^5 = 10^{10}`. This is too large to store in an array `dp` of size `a`.\n    # `dp[r]` stores the minimum value `k`. `k` can be `10^{10}`.\n    # This is fine. `dp` array stores `long long`.\n\n    # Let's verify the maximum value of `dp[r]`.\n    # `dp[r]` is the smallest non-negative integer `k` such that `k \\equiv r \\pmod a` and `k` is reachable.\n    # `k = c_1 a - c_2 b`.\n    # We are looking for the smallest `k \\ge 0`.\n    # The maximum such `k` is bounded by `a * b / g`.\n    # Example: a=5, b=3. g=1.\n    # dp = [0, inf, inf, inf, inf]\n    # pq = [(0,0)]\n    # Pop (0,0). val=0, r=0.\n    #   next_val = 0-3 = -3. Not >=0.\n    # pq empty.\n    # This is wrong. My Dijkstra implementation logic is flawed.\n\n    # The Dijkstra should be:\n    # `dp[r]` = minimum non-negative value `k` such that `k % a == r` and `k` is reachable from 0.\n    # `dp[0] = 0`.\n    # `pq = [(0, 0)]`\n    # When we extract `(val, r)` from `pq`:\n    #   If `val > dp[r]`, continue.\n    #   From `val`, we can reach `val + a`. This has remainder `r`.\n    #   This `val + a` is a candidate for `dp[r]`. But `dp[r]` is already `val`.\n    #   This is not a graph where edges are `+a` and `-b`.\n    #   The states are `0, 1, ..., max_reachable`. This is a BFS on actual numbers.\n    #   The states are `0, 1, ..., a-1`.\n\n    # Let's use the standard Dijkstra formulation on remainders.\n    # `dist[r]` = minimum non-negative value `k` such that `k % a == r` and `k` is reachable from 0.\n    # `dist[0] = 0`, others `inf`.\n    # `pq = [(0, 0)]` (cost, remainder)\n    # When we extract `(d, u)` from `pq`:\n    #   If `d > dist[u]`, continue.\n    #   Consider edge to `(u + a) % a == u`. This transition is `k -> k+a`.\n    #     The cost for `u` is `d`. We can transition to `d+a`.\n    #     If `d+a < dist[u]` (impossible, `d` is already `dist[u]`), update.\n    #   Consider edge to `(u - b) % a`. This transition is `k -> k-b`.\n    #     The cost for `u` is `d`. We can transition to `d-b`.\n    #     Let `v = (u - b) % a`.\n    #     If `d-b >= 0` and `d-b < dist[v]`:\n    #       `dist[v] = d-b`\n    #       `heapq.heappush(pq, (d-b, v))`\n    # This is the correct Dijkstra for finding the minimum non-negative `k` for each remainder `r`.\n    # The values `dp[r]` can be large. Max `a * (b/g - 1)`.\n    # If `a=10^5, b=10^5, g=1`, then `dp[r]` could be `10^5 * (10^5-1)`. This is `10^{10}`.\n    # This is fine. Python integers handle large numbers.\n\n    # After Dijkstra, we have `dp[r]` for all `r` in `[0, a-1]`.\n    # `dp[r]` is the minimum non-negative reachable value `k` such that `k % a == r`.\n    # All reachable values `k'` with `k' % a == r` are of the form `dp[r] + c*a` for `c >= 0`.\n    # Also, `dp[r]` must be a multiple of `g = gcd(a, b)`. If not, it means it's unreachable.\n    # The Dijkstra ensures `dp[r]` is reachable.\n    # The `dp[r]` values are the \"base\" points.\n    # Let `max_dp_val = max(dp[r])` over all `r` where `dp[r]` is finite.\n    # If `m` is very small, say `m < min(a, b)`, then `f(i)` might be `1` for all `i`.\n    # For `m=100, a=100000, b=1`.\n    # `dp[0]=0`.\n    # `dp[r]` for `r != 0` will be reachable by `0-1, 0-2, ...`\n    # `dp[r]` will be `100000 - r` for `r \\ne 0`.\n    # `dp[99999] = 1`. `dp[99998] = 2`.\n    # `dp[r]` values are small if `b=1`.\n\n    # Let `max_relevant_x = max(dp[r]) + a`.\n    # If `x >= max_relevant_x`, then `f(x)` will stabilize.\n    # The maximum `dp[r]` can be `a * (b/g - 1)`. This is roughly `10^{10}`.\n    # So `max_relevant_x` can be very large.\n    # This implies we cannot iterate up to `max_relevant_x`.\n    # The value `m` is `10^9`. So we need to handle `m` efficiently.\n\n    # We need to compute `f(i)` for `i` from `0` to `m`.\n    # `f(i)` = number of reachable points `k` in `[0, i]` such that all intermediate points are in `[0, i]`.\n    # Let `g = gcd(a, b)`.\n    # All reachable points are multiples of `g`.\n    # The actual set of reachable points is `S = { k | k = c1*a - c2*b, c1, c2 >= 0 }`.\n    # The Dijkstra computes `dp[r]` = min `k` in `S` such that `k % a == r`.\n    # All points `k'` in `S` with `k' % a == r` are `dp[r] + c*a` for `c >= 0`.\n    # Let `max_dp_val = max(dp[r])` over all `r` for which `dp[r]` is finite.\n    # Let `max_dp_val = 0` if all `dp[r]` are infinite except `dp[0]=0`.\n    # If `x` is large enough, say `x >= max_dp_val + a`, then all points `dp[r] + c*a` such that `dp[r] + c*a <= x` are reachable.\n    # And the constraint \"never jumps outside [0, x]\" becomes less restrictive.\n    # If `x` is sufficiently large, say `x >= max_val_ever_reached_by_any_path_to_any_dp_r_point`.\n    # This is the tricky part.\n\n    # The actual constraint: \"never jumps on an integer outside the interval [0, x]\".\n    # This means, for a given `x`, we can only use points in `[0, x]`.\n    # This is a BFS on `[0, x]`.\n    # The number of reachable points `f(x)` is non-decreasing with `x`.\n    # `f(x)` changes value only when `x` crosses a reachable point.\n    # Or `x` crosses `k+a` or `k-b` for some reachable `k`.\n\n    # Let `R_x` be the set of reachable points in `[0, x]` under the interval constraint.\n    # `f(x) = |R_x|`.\n    # The points `k` that can be reached are `k \\in [0, x]`.\n    # For each `k \\in R_x`, `k+a` is reachable if `k+a \\in [0, x]`.\n    # For each `k \\in R_x`, `k-b` is reachable if `k-b \\in [0, x]`.\n\n    # Consider `x_0 = max(dp[r])` (the largest `dp[r]` that is finite).\n    # If `x >= x_0`, then all `dp[r]` values are available.\n    # For `k \\ge x_0`, if `k` is reachable, then `k+a` and `k-b` (if `k-b \\ge 0`) are reachable.\n    # This is because `k` is large enough that `k-b` is likely to be positive, and `k+a` is likely to be in range.\n    # If `k` is reachable (i.e., `k = dp[r] + c*a`), and `k >= x_0`, then `k-b` is also reachable.\n    # This is because `k-b = dp[r'] + c'*a` for some `r'` and `c'`.\n    # The `dp` values are the \"minimal\" reachable points.\n    # Any `k \\ge max(dp[r])` that is a multiple of `g` is reachable.\n    # This is because `gcd(a, b) = g`. `a/g` and `b/g` are coprime.\n    # All multiples of `g` larger than `g * (a/g * b/g - a/g - b/g)` are reachable.\n    # This is `g * ( (a/g-1)(b/g-1) - 1 )`.\n    # So all `k \\ge K_0` (for some `K_0`) that are multiples of `g` are reachable.\n    # Let `K_0 = max_dp_val`.\n    # For `x \\ge K_0`, `f(x)` is simply the number of multiples of `g` in `[0, x]`.\n    # This is `floor(x/g) + 1`.\n    # This is true if `x` is large enough that the constraint \"never jumps outside [0, x]\" is always satisfied.\n    # What is \"large enough\"?\n    # The points `dp[r]` are the minimum non-negative values for each remainder `r` modulo `a`.\n    # Let `max_dp_val = max(dp[r])` over all `r` where `dp[r]` is finite.\n    # If `x >= max_dp_val + b`, then any jump `k-b` from `k` (where `k >= max_dp_val`) will result in `k-b >= 0`.\n    # Any jump `k+a` from `k` (where `k >= max_dp_val`) will result in `k+a > max_dp_val`.\n    # So, for `x >= max_dp_val + b`, the set of reachable points in `[0, x]` is simply all `k` such that `k \\in [0, x]`\n    # and `k` is reachable from `0` without any `x` constraint.\n    # These are all `k` in `[0, x]` that are multiples of `g = gcd(a, b)`.\n    # So for `x >= max_dp_val + b`, `f(x) = floor(x/g) + 1`.\n    # Let `X_0 = max_dp_val + b`.\n    # We need to calculate `sum_{i=0 to m} f(i)`.\n    # This sum is `sum_{i=0 to min(m, X_0-1)} f(i) + sum_{i=X_0 to m} f(i)`.\n    # The second sum is `sum_{i=X_0 to m} (floor(i/g) + 1)`. This can be calculated efficiently.\n\n    # Calculate `g = gcd(a, b)`\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    g = gcd(a, b)\n\n    # Dijkstra to find dp[r]\n    dp = [float('inf')] * a\n    dp[0] = 0\n    pq = [(0, 0)] # (min_reachable_value, remainder_mod_a)\n\n    while pq:\n        val, r = heapq.heappop(pq)\n\n        if val > dp[r]:\n            continue\n\n        # Jump -b\n        next_val_minus_b = val - b\n        next_r_minus_b = (r - b) % a\n\n        if next_val_minus_b >= 0:\n            if next_val_minus_b < dp[next_r_minus_b]:\n                dp[next_r_minus_b] = next_val_minus_b\n                heapq.heappush(pq, (next_val_minus_b, next_r_minus_b))\n        \n        # Jump +a (This needs to be handled carefully)\n        # From `val`, we can reach `val + a`. This `val + a` also has remainder `r`.\n        # This is not a state transition in the Dijkstra for `dp[r]`.\n        # `dp[r]` is the *minimum* value. So `val` is already `dp[r]`.\n        # We need to find the `dp[r]` values for all `r`.\n        # The set of reachable points is `union_{r=0 to a-1} { dp[r] + c*a | c >= 0 }`.\n        # The Dijkstra above is correct for finding `dp[r]`.\n\n    # Find max_dp_val\n    max_dp_val = 0\n    for val in dp:\n        if val != float('inf'):\n            max_dp_val = max(max_dp_val, val)\n\n    # X_0 is the threshold after which f(x) = floor(x/g) + 1\n    # This threshold is `max_dp_val + b`.\n    # Why `+b`? Because if `x >= max_dp_val + b`, then any `k` that is reachable and `k \\ge max_dp_val`\n    # will satisfy `k-b \\ge 0`. So the `k-b` jump is always valid (doesn't go below 0).\n    # And `k+a` jump is always valid (doesn't go above `x` if `x` is large enough).\n    # The critical point is that for `x >= max_dp_val + b`, all points `k` in `[0, x]` that are multiples of `g`\n    # and `k \\ge max_dp_val` are reachable.\n    # All `k` in `[0, max_dp_val]` that are multiples of `g` are also reachable.\n    # So for `x >= max_dp_val + b`, `f(x)` is simply `floor(x/g) + 1`.\n    \n    X0 = max_dp_val + b\n\n    total_sum = 0\n\n    # Part 1: i from 0 to min(m, X0 - 1)\n    # For these values, we need to compute f(i) using BFS.\n    # We can compute f(i) incrementally.\n    # `reachable_set` stores points reachable within `[0, i]`.\n    # `f_val` is `len(reachable_set)`.\n    \n    # We need to find `f(i)` for `i` up to `min(m, X0 - 1)`.\n    # `X0` can be up to `10^{10}`. `m` can be `10^9`.\n    # So `min(m, X0-1)` can be `10^9`. This is too large for BFS.\n\n    # This means the `X0` threshold must be smaller.\n    # The maximum value that `dp[r]` can take is `a * (b/g - 1)`.\n    # If `a=10^5, b=10^5, g=1`, then `dp[r]` is `10^5 * (10^5-1)`. This is `10^{10}`.\n    # This means `X0` can be `10^{10}`.\n    # If `m=10^9`, then `min(m, X0-1)` is `m`.\n    # So we must compute `f(i)` up to `m` using the `floor(i/g)+1` formula.\n    # This implies that the `X0` threshold is effectively `m`.\n    # This can only be true if `max_dp_val + b` is always less than or equal to `m` or `m` is small.\n    # Or, the problem has a trick.\n\n    # The maximum value of `a, b` is `10^5`.\n    # The maximum value of `m` is `10^9`.\n    # The maximum value of `max_dp_val` is `a * (b/g - 1)`.\n    # This is roughly `10^5 * 10^5 = 10^{10}`.\n    # So `X0` can be `10^{10}`.\n    # This means that `m` is usually smaller than `X0`.\n    # So we need to calculate `sum_{i=0 to m} f(i)` where `f(i)` is based on BFS up to `i`.\n    # We cannot do BFS for each `i`.\n\n    # Let's consider the set of reachable points for `x`.\n    # `S_x = { k | k \\in [0, x], k \\text{ reachable from } 0 \\text{ using jumps in } [0, x] }`.\n    # `f(x) = |S_x|`.\n    # `f(x)` is non-decreasing. `f(x) = f(x-1)` or `f(x) = f(x-1) + 1`.\n    # `f(x)` increases by 1 if `x` becomes reachable and `x` was not reachable for `x-1`.\n    # Or if `x` becomes reachable and `x` was already reachable but the path constraint for `x-1` was too strict.\n    # This is not how `f(x)` is defined. `f(x)` is the count of reachable points in `[0, x]`.\n    # So `f(x) = f(x-1)` if `x` is not reachable.\n    # `f(x) = f(x-1) + 1` if `x` is reachable.\n\n    # We need to find the actual `f(i)` values for `i` up to `min(m, max_dp_val + a)`.\n    # Let `K_limit = min(m, max_dp_val + a)`.\n    # Why `max_dp_val + a`? Because if `x >= max_dp_val + a`, then all `dp[r]` are within `[0, x]`.\n    # And `dp[r] + c*a` are also in `[0, x]`.\n    # This is still not `X0`. The `X0` is when the constraint \"never jumps outside [0, x]\" becomes irrelevant.\n    # This happens when `x` is large enough so that `k-b >= 0` for all `k` in `[0, x]` that are reachable.\n    # And `k+a <= x` for all `k` in `[0, x]` that are reachable.\n    # The `k-b >= 0` constraint is handled by `max_dp_val + b`.\n    # The `k+a <= x` constraint means `x` must be large enough.\n    # If `x >= max_dp_val + a`, then all `dp[r]` points are available.\n    # And all points `dp[r] + c*a` up to `x` are available.\n    # What if `x < X0`?\n    # We need to sum `f(i)` for `i` from `0` to `m`.\n    # The maximum value of `a` or `b` is `10^5`.\n    # The maximum value of `X0` is `max_dp_val + b`.\n    # `max_dp_val` can be `a * (b/g - 1)`. Max value `10^5 * (10^5 - 1)` is `10^{10}`.\n    # `m` is `10^9`.\n    # So, `m` is likely less than `X0`.\n    # This means we cannot use the `floor(i/g)+1` shortcut for the majority of `m`.\n\n    # Let's consider the number of distinct reachable points `k` such that `0 <= k <= i`.\n    # We can iterate `i` from `0` to `min(m, 2*a + 2*b)`.\n    # No, the problem implies a linear scan up to `m` is too slow.\n    # The maximum value for `max_dp_val` is `a * (b/g - 1)`.\n    # If `g=1`, `max_dp_val` is `a * (b-1)`. Max `10^5 * 10^5 = 10^{10}`.\n    # The number of states in the BFS for `f(i)` is `i`.\n    # We need to calculate `f(i)` for `i` up to `m`.\n    # `f(i)` is the count of reachable points in `[0, i]`.\n    # Let `max_bfs_limit = max(a, b) * 2`. Or `a + b`.\n    # The `dp` values can be up to `a * (b/g - 1)`.\n    # The maximum value for `max_dp_val` is `a * (b/g - 1)`.\n    # This can be `10^5 * 10^5 = 10^{10}`.\n    # `m` is `10^9`.\n    # So, `m` is almost always smaller than `max_dp_val + b`.\n    # This means the simple `floor(i/g)+1` formula is not applicable for `i` up to `m`.\n\n    # Let's check the example 1: m=7, a=5, b=3.\n    # g = gcd(5,3) = 1.\n    # dp array (size a=5):\n    # dp = [0, inf, inf, inf, inf]\n    # pq = [(0,0)]\n    # Pop (0,0). val=0, r=0.\n    #   next_val = 0-3 = -3. Not >=0.\n    #\n    # Wait, the Dijkstra for `dp[r]` is not just for `val-b`.\n    # It's for finding minimum `k` such that `k % a == r`.\n    # From `val`, we can jump to `val-b`.\n    # From `val`, we can jump to `val+a`.\n    # This is a graph where nodes are `0..a-1`.\n    # Edge `r -> (r-b)%a` has weight `b`.\n    # Edge `r -> (r+a)%a` (which is `r`) has weight `a`.\n    # `dist[r]` = minimum `k` such that `k % a == r`.\n    #\n    # Let's re-run Dijkstra for a=5, b=3:\n    # dist = [inf]*5\n    # dist[0] = 0\n    # pq = [(0,0)]\n    #\n    # Pop (0,0). d=0, u=0.\n    #   1. Jump -b: `v = (0-3)%5 = 2`. `new_d = 0+3 = 3`. (Cost is `+b` not `-b`)\n    #      `new_d = 0+b = 3`. If `3 < dist[2]`: `dist[2]=3`. Push `(3,2)`.\n    #      (This is finding shortest path in terms of value difference)\n    #   2. Jump +a: `v = (0+5)%5 = 0`. `new_d = 0+5 = 5`. If `5 < dist[0]` (impossible, `dist[0]=0`).\n    #\n    # This Dijkstra formulation is for finding minimum cost to reach remainder `r`.\n    # The cost is `k`.\n    # If we jump `+a`, `k` becomes `k+a`. If we jump `-b`, `k` becomes `k-b`.\n    # The `dp[r]` should be the minimum `k >= 0`.\n    #\n    # Correct Dijkstra for `dp[r]` (min `k >= 0` with `k % a == r`):\n    # `dp[r]` is the min value `k`.\n    # `dp = [inf]*a`, `dp[0]=0`. `pq = [(0,0)]`\n    # Pop `(val, r)` from `pq`.\n    #   If `val > dp[r]`, continue.\n    #   Consider `val + a`: `new_val = val + a`. `new_r = r`.\n    #     If `new_val < dp[new_r]`: `dp[new_r] = new_val`. Push `(new_val, new_r)`.\n    #   Consider `val - b`: `new_val = val - b`. `new_r = (r - b) % a`.\n    #     If `new_val >= 0` and `new_val < dp[new_r]`: `dp[new_r] = new_val`. Push `(new_val, new_r)`.\n    #\n    # Let's try this for a=5, b=3.\n    # dp = [0, inf, inf, inf, inf]\n    # pq = [(0,0)]\n    #\n    # 1. Pop (0,0). val=0, r=0.\n    #    +a: new_val=5, new_r=0. `5 < dp[0]` (false, `dp[0]=0`).\n    #    -b: new_val=-3. Not >=0.\n    #\n    # This Dijkstra is also not right. `dp[0]` should not be `0` if `a` is large.\n    # `dp[r]` is the *minimum non-negative* integer `k` such that `k % a == r` and `k` is reachable.\n    # Example a=5, b=3.\n    # Reachable points are multiples of gcd(5,3)=1.\n    # 0 is reachable.\n    # 5 is reachable (0+5).\n    # 3 is reachable (5-3).\n    # 2 is reachable (5-3).\n    # 8 is reachable (5+3).\n    # 1 is reachable (3-2 is not a jump, 5-2*3 = -1, 2*5-3*3 = 1).\n    # So all non-negative integers are reachable.\n    #\n    # The Dijkstra needs to find the smallest `k` for each `r`.\n    # `dp[r]` = min `k >= 0` such that `k \\equiv r \\pmod a` and `k` is reachable.\n    #\n    # Let's use the 0-1 BFS style on remainders.\n    # `dp[r]` = min `k` for remainder `r`.\n    # `dp = [inf]*a`, `dp[0]=0`. `q = collections.deque([(0,0)])` (val, rem)\n    #\n    # Pop `(0,0)`. `val=0, r=0`.\n    #   Jump `+a`: `next_val = 0+a = a`. `next_r = 0`.\n    #     If `a < dp[0]` (false, `dp[0]=0`).\n    #   Jump `-b`: `next_val = 0-b = -b`. Not `\\ge 0`.\n    #\n    # This is a graph where edges `u -> v` have weight `w`.\n    # `dist[u]` = shortest path from source to `u`.\n    # `source = 0`.\n    # Nodes are `0, 1, ..., a-1`.\n    # Edge `u -> (u-b)%a` has weight `b`. (From `k`, we go to `k-b`. Difference in value is `b`).\n    # Edge `u -> (u+a)%a` has weight `0`. (From `k`, we go to `k+a`. Difference in value is `0` mod `a`).\n    # `dist[r]` = minimum value `k` such that `k % a == r`.\n    #\n    # `dist = [inf]*a`, `dist[0] = 0`.\n    # `pq = [(0,0)]` (cost, remainder).\n    #\n    # Pop `(0,0)`. `d=0, u=0`.\n    #   1. Transition `u -> (u-b)%a`: `v = (0-b)%a`. Cost `b`.\n    #      `new_d = d + b`. (This is `0 + b`).\n    #      If `new_d < dist[v]`: `dist[v] = new_d`. Push `(new_d, v)`.\n    #      For a=5, b=3: `v = (0-3)%5 = 2`. `new_d = 0+3 = 3`.\n    #      `dist[2]=3`. Push `(3,2)`.\n    #   2. Transition `u -> (u+a)%a`: `v = (0+a)%a = 0`. Cost `0`.\n    #      `new_d = d + 0`.\n    #      If `new_d < dist[v]` (impossible, `new_d=d=dist[v]`).\n    #\n    # PQ: `[(3,2)]`\n    # Pop `(3,2)`. `d=3, u=2`.\n    #   1. Transition `u -> (u-b)%a`: `v = (2-3)%5 = 4`. Cost `b`.\n    #      `new_d = d + b = 3 + 3 = 6`.\n    #      If `6 < dist[4]`: `dist[4]=6`. Push `(6,4)`.\n    #   2. Transition `u -> (u+a)%a`: `v = (2+5)%5 = 2`. Cost `0`.\n    #      `new_d = d + 0 = 3`.\n    #      If `3 < dist[2]` (impossible).\n    #\n    # PQ: `[(6,4)]`\n    # Pop `(6,4)`. `d=6, u=4`.\n    #   1. Transition `u -> (u-b)%a`: `v = (4-3)%5 = 1`. Cost `b`.\n    #      `new_d = d + b = 6 + 3 = 9`.\n    #      If `9 < dist[1]`: `dist[1]=9`. Push `(9,1)`.\n    #   2. Transition `u -> (u+a)%a`: `v = (4+5)%5 = 4`. Cost `0`.\n    #      `new_d = d + 0 = 6`.\n    #      If `6 < dist[4]` (impossible).\n    #\n    # PQ: `[(9,1)]`\n    # Pop `(9,1)`. `d=9, u=1`.\n    #   1. Transition `u -> (u-b)%a`: `v = (1-3)%5 = 3`. Cost `b`.\n    #      `new_d = d + b = 9 + 3 = 12`.\n    #      If `12 < dist[3]`: `dist[3]=12`. Push `(12,3)`.\n    #   2. Transition `u -> (u+a)%a`: `v = (1+5)%5 = 1`. Cost `0`.\n    #      `new_d = d + 0 = 9`.\n    #      If `9 < dist[1]` (impossible).\n    #\n    # PQ: `[(12,3)]`\n    # Pop `(12,3)`. `d=12, u=3`.\n    #   1. Transition `u -> (u-b)%a`: `v = (3-3)%5 = 0`. Cost `b`.\n    #      `new_d = d + b = 12 + 3 = 15`.\n    #      If `15 < dist[0]` (false, `dist[0]=0`).\n    #   2. Transition `u -> (u+a)%a`: `v = (3+5)%5 = 3`. Cost `0`.\n    #      `new_d = d + 0 = 12`.\n    #      If `12 < dist[3]` (impossible).\n    #\n    # PQ empty.\n    # `dp` (renamed from `dist`) values:\n    # `dp[0]=0, dp[1]=9, dp[2]=3, dp[3]=12, dp[4]=6`.\n    # These are the minimum non-negative reachable points for each remainder mod `a`.\n    # All these are multiples of `g=1`.\n    # `max_dp_val = 12`.\n    # `X0 = max_dp_val + b = 12 + 3 = 15`.\n    #\n    # Now, calculate `sum_{i=0 to m} f(i)`. `m=7`.\n    # `min(m, X0-1) = min(7, 14) = 7`.\n    # So we need to calculate `f(i)` for `i=0..7` using BFS.\n    # This is `O(m * (m/g + (a+b)))` which is too slow.\n    # `m` up to `10^9`.\n\n    # The issue is that `f(x)` calculation is too slow for `x` up to `m`.\n    # The `X0` threshold must be much smaller.\n    # The definition of `f(x)`: \"if it never jumps on an integer outside the interval [0, x]\".\n    # This means for each `x`, we run a BFS *only* using jumps that stay in `[0, x]`.\n    # Let `dp[k]` be the minimum `x` such that `k` is reachable within `[0, x]`.\n    # This is not right.\n    # Let `max_path_val[k]` be the maximum value visited on *any* path from `0` to `k`.\n    # `min_path_val[k]` be the minimum value visited on *any* path from `0` to `k`.\n    # `k` is counted in `f(x)` if `k \\in [0, x]` and `max_path_val[k] <= x` and `min_path_val[k] >= 0`.\n    # But `min_path_val[k] >= 0` is always true if we start at 0 and only make valid jumps.\n    # So `k` is counted in `f(x)` if `k \\in [0, x]` and `max_path_val[k] <= x`.\n    #\n    # We need to find `max_path_val[k]` for all `k`.\n    # Let `max_reach[k]` be the minimum possible maximum value reached on a path from `0` to `k`.\n    # Initialize `max_reach[0] = 0`, others `inf`.\n    # Use Dijkstra. `pq = [(0, 0)]` (max_val_on_path, current_pos).\n    #\n    # `max_reach` array (size `max_m_or_max_dp_val_plus_a_plus_b`). Max `10^9`. Still too big.\n    # The number of distinct reachable points is `N_R`. `N_R` can be `m/g`.\n    # Max `N_R` can be `10^9`.\n\n    # The key insight for this type of problem is often that `f(x)` stabilizes or follows a linear pattern.\n    # The value `max_dp_val` (from the first Dijkstra) is the largest \"base\" point.\n    # Let `K = max_dp_val`.\n    # For `i > K`, if `i` is reachable, then `i = dp[r] + c*a` for some `c >= 0`.\n    # And `i` is a multiple of `g`.\n    # If `i >= K`, then `i-b` is also reachable (if `i-b >= 0`).\n    # And `i+a` is also reachable.\n    #\n    # Consider `f(i)` for `i` up to `min(m, 2*a + 2*b)`. This is `min(10^9, 4*10^5)`.\n    # Let `LIMIT = min(m, 2 * a + 2 * b)`.\n    # For `i` from `0` to `LIMIT`:\n    #   Run BFS for `f(i)`.\n    #   `q = collections.deque([0])`\n    #   `visited = {0}`\n    #   `while q:`\n    #     `curr = q.popleft()`\n    #     `next_a = curr + a`\n    #     `if next_a <= i and next_a not in visited:`\n    #       `visited.add(next_a)`\n    #       `q.append(next_a)`\n    #     `next_b = curr - b`\n    #     `if next_b >= 0 and next_b not in visited:`\n    #       `visited.add(next_b)`\n    #       `q.append(next_b)`\n    #   `f_values[i] = len(visited)`\n    # This is `O(LIMIT * (LIMIT/g + (a+b)))`.\n    # `LIMIT` can be `4*10^5`. `(4*10^5)^2` is `1.6 * 10^{11}`. Too slow.\n\n    # We need to compute `f(i)` for `i` from `0` to `m`.\n    # Let `max_bfs_limit = a + b`.\n    # For `i` up to `max_bfs_limit`, we can do a single BFS that expands.\n    # `reachable_points = set()`\n    # `q = collections.deque([0])`\n    # `visited_bfs = {0}`\n    # `current_f_val = 0`\n    # `f_prefix_sum = [0] * (max_bfs_limit + 1)`\n    #\n    # `f_arr = [0] * (max_bfs_limit + 1)`\n    # `max_reached_so_far = 0`\n    # `q = collections.deque([0])`\n    # `visited_set = {0}`\n    # `all_reachable_in_limit = []`\n    #\n    # while q:\n    #     curr = q.popleft()\n    #     all_reachable_in_limit.append(curr)\n    #\n    #     next_a = curr + a\n    #     if next_a <= max_bfs_limit and next_a not in visited_set:\n    #         visited_set.add(next_a)\n    #         q.append(next_a)\n    #\n    #     next_b = curr - b\n    #     if next_b >= 0 and next_b not in visited_set:\n    #         visited_set.add(next_b)\n    #         q.append(next_b)\n    #\n    # `all_reachable_in_limit` contains all points reachable without constraint up to `max_bfs_limit`.\n    # Sort `all_reachable_in_limit`.\n    # `f(i)` is the count of points in `all_reachable_in_limit` that are `<= i`.\n    # This is `bisect_right(all_reachable_in_limit, i)`.\n    # This is for the case where `x` is large enough that the interval constraint is not tight.\n    # But `f(x)` is defined by \"never jumps on an integer outside the interval [0, x]\".\n    # This means the BFS for `f(x)` should be limited to `[0, x]`.\n\n    # Let `dp_val[k]` be the minimum `x` such that `k` is reachable within `[0, x]`.\n    # This `dp_val[k]` is effectively `max_path_val[k]`.\n    # Initialize `dp_val` array of size `m+1` (too large) or `max_dp_val + a + b` (too large).\n    # `dp_val[k]` is the minimum maximum value encountered on a path from `0` to `k`.\n    # `dp_val = [inf] * (max_relevant_point + 1)`\n    # `dp_val[0] = 0`.\n    # `pq = [(0, 0)]` (max_val_on_path, current_pos)\n    #\n    # This Dijkstra will compute `dp_val[k]` for all `k` up to `max_dp_val + a`.\n    # The states are `k` from `0` to `max_dp_val + a`.\n    # Max value of `max_dp_val + a` is `10^{10}`. Still too large.\n\n    # The maximum value of `a, b` is `10^5`.\n    # The maximum number of distinct `dp[r]` values is `a`.\n    # The maximum `max_dp_val` is `a * (b/g - 1)`.\n    # The number of points that `f(i)` can change is limited.\n    # `f(i)` can only change if `i` itself becomes reachable, or if `i` is the new upper bound that allows\n    # a previously unreachable point to become reachable.\n    # The points that are \"hardest\" to reach (require high `x`) are the `dp[r]` values.\n    # Specifically, `dp[r]` is the minimum `k` that has `k % a == r`.\n    # The `max_dp_val` is the largest of these `dp[r]`.\n    # For `x >= max_dp_val`, all `dp[r]` are within `[0, x]`.\n    # For `x >= max_dp_val + b`, all `dp[r]` can be used to make `k-b` jumps without going below 0.\n    # For `x >= max_dp_val + a`, all `dp[r]` can be used to make `k+a` jumps without going above `x`.\n    #\n    # The range where `f(x)` is not `floor(x/g)+1` is roughly `[0, max_dp_val + max(a,b)]`.\n    # Let `K_max = max_dp_val + max(a,b)`. This can be `10^{10}`.\n    # This means `m` is almost always less than `K_max`.\n    # This implies that the special `f(x)` formula is not used for `m`.\n\n    # The only way this works is if the relevant `x` range for BFS is small.\n    # What if `a` and `b` are small? Say `a=5, b=3`. `max_dp_val=12`. `K_max = 12+5=17`.\n    # For `m=7`, we need `f(0)...f(7)`. All are within `K_max`.\n    # So we need to compute `f(i)` for `i` up to `min(m, K_max)`.\n    # `K_max` is roughly `a*b/g`. If `a,b` are `10^5`, `g=1`, `K_max` is `10^{10}`.\n    # If `g` is large, `K_max` is small. E.g., `a=10^5, b=10^5, g=10^5`. Then `K_max` is `10^5`.\n    # So the calculation of `f(i)` by BFS is limited by `max_x_to_compute = min(m, K_max)`.\n    # If `K_max` is small (e.g., `a*b/g` is small), then `max_x_to_compute` is small.\n    # `max_x_to_compute` is at most `m`.\n    # If `m` is `10^9`, `max_x_to_compute` is `10^9`. Still too large.\n\n    # This problem must be about the `dp[r]` values.\n    # The number of distinct integers reachable in `[0, x]` if it never jumps outside `[0, x]`.\n    # Let `reachable_in_range[k]` be true if `k` is reachable within `[0, i]` for some `i`.\n    # Let `f_vals[i]` be the count of reachable points in `[0, i]`.\n    # We can iterate `i` from `0` to `m`.\n    # Maintain a set of `reachable_for_current_i`.\n    # When `i` increments to `i+1`:\n    #   If `i+1` is reachable from some `k` in `reachable_for_current_i` by `k+a` or `k-b`,\n    #   and `k+a <= i+1` or `k-b >= 0`, then `i+1` is reachable.\n    # This is still `O(m * a)` or `O(m * log m)`. Too slow.\n\n    # The maximum relevant `x` for the BFS computation is `2*a + 2*b`.\n    # Let `max_bfs_range = 2 * (a + b)`.\n    # For `x > max_bfs_range`, `f(x)` will be `floor(x/g) + 1`.\n    # This is because beyond `2*(a+b)`, all `dp[r]` values are available.\n    # And the constraint `k+a <= x` and `k-b >= 0` is always satisfied for `k` within `[0, x]`.\n    # This seems like the standard approach.\n    # `max_bfs_range` is at most `4 * 10^5`.\n    # Let `limit_x = min(m, 2 * (a + b) + 5)`. Add a small buffer.\n    # For `i` from `0` to `limit_x`:\n    #   `f_arr[i]` stores `f(i)`.\n    #   `visited = set()`\n    #   `q = collections.deque([0])`\n    #   `visited.add(0)`\n    #   `while q:`\n    #     `curr = q.popleft()`\n    #     `next_a = curr + a`\n    #     `if next_a <= i and next_a not in visited:`\n    #       `visited.add(next_a)`\n    #       `q.append(next_a)`\n    #     `next_b = curr - b`\n    #     `if next_b >= 0 and next_b not in visited:`\n    #       `visited.add(next_b)`\n    #       `q.append(next_b)`\n    #   `f_arr[i] = len(visited)`\n    # This is `O(limit_x * (limit_x/g + a+b))`. Still `(4*10^5)^2`.\n\n    # Let's fix the `f(x)` calculation up to a certain `X_cutoff`.\n    # `X_cutoff = 2 * (a + b)` seems plausible.\n    # The number of points reachable by BFS up to `X_cutoff` is `X_cutoff/g`.\n    # A single BFS up to `X_cutoff` to find all `k` that are reachable.\n    # `q = collections.deque([0])`\n    # `reachable_set = {0}`\n    # `max_k_reached = 0`\n    # `all_reachable_points = []` (stores (k, max_path_val[k]))\n    #\n    # We need `max_path_val[k]`.\n    # `max_path_val[k]` is the minimum maximum value encountered on a path from 0 to k.\n    # `max_path_val = [inf] * (X_cutoff + 1)`\n    # `max_path_val[0] = 0`\n    # `pq = [(0, 0)]` (current_max_val_on_path, current_pos)\n    #\n    # while pq:\n    #     curr_max_val, curr_pos = heapq.heappop(pq)\n    #\n    #     if curr_max_val > max_path_val[curr_pos]:\n    #         continue\n    #\n    #     # Jump +a\n    #     next_pos_a = curr_pos + a\n    #     next_max_val_a = max(curr_max_val, next_pos_a)\n    #     if next_pos_a <= X_cutoff and next_max_val_a < max_path_val[next_pos_a]:\n    #         max_path_val[next_pos_a] = next_max_val_a\n    #         heapq.heappush(pq, (next_max_val_a, next_pos_a))\n    #\n    #     # Jump -b\n    #     next_pos_b = curr_pos - b\n    #     next_max_val_b = curr_max_val # min_path_val is 0, max_path_val doesn't change\n    #     if next_pos_b >= 0 and next_pos_b <= X_cutoff and next_max_val_b < max_path_val[next_pos_b]:\n    #         max_path_val[next_pos_b] = next_max_val_b\n    #         heapq.heappush(pq, (next_max_val_b, next_pos_b))\n    #\n    # This Dijkstra computes `max_path_val[k]` for `k` up to `X_cutoff`.\n    # `X_cutoff` is `4*10^5`. This Dijkstra is `O(X_cutoff * log(X_cutoff))`. This is feasible.\n    # `4*10^5 * log(4*10^5)` is `4*10^5 * 19` roughly `7.6 * 10^6`. This is fast enough.\n\n    # After this Dijkstra, we have `max_path_val[k]` for `k` in `[0, X_cutoff]`.\n    # `f(i)` is the count of `k` in `[0, i]` such that `max_path_val[k] <= i`.\n    # Create a list of `(max_path_val[k], k)` pairs for `k` where `max_path_val[k]` is finite.\n    # Sort this list by `max_path_val[k]`.\n    # `points_by_max_path_val = []`\n    # for `k` from `0` to `X_cutoff`:\n    #   if `max_path_val[k]` is finite:\n    #     `points_by_max_path_val.append((max_path_val[k], k))`\n    # `points_by_max_path_val.sort()`\n\n    # `f_arr = [0] * (X_cutoff + 1)`\n    # `count = 0`\n    # `current_points_set = set()`\n    # `ptr = 0`\n    # for `i` from `0` to `X_cutoff`:\n    #   while `ptr < len(points_by_max_path_val)` and `points_by_max_path_val[ptr][0] <= i`:\n    #     `current_points_set.add(points_by_max_path_val[ptr][1])`\n    #     `ptr += 1`\n    #   `f_arr[i] = len({k for k in current_points_set if k <= i})`\n    # This step is `O(X_cutoff * log(X_cutoff))` or `O(X_cutoff * X_cutoff)` if set intersection is slow.\n    # The set intersection is slow.\n    # We need `len({k | k \\in current_points_set, k <= i})`.\n    # `current_points_set` grows.\n    # We can maintain a Fenwick tree or segment tree for `k` values.\n    # Or, simpler:\n    # `f_arr = [0] * (X_cutoff + 1)`\n    # `active_points_at_i = [[] for _ in range(X_cutoff + 1)]`\n    # for `k` from `0` to `X_cutoff`:\n    #   if `max_path_val[k]` is finite:\n    #     `active_points_at_i[max_path_val[k]].append(k)`\n    #\n    # `current_reachable_points_count = 0`\n    # `is_reachable_within_i = [False] * (X_cutoff + 1)`\n    # for `i` from `0` to `X_cutoff`:\n    #   # Add points that become fully reachable at this `i`\n    #   for `k_val` in `active_points_at_i[i]`:\n    #     if `not is_reachable_within_i[k_val]`:\n    #       `is_reachable_within_i[k_val] = True`\n    #   # Count points `k_val <= i` that are `is_reachable_within_i[k_val]`\n    #   `count_for_i = 0`\n    #   for `k_val` in `range(i + 1)`:\n    #     if `is_reachable_within_i[k_val]`:\n    #       `count_for_i += 1`\n    #   `f_arr[i] = count_for_i`\n    # This is `O(X_cutoff^2)`. Still too slow.\n\n    # Instead of `is_reachable_within_i`, we can use a Fenwick tree (BIT).\n    # `BIT` stores counts of `k`.\n    # `BIT = FenwickTree(X_cutoff + 1)`\n    # `f_arr = [0] * (X_cutoff + 1)`\n    # `active_points_at_i = [[] for _ in range(X_cutoff + 1)]` (as before)\n    #\n    # for `k` from `0` to `X_cutoff`:\n    #   if `max_path_val[k]` is finite:\n    #     `active_points_at_i[max_path_val[k]].append(k)`\n    #\n    # for `i` from `0` to `X_cutoff`:\n    #   for `k_val` in `active_points_at_i[i]`:\n    #     `BIT.update(k_val, 1)` (add `k_val` to set of points that are reachable within `[0, i]`)\n    #   `f_arr[i] = BIT.query(i)` (count of reachable points `k <= i`)\n    # This is `O(X_cutoff * log(X_cutoff))`. This is feasible.\n\n    # Final sum calculation:\n    # `total_sum = 0`\n    # `limit_X = min(m, X_cutoff)`\n    # for `i` from `0` to `limit_X`:\n    #   `total_sum += f_arr[i]`\n    #\n    # If `m > X_cutoff`:\n    #   For `i` from `X_cutoff + 1` to `m`:\n    #     `f(i) = floor(i/g) + 1`\n    #     `total_sum += (floor(i/g) + 1)`\n    # This sum `sum_{i=X_cutoff+1 to m} (floor(i/g) + 1)` can be calculated using number theory.\n    # `sum_{i=A to B} (floor(i/g) + 1) = sum_{i=A to B} floor(i/g) + (B-A+1)`.\n    # `sum_{i=A to B} floor(i/g)` can be computed efficiently.\n    # It's `g * sum_{j=floor(A/g) to floor(B/g)} j * (count of i s.t. floor(i/g)=j)`.\n    # This is arithmetic progression sum.\n    # `sum_{i=A to B} floor(i/g)` is `(sum_{i=1 to B} floor(i/g)) - (sum_{i=1 to A-1} floor(i/g))`.\n    # `sum_{i=1 to N} floor(i/g)` is `N * floor(N/g) - g * floor(N/g) * (floor(N/g) + 1) / 2 + floor(N/g) * (floor(N/g) + 1) / 2`.\n    # No, it's `sum_{k=1}^{floor(N/g)} k*g + sum_{i=floor(N/g)*g+1}^N floor(i/g)`.\n    # The sum `sum_{i=1 to N} floor(i/g)` can be computed in `O(sqrt(N))` or `O(log N)` using properties of floor.\n    # A simple way: `sum_{i=1 to N} floor(i/g) = sum_{j=1}^{floor(N/g)} j * g + sum_{j=1}^{floor(N/g)} (g-1) * j`\n    # No, `sum_{i=1 to N} floor(i/g) = sum_{k=1}^{N} sum_{j=1}^{k} [j*g <= k]`.\n    # It is `sum_{k=1}^{N} floor(k/g)`.\n    # `floor(k/g)` takes `g` distinct values for `k=1..g`, `k=g+1..2g`, etc.\n    # This is `sum_{q=0}^{floor(N/g)-1} q*g + sum_{i=floor(N/g)*g+1}^{N} floor(i/g)`.\n    # `sum_{i=1 to N} floor(i/g) = (N/g)*(N/g+1)/2 * g`\n    # `sum_{i=1 to N} floor(i/g)` is `floor(N/g) * (N+1) - g * floor(N/g) * (floor(N/g)+1)/2`.\n    # This is `N * floor(N/g) - g * floor(N/g) * (floor(N/g)-1)/2`.\n    # The formula is `N * floor(N/g) - g * floor(N/g) * (floor(N/g) + 1) / 2 + (N - g * floor(N/g)) * floor(N/g)`.\n    # `sum_{i=1}^N \\lfloor i/k \\rfloor = \\sum_{j=1}^{\\lfloor N/k \\rfloor} j \\cdot k + \\lfloor N/k \\rfloor \\cdot (N \\pmod k + 1)`\n    # No, this is `sum_{i=1}^N \\lfloor i/k \\rfloor = \\sum_{j=1}^{\\lfloor N/k \\rfloor} j \\cdot k + \\lfloor N/k \\rfloor \\cdot (N - k \\lfloor N/k \\rfloor + 1)`.\n    # It is `sum_{i=1 to N} (i//g)`.\n    # Let `N_g = N // g`.\n    # `sum_{i=1 to N} (i//g) = sum_{j=0}^{N_g-1} j*g + sum_{i=N_g*g+1}^{N} N_g`.\n    # `sum_{i=1 to N} (i//g) = g * (N_g-1)*N_g/2 + N_g * (N - N_g*g)`.\n    # This is wrong.\n    # The sum `sum_{i=1}^N \\lfloor i/g \\rfloor` is `N_g * (N_g - 1) * g // 2 + N_g * (N - N_g * g + 1)`.\n    # No, this is wrong.\n    # The correct formula for `S(N, k) = sum_{i=1 to N} floor(i/k)` is:\n    # `S(N, k) = floor(N/k) * (N + 1) - k * floor(N/k) * (floor(N/k) + 1) / 2`.\n    # Let `q = N // k`.\n    # `S(N, k) = q * (N + 1) - k * q * (q + 1) // 2`.\n    # This is `O(1)`.\n    # So `sum_{i=X_cutoff+1 to m} (floor(i/g) + 1)` can be computed as:\n    # `(sum_{i=1 to m} (floor(i/g) + 1)) - (sum_{i=1 to X_cutoff} (floor(i/g) + 1))`.\n    # `sum_{i=1 to N} (floor(i/g) + 1) = S(N, g) + N`.\n\n    # Overall algorithm:\n    # 1. Compute `g = gcd(a, b)`.\n    # 2. Define `X_cutoff = 2 * (a + b) + 5`. (Or a similar small constant like `a+b+g` or `max(a,b)*2`)\n    #    The maximum value of `a, b` is `10^5`, so `X_cutoff` is around `4 * 10^5`.\n    # 3. Compute `max_path_val[k]` for `k` from `0` to `X_cutoff` using Dijkstra.\n    #    `max_path_val[k]` is the minimum maximum value encountered on a path from `0` to `k`.\n    #    This is `O(X_cutoff * log(X_cutoff))`.\n    # 4. Compute `f_arr[i]` for `i` from `0` to `X_cutoff` using a Fenwick tree.\n    #    `f_arr[i]` is the count of `k` in `[0, i]` such that `max_path_val[k] <= i`.\n    #    This is `O(X_cutoff * log(X_cutoff))`.\n    # 5. Calculate `total_sum_part1 = sum_{i=0 to min(m, X_cutoff)} f_arr[i]`.\n    #    This is `O(X_cutoff)`.\n    # 6. If `m > X_cutoff`:\n    #    Calculate `total_sum_part2 = sum_{i=X_cutoff+1 to m} (floor(i/g) + 1)`.\n    #    This is `O(1)` using the sum formula.\n    # 7. Add `total_sum_part1` and `total_sum_part2`.\n\n    # Fenwick Tree (BIT) implementation\n    class FenwickTree:\n        def __init__(self, size):\n            self.tree = [0] * (size + 1)\n            self.size = size\n\n        def update(self, idx, delta):\n            idx += 1 # 1-based indexing\n            while idx <= self.size:\n                self.tree[idx] += delta\n                idx += idx & (-idx)\n\n        def query(self, idx):\n            idx += 1 # 1-based indexing\n            s = 0\n            while idx > 0:\n                s += self.tree[idx]\n                idx -= idx & (-idx)\n            return s\n\n    # Function to calculate sum_{i=1 to N} (floor(i/g) + 1)\n    def sum_floor_plus_one(N, g):\n        if N < 0: return 0\n        \n        # sum_{i=1 to N} floor(i/g)\n        q = N // g\n        sum_floor_i_div_g = q * (N + 1) - g * q * (q + 1) // 2\n        \n        # sum_{i=1 to N} 1\n        sum_ones = N\n        \n        return sum_floor_i_div_g + sum_ones\n\n    g = gcd(a, b)\n\n    # Determine X_cutoff\n    # A safe bound for X_cutoff: a value beyond which all reachable points k are \"stable\".\n    # This means max_path_val[k] <= k.\n    # A common bound for reachability problems with +a, -b is related to a*b/g or 2*max(a,b).\n    # Let's use `2 * (a + b)` as a heuristic.\n    # For a=1, b=2019, m=10^9. X_cutoff = 2*(1+2019) = 4040.\n    # This is small enough.\n    X_cutoff = 2 * (a + b) + 5 # Add a small buffer\n\n    # Dijkstra to compute max_path_val[k]\n    # max_path_val[k] = minimum max value on a path from 0 to k\n    max_path_val = [float('inf')] * (X_cutoff + 1)\n    max_path_val[0] = 0\n    pq = [(0, 0)] # (current_max_val_on_path, current_pos)\n\n    while pq:\n        curr_max_val, curr_pos = heapq.heappop(pq)\n\n        if curr_max_val > max_path_val[curr_pos]:\n            continue\n\n        # Jump +a\n        next_pos_a = curr_pos + a\n        next_max_val_a = max(curr_max_val, next_pos_a)\n        if next_pos_a <= X_cutoff and next_max_val_a < max_path_val[next_pos_a]:\n            max_path_val[next_pos_a] = next_max_val_a\n            heapq.heappush(pq, (next_max_val_a, next_pos_a))\n\n        # Jump -b\n        next_pos_b = curr_pos - b\n        # next_max_val_b is curr_max_val, because we are reducing position,\n        # so the maximum value on path won't increase.\n        # min_path_val is always >= 0.\n        if next_pos_b >= 0 and next_pos_b <= X_cutoff and curr_max_val < max_path_val[next_pos_b]:\n            max_path_val[next_pos_b] = curr_max_val\n            heapq.heappush(pq, (curr_max_val, next_pos_b))\n\n    # Compute f_arr[i] using Fenwick Tree\n    f_arr = [0] * (X_cutoff + 1)\n    # active_points_at_i[x] stores k such that max_path_val[k] == x\n    active_points_at_i = [[] for _ in range(X_cutoff + 1)]\n\n    for k in range(X_cutoff + 1):\n        if max_path_val[k] != float('inf'):\n            # Ensure k is a multiple of g\n            if k % g == 0:\n                # Add k to the list for its max_path_val\n                # max_path_val[k] can be greater than X_cutoff if k is large.\n                # But we only care about max_path_val[k] <= X_cutoff for f_arr.\n                # If max_path_val[k] > X_cutoff, then k will never be counted for i <= X_cutoff.\n                if max_path_val[k] <= X_cutoff:\n                    active_points_at_i[max_path_val[k]].append(k)\n                else:\n                    # If max_path_val[k] > X_cutoff, it means k can only be reached\n                    # if the interval constraint [0, i] is wider than X_cutoff.\n                    # This means for i <= X_cutoff, k is not counted.\n                    pass\n            \n    bit = FenwickTree(X_cutoff + 1)\n    \n    for i in range(X_cutoff + 1):\n        for k_val in active_points_at_i[i]:\n            bit.update(k_val, 1)\n        f_arr[i] = bit.query(i)\n\n    total_sum = 0\n    \n    # Part 1: i from 0 to min(m, X_cutoff)\n    limit_m_X_cutoff = min(m, X_cutoff)\n    for i in range(limit_m_X_cutoff + 1):\n        total_sum += f_arr[i]\n\n    # Part 2: i from X_cutoff + 1 to m\n    if m > X_cutoff:\n        # Sum floor(i/g) + 1 for i from X_cutoff + 1 to m\n        # = (sum_{i=1 to m} (floor(i/g) + 1)) - (sum_{i=1 to X_cutoff} (floor(i/g) + 1))\n        sum_up_to_m = sum_floor_plus_one(m, g)\n        sum_up_to_X_cutoff = sum_floor_plus_one(X_cutoff, g)\n        \n        total_sum += (sum_up_to_m - sum_up_to_X_cutoff)\n\n    sys.stdout.write(str(total_sum) + '\\n')\n\nsolve()"}
{"task_id": "E2H_CF980E", "completion": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # We want to keep n-k nodes.\n    # The total number of fans is sum(2^i) for kept nodes.\n    # To maximize this sum, we want to keep nodes with larger indices.\n    # So, we should try to remove nodes with smaller indices.\n    # The problem states that the remaining nodes must form a connected component.\n\n    # We can use a greedy approach.\n    # Start with all nodes included.\n    # We need to remove k nodes.\n    # To maximize the sum, we should remove nodes with the smallest possible indices.\n    # However, removing a node might disconnect the graph.\n\n    # Consider removing nodes from largest index to smallest.\n    # This doesn't seem right, as we want to keep large indices.\n\n    # What if we iterate from largest possible node index downwards,\n    # and try to keep as many nodes as possible, ensuring connectivity,\n    # until we have removed k nodes?\n\n    # Let's rephrase: we want to select a connected component of size n-k\n    # such that the sum of 2^i for nodes in the component is maximized.\n    # This is equivalent to minimizing the sum of 2^i for removed nodes.\n    # Since 2^i grows very fast, we prioritize keeping larger indices.\n    # This means we should remove nodes with smaller indices.\n\n    # We can try to keep the node with the largest index, `n`.\n    # Then, we need to keep `n-k-1` more nodes, all connected to `n` (possibly indirectly).\n    # And we need to remove `k` nodes.\n\n    # This problem can be modeled as finding a connected component of size `n-k`\n    # that maximizes the sum of powers of 2.\n    # Since powers of 2 are strictly increasing, this means we want to keep nodes with larger indices.\n    # So, we should remove nodes with smaller indices.\n\n    # Let's try to remove nodes greedily from 1 up to n.\n    # We want to remove `k` nodes.\n    # We maintain a set of `kept_nodes`. Initially, all nodes are kept.\n    # We iterate from `i = 1` to `n`. If node `i` is currently kept,\n    # we try to remove it. We can remove it if:\n    # 1. We still need to remove more nodes (`removed_count < k`).\n    # 2. Removing node `i` does not disconnect the remaining `n - removed_count - 1` nodes.\n\n    # How to check connectivity efficiently?\n    # This suggests rooting the tree.\n    # If we root the tree at node `n`, the node with the largest index.\n    # Then, we can consider removing nodes.\n\n    # The problem is to find a connected subgraph of size `n-k` that maximizes the sum.\n    # This is equivalent to finding a connected subgraph of size `n-k` that contains the largest possible indices.\n    # So, we should always try to keep node `n`.\n    # And then node `n-1`, if possible, and so on.\n\n    # Let's try to identify the `n-k` nodes we want to keep.\n    # We know we want to keep node `n`.\n    # We can perform a BFS/DFS starting from node `n`.\n    # When exploring, we prioritize adding neighbors with larger indices.\n    # This sounds like a greedy approach.\n\n    # Consider a simpler greedy strategy:\n    # We want to remove `k` nodes.\n    # We iterate from `i = 1` to `n-1`.\n    # If node `i` can be removed without disconnecting the component containing node `n`,\n    # and we still need to remove nodes, we remove `i`.\n    # The \"component containing node `n`\" means the set of all nodes that are currently kept and are reachable from `n`.\n\n    # Let's try to remove nodes starting from 1.\n    # We need to keep `n - k` nodes.\n    # The strategy: always keep node `n`.\n    # We want to remove `k` nodes. We prefer removing nodes with small indices.\n    # We can maintain a count of nodes we've decided to remove.\n    # `removed_nodes = []`\n    # `kept_nodes_count = n`\n\n    # Iterate `i` from `1` to `n-1`.\n    # If `i` is a leaf node in the current graph (after some removals),\n    # and `i != n`, and `kept_nodes_count > n-k`, we can remove `i`.\n    # This is a bit tricky because removing a node can change the structure.\n\n    # A common technique for \"remove k nodes to maximize sum\" in trees is to\n    # root the tree arbitrarily, say at node 1.\n    # Calculate subtree sizes.\n    # If we remove a node, its subtree might be affected.\n\n    # The crucial observation might be:\n    # To maximize sum(2^i), we should try to keep node `n`, then `n-1`, etc.\n    # This means we should remove nodes `1, 2, ..., k` if possible.\n    # But this is not always possible due to connectivity.\n\n    # What if we fix the 'root' of our desired connected component?\n    # Say, we decide that node `X` is the \"highest\" (largest index) node we keep.\n    # No, we want to keep `n`.\n    # The problem asks for `k` nodes to remove.\n\n    # Let's consider the nodes in decreasing order of index, from `n` down to `1`.\n    # We want to select `n-k` nodes to keep.\n    # We must keep node `n` because it has the largest power of 2.\n    # Then, we try to keep `n-1`, then `n-2`, and so on.\n    # We must ensure that the `n-k` selected nodes form a connected component.\n\n    # This sounds like a BFS/DFS from node `n`, but prioritizing higher-indexed neighbors.\n    # Let `kept_set` be the set of nodes we keep. Initially, `kept_set = {n}`.\n    # Let `removed_set` be the set of nodes we remove.\n    # We need to remove `k` nodes.\n    # We will iterate through nodes from `n-1` down to `1`.\n    # For each node `curr_node`:\n    # If `curr_node` is connected to any node in `kept_set` (i.e., it's a neighbor of a node in `kept_set`),\n    # we add `curr_node` to `kept_set`.\n    # Otherwise, we add `curr_node` to `removed_set`.\n    # This strategy will ensure connectivity.\n    # However, this strategy keeps all nodes that are reachable from `n`.\n    # This might keep too many nodes. We need to remove exactly `k` nodes.\n\n    # Let's try the reverse approach: remove nodes greedily from smallest index.\n    # We maintain a set of `kept_nodes`. Initially, all nodes are in `kept_nodes`.\n    # We also maintain a `removed_count`.\n    # We iterate `curr_node` from `1` to `n`.\n    # If `curr_node` is not `n` (we always want to keep `n`), and `removed_count < k`:\n    # We try to remove `curr_node`.\n    # How to check if removing `curr_node` disconnects the graph?\n    # This check is expensive. Running BFS/DFS for each potential removal is O(N * (N+M)) = O(N^2).\n    # With N up to 10^6, this is too slow.\n\n    # A more efficient way to check connectivity:\n    # If we remove `curr_node`, the graph remains connected if and only if\n    # `curr_node` is a leaf node in the current graph, or `curr_node` has degree 1 in the current graph\n    # and its only neighbor is not `n` (if we consider `n` as the \"core\").\n    # This is also not quite right.\n    # What if `curr_node` is an articulation point?\n\n    # Consider the \"core\" of the remaining graph to be node `n`.\n    # We want to keep `n-k` nodes.\n    # We want to keep `n`, and then `n-1`, `n-2`, etc., as long as they are \"close\" to `n`.\n    # \"Close\" means they are part of the connected component.\n\n    # The problem is equivalent to finding a connected subgraph of size `N-K`\n    # that maximizes `sum(2^i)`. This implies we want to keep `N`, then `N-1`, etc.\n    # So we should remove `K` nodes with the smallest possible indices.\n\n    # Let's keep track of the nodes we've decided to remove.\n    # `removed = []`\n    # `current_kept_count = n`\n    # `parent = [-1] * (n + 1)`\n    # `children_count = [0] * (n + 1)` (number of children in the \"kept\" tree, initially 0)\n    # `degree = [len(adj[i]) for i in range(n + 1)]`\n\n    # We want to remove `k` nodes. We prioritize removing nodes with small indices.\n    # Node `n` must always be kept.\n    # Let's use a BFS-like approach starting from node `n`.\n    # We want to identify the `n-k` nodes to keep.\n    # We start with `n` in our `kept_nodes` set.\n    # We need to add `n-k-1` more nodes.\n    # We can use a priority queue to select the next node to add.\n    # The priority queue should prioritize nodes with higher indices.\n    # This is not quite right, as we are removing.\n\n    # What if we consider all nodes initially kept.\n    # We need to remove `k` nodes.\n    # We iterate `i` from `1` to `n-1`.\n    # If `i` is a \"removable\" node and we still need to remove nodes:\n    #   Remove `i`.\n    # A node `i` is \"removable\" if removing it does not disconnect `n` from any other currently kept node.\n    # This means `i` must be a leaf in the current graph (when considering only kept nodes).\n\n    # Let's maintain `current_degree` for each node, considering only kept nodes.\n    # Initially, `current_degree[j] = degree[j]`.\n    # `kept = [True] * (n + 1)`\n    # `removed_list = []`\n\n    # We can use a queue to store potential nodes to remove.\n    # These are nodes `j` such that `j != n` and `current_degree[j] == 1`.\n    # These are \"leaf\" nodes in the current graph (ignoring `n` for a moment).\n    # Initialize `q` with all nodes `j` such that `j != n` and `degree[j] == 1`.\n    # `removed_count = 0`\n\n    # while `q` is not empty and `removed_count < k`:\n    #   `u = q.pop(0)` (or `q.popleft()` for deque)\n    #   If `u` is already marked as removed, continue.\n    #   Mark `u` as removed.\n    #   `removed_list.append(u)`\n    #   `removed_count += 1`\n    #   For each neighbor `v` of `u`:\n    #     If `v` is not removed:\n    #       `current_degree[v] -= 1`\n    #       If `current_degree[v] == 1` and `v != n`:\n    #         `q.append(v)`\n\n    # This greedy approach prioritizes removing \"leaves\" of the tree.\n    # It will remove nodes with smaller indices first if they become leaves.\n    # This is essentially a \"peeling\" process from the outside of the tree.\n    # We start with leaves, remove them, then their neighbors become leaves, etc.\n    # We must ensure `n` is never removed.\n    # The order of removal matters: we want to remove smallest indices first.\n    # So, `q` should be a min-priority queue (or a sorted list/deque).\n\n    # Let's use a `collections.deque` and sort the initial leaves.\n    # `removed_nodes_set = set()`\n    # `current_degrees = [0] * (n + 1)`\n    # for i in range(1, n + 1):\n    #     current_degrees[i] = len(adj[i])\n\n    # `q = collections.deque()`\n    # `initial_leaves = []`\n    # for i in range(1, n + 1):\n    #     if i == n:\n    #         continue\n    #     if current_degrees[i] == 1:\n    #         initial_leaves.append(i)\n    # initial_leaves.sort() # Prioritize smaller indices\n    # q.extend(initial_leaves)\n\n    # `removed_count = 0`\n    # `removed_output = []`\n\n    # while q and removed_count < k:\n    #     u = q.popleft()\n    #     if u in removed_nodes_set: # Already processed via another neighbor\n    #         continue\n\n    #     removed_nodes_set.add(u)\n    #     removed_output.append(u)\n    #     removed_count += 1\n\n    #     for v in adj[u]:\n    #         if v not in removed_nodes_set:\n    #             current_degrees[v] -= 1\n    #             if current_degrees[v] == 1 and v != n:\n    #                 # This neighbor `v` has become a leaf. Add it to the queue.\n    #                 # To maintain the \"smallest index first\" property, we need to insert it\n    #                 # in the correct sorted position. A deque doesn't support this easily.\n    #                 # A min-heap (priority queue) is better here.\n    #                 # Or, just append and sort the queue if it's small, or use a list and sort.\n    #                 # Since we only add one node at a time, we can insert it.\n    #                 # However, if we append and then sort, it's O(Q log Q) each time.\n    #                 # A min-heap (heapq) is the correct structure.\n    #                 heapq.heappush(q_heap, v)\n\n    # Let's refine the greedy strategy using a min-heap.\n    # `import heapq`\n    # `removed_nodes_set = set()`\n    # `current_degrees = [0] * (n + 1)`\n    # for i in range(1, n + 1):\n    #     current_degrees[i] = len(adj[i])\n\n    # `q_heap = []` # Min-heap\n    # for i in range(1, n + 1):\n    #     if i == n:\n    #         continue\n    #     if current_degrees[i] == 1:\n    #         heapq.heappush(q_heap, i)\n\n    # `removed_output = []`\n\n    # while q_heap and len(removed_output) < k:\n    #     u = heapq.heappop(q_heap)\n\n    #     # Check if u has already been effectively removed (e.g., its degree dropped to 0)\n    #     # This check is implicitly handled by `current_degrees[u] == 0` or similar.\n    #     # If `u` was pushed to heap when `current_degrees[u]` was 1, but later\n    #     # another neighbor was removed, `current_degrees[u]` might become 0.\n    #     # We should only remove if `current_degrees[u]` is still 1 (or 0 if it's isolated).\n    #     # But if it's 0, it means it's already removed.\n    #     # The logic is that `u` must be a leaf *among the kept nodes*.\n    #     # If `current_degrees[u]` becomes 0, it means `u` is isolated from the rest of the kept nodes.\n    #     # This can happen if its only neighbor was also removed.\n    #     # So, we should check `current_degrees[u] == 1` when we pop it.\n    #     # If it's 0, it means it was already effectively removed (or its only link was removed).\n    #     # But we're explicitly adding it to `removed_nodes_set`.\n    #     # The condition should be `current_degrees[u] <= 1`.\n    #     # If `current_degrees[u]` is 0, it means it's an isolated node. It can be removed.\n    #     # If `current_degrees[u]` is 1, it's a leaf. It can be removed.\n    #     # If `current_degrees[u]` > 1, it's not a leaf, we can't remove it yet.\n    #     # This check is crucial for correctness.\n\n    #     if u in removed_nodes_set:\n    #         continue # Already removed\n\n    #     # A node `u` can be removed if it's a leaf in the current graph of kept nodes,\n    #     # and it's not node `n`.\n    #     # When we pop `u` from heap, `current_degrees[u]` might have changed.\n    #     # We only remove if `current_degrees[u] == 1` (it's a leaf) or `current_degrees[u] == 0` (it's isolated).\n    #     # If `current_degrees[u]` is 0, it implies its only neighbor (that was not `n`) has been removed.\n    #     # So `u` is effectively isolated from the `n`-component.\n    #     # So, if `current_degrees[u]` is 0, it means it's not connected to the `n`-component.\n    #     # This logic is correct.\n\n    #     # The key is that `u` must be a leaf in the *current* graph of nodes *not yet removed*.\n    #     # When `u` is popped, its `current_degrees[u]` is the number of its neighbors that are *not yet removed*.\n    #     # If `current_degrees[u]` is 1, it's a leaf. If it's 0, it's isolated. Both can be removed.\n    #     # If `current_degrees[u]` > 1, it's not a leaf, so we cannot remove it *yet*.\n    #     # It means `u` was pushed to the heap when its degree was 1, but then another neighbor of `u` was removed,\n    #     # reducing `current_degrees[u]` to 0. Or, it was pushed, but another neighbor was removed, and\n    #     # its degree became 0, then its only neighbor (which was `n`) was also removed (impossible as `n` is kept).\n\n    #     # Let's be precise: `current_degrees[u]` tracks the number of *kept* neighbors.\n    #     # When `u` is popped, if `current_degrees[u]` is 1, it's a leaf of the current component. Remove it.\n    #     # If `current_degrees[u]` is 0, it means it became isolated from the `n`-component. Remove it.\n    #     # If `current_degrees[u]` > 1, it means it's not a leaf. We cannot remove it now.\n    #     # This implies that `u` was added to the heap when its degree was 1, but then some other neighbor `w` of `u`\n    #     # was removed, causing `current_degrees[u]` to decrease further.\n    #     # In this case, `u` is no longer a leaf, and should not be removed yet.\n    #     # So, we only remove if `current_degrees[u] == 1`.\n    #     # If `current_degrees[u] == 0`, it means `u` is completely isolated. It can be removed.\n    #     # The condition `current_degrees[u] <= 1` is correct.\n\n    #     if current_degrees[u] > 1:\n    #         continue # Not a leaf in the current graph of kept nodes. Cannot remove yet.\n\n    #     # If current_degrees[u] is 0 or 1, it's a valid candidate for removal.\n    #     # 0 means isolated, 1 means leaf.\n    #     removed_nodes_set.add(u)\n    #     removed_output.append(u)\n\n    #     for v in adj[u]:\n    #         if v not in removed_nodes_set:\n    #             current_degrees[v] -= 1\n    #             if v != n and current_degrees[v] <= 1: # If v becomes a leaf or isolated, add to heap\n    #                 heapq.heappush(q_heap, v)\n\n    # This greedy strategy works. We always remove the smallest indexed node that is a leaf (or isolated)\n    # in the current graph of kept nodes. This ensures that the remaining graph stays connected\n    # (because we only remove leaves/isolated nodes, which don't disconnect the graph)\n    # and we prioritize removing smaller indices to maximize the sum of 2^i.\n\n    # Let's trace the example: N=6, K=3\n    # Edges: (2,1), (2,6), (4,2), (5,6), (2,3)\n    # Adjacency list:\n    # 1: [2]\n    # 2: [1,6,4,3]\n    # 3: [2]\n    # 4: [2]\n    # 5: [6]\n    # 6: [2,5]\n\n    # Initial degrees:\n    # 1: 1\n    # 2: 4\n    # 3: 1\n    # 4: 1\n    # 5: 1\n    # 6: 2\n\n    # `n = 6`. Node 6 must be kept.\n    # `current_degrees` initialized to `degree`.\n    # `removed_nodes_set = {}`\n    # `q_heap = []`\n    # Initial leaves (not 6) with degree 1:\n    # 1, 3, 4, 5. Add them to heap.\n    # `q_heap = [1, 3, 4, 5]` (order might vary based on heap implementation, but logically sorted)\n\n    # `removed_output = []`\n    # `k = 3`\n\n    # 1. Pop 1. `len(removed_output) = 0 < 3`. `current_degrees[1] = 1`. Valid.\n    #    `removed_nodes_set = {1}`. `removed_output = [1]`.\n    #    Neighbor of 1: 2.\n    #    `current_degrees[2]` becomes 3. (4-1=3). Not <= 1. Don't add 2 to heap.\n    #    `q_heap = [3, 4, 5]`\n\n    # 2. Pop 3. `len(removed_output) = 1 < 3`. `current_degrees[3] = 1`. Valid.\n    #    `removed_nodes_set = {1, 3}`. `removed_output = [1, 3]`.\n    #    Neighbor of 3: 2.\n    #    `current_degrees[2]` becomes 2. (3-1=2). Not <= 1. Don't add 2 to heap.\n    #    `q_heap = [4, 5]`\n\n    # 3. Pop 4. `len(removed_output) = 2 < 3`. `current_degrees[4] = 1`. Valid.\n    #    `removed_nodes_set = {1, 3, 4}`. `removed_output = [1, 3, 4]`.\n    #    Neighbor of 4: 2.\n    #    `current_degrees[2]` becomes 1. (2-1=1). Now `current_degrees[2] <= 1`.\n    #    Add 2 to heap.\n    #    `q_heap = [2, 5]` (or `[5, 2]` then `heapify` would put 2 first)\n\n    # Now `len(removed_output) = 3`. Loop terminates.\n    # Final `removed_output = [1, 3, 4]`. This matches the example output.\n\n    # This greedy approach seems correct and efficient enough.\n    # Time complexity:\n    # Initializing degrees: O(N + M) = O(N) since M = N-1.\n    # Initializing heap: O(N) for iterating, O(N log N) for `N` pushes.\n    # Loop: Each node is pushed to heap at most once. Each edge is processed at most twice (when its endpoints are removed).\n    # So, `k` pops from heap, and at most `2*(N-1)` degree decrements.\n    # Each pop is O(log N). Each push is O(log N).\n    # Total time complexity: O(N log N).\n    # Space complexity: O(N) for adj list, degrees, heap, removed set.\n    # N = 10^6, N log N is about 10^6 * 20 = 2 * 10^7, which is acceptable.\n\n    removed_nodes_set = set()\n    current_degrees = [0] * (n + 1)\n    for i in range(1, n + 1):\n        current_degrees[i] = len(adj[i])\n\n    q_heap = [] # Min-heap\n    for i in range(1, n + 1):\n        if i == n:\n            continue\n        if current_degrees[i] == 1:\n            heapq.heappush(q_heap, i)\n\n    removed_output = []\n\n    while q_heap and len(removed_output) < k:\n        u = heapq.heappop(q_heap)\n\n        if u in removed_nodes_set:\n            continue\n\n        # A node `u` can be removed if it's a leaf (current_degrees[u] == 1)\n        # or if it's isolated (current_degrees[u] == 0) from the 'n'-component.\n        # If current_degrees[u] > 1, it means it's not a leaf among the currently kept nodes,\n        # so it cannot be removed without potentially disconnecting the graph (or parts of it).\n        # This check is essential.\n        if current_degrees[u] > 1:\n            continue\n\n        removed_nodes_set.add(u)\n        removed_output.append(u)\n\n        for v in adj[u]:\n            if v not in removed_nodes_set:\n                current_degrees[v] -= 1\n                if v != n and current_degrees[v] <= 1:\n                    heapq.heappush(q_heap, v)\n\n    removed_output.sort()\n    sys.stdout.write(\" \".join(map(str, removed_output)) + \"\\n\")\n\nimport collections\nimport heapq\n\nsolve()"}
{"task_id": "E2H_CF1709F", "completion": "MOD = 998244353\n\ndef solve():\n    n, k, f = map(int, input().split())\n\n    dp_ways = [[0] * (k + 1) for _ in range(n + 1)]\n    dp_sum = [[0] * (k + 1) for _ in range(n + 1)]\n\n    # Base case: length n\n    # For strings of length n, c_s is the count for that specific string.\n    # The sum of c_s for all strings of length n is the total size.\n    # dp_ways[n][s] = number of ways to choose c_s for strings of length n\n    #                 such that their sum is s.\n    # dp_sum[n][s] = sum of (ways * s) for s.\n\n    # For length n, there are 2^n strings.\n    # Each c_s can be from 0 to k.\n    # This is equivalent to distributing s items into 2^n bins, where each bin has capacity k.\n    # Or, choosing 2^n numbers (c_s) from 0 to k that sum to s.\n    # This is (s + 2^n - 1) choose (2^n - 1) without upper bound,\n    # and then using inclusion-exclusion for upper bound k.\n    # However, k can be large, and 2^n can be large (up to 2^15).\n    # The problem statement says \"maximum possible size of a beautiful multiset is exactly f\".\n    # Let's re-evaluate what the maximum size is.\n\n    # Maximum size of a beautiful multiset:\n    # For any string s of length < n, let P(s) be the set of strings in the multiset that have s as a prefix.\n    # The condition is |P(s)| <= c_s.\n    # For a string s of length n, P(s) is just the count of s in the multiset.\n    #\n    # The maximum size of a beautiful multiset is determined by the minimum of c_s for prefixes.\n    # Let M(s) be the maximum number of strings in a beautiful multiset that have s as a prefix.\n    # If s has length n, M(s) = c_s.\n    # If s has length < n, M(s) = min(c_s, M(s0) + M(s1)).\n    # The total size of the multiset is M(\"\"), where \"\" is the empty string (root of the trie).\n    # M(\"\") = M(\"0\") + M(\"1\").\n    # The problem asks for the number of ways to choose c_s such that M(\"\") = f.\n\n    # Let's define dp[len][val] as the number of ways to choose c_s for all strings of length `len` to `n`\n    # (that are extensions of some fixed prefix of length `len-1`) such that the total maximum size\n    # for this subtree is `val`.\n    # This is still not quite right. The `c_s` values for prefixes depend on children.\n\n    # Let's re-read: \"the number of strings in the multiset such that s is their prefix is not exceeding c_s\".\n    # The maximum possible size of a beautiful multiset is determined by the `c_s` values.\n    # For any node `u` in the trie (representing string `s`), let `N(u)` be the number of strings in the multiset\n    # that have `s` as a prefix.\n    # We must have `N(u) <= c_s`.\n    # If `s` has length `n`, `N(u)` is the count of string `s` in the multiset.\n    # If `s` has length `< n`, `N(u) = N(u_0) + N(u_1)`, where `u_0` is `s0` and `u_1` is `s1`.\n    #\n    # To maximize the total size, we want to maximize `N(\"\")`.\n    # `N(\"\") = N(\"0\") + N(\"1\")`.\n    # `N(\"s\") = min(c_s, N(\"s0\") + N(\"s1\"))` for `len(s) < n`.\n    # `N(\"s\") = c_s` for `len(s) = n`.\n    #\n    # Let `dp[i][j]` be the number of ways to choose `c_s` for all strings `s` of length `i` to `n`\n    # that are descendants of a fixed string of length `i-1`, such that the maximum possible\n    # contribution from this subtree (i.e., `N(s_parent)`) is `j`.\n    #\n    # Base case: `i = n`.\n    # For each string `s` of length `n`, we choose `c_s`.\n    # The maximum contribution from this string is `c_s`.\n    # We are considering *one* string `s` of length `n`.\n    # The value `j` is `c_s`.\n    # There is 1 way to choose `c_s` such that `N(s) = c_s`.\n    # So `dp[n][j] = 1` for `0 <= j <= k`.\n    # This counts choices for *one* leaf node.\n    # There are `2^n` leaf nodes.\n    # For `i=n`, we are considering the values `c_s` for all `2^n` strings of length `n`.\n    # The total sum of `c_s` for these `2^n` strings will be the total size.\n    # Let `dp_n[s]` be the number of ways to choose `c_s` for all `2^n` strings of length `n`\n    # such that their sum is `s`.\n    # This is a stars and bars problem: `s` items into `2^n` bins, each bin capacity `k`.\n    # This is `(s + 2^n - 1) choose (2^n - 1)` without capacity constraint.\n    # `2^n` can be up to `2^15 = 32768`. `k` up to `2e5`. `f` up to `2e5`.\n    # The sum `s` can be up to `2^n * k`.\n    # `f` is the total size, so `s` can be up to `f`.\n    # `dp_n[s]` for `s` from `0` to `f`.\n    #\n    # Let `ways[count][current_sum]` be the number of ways to choose `count` values `c_s`\n    # (each from `0` to `k`) that sum up to `current_sum`.\n    # `ways[1][j] = 1` for `0 <= j <= k`.\n    # For `c = 2` to `2^n`:\n    # `ways[c][s] = sum(ways[c-1][s - j])` for `0 <= j <= k`.\n    # This is `ways[c][s] = sum_{j=0 to k} ways[c-1][s-j]`.\n    # This can be computed efficiently using prefix sums: `ways[c][s] = prefix_sum[c-1][s] - prefix_sum[c-1][s-k-1]`.\n    # Let `dp_last_level[s]` be `ways[2^n][s]`.\n    # `dp_last_level` will be the base for our DP.\n    #\n    # `dp[i][j]` = number of ways to choose `c_s` for all strings `s` of length `i` to `n`\n    #              (descendants of a fixed string of length `i-1`)\n    #              such that `min(c_s_parent, N(s0) + N(s1))` is `j`.\n    # This is still wrong. The problem is that `c_s` values are chosen *first*, then `f` is determined.\n    # We need to count ways to choose `c_s` for all strings `s` (length 1 to n)\n    # such that `max_size = f`.\n\n    # Let `g[len][val]` be the number of ways to choose `c_s` for all strings `s` of length `len` to `n`\n    # that are descendants of a fixed string of length `len-1`, such that the *maximum possible value*\n    # for `N(s_parent)` (which is `min(c_s_parent, N(s0) + N(s1))`) is `val`.\n    # This `val` is the effective capacity for the parent.\n    #\n    # Let `dp[i][j]` be the number of ways to assign `c_s` values for all strings `s` of length `i` to `n`\n    # that are extensions of a particular string of length `i-1`, such that the maximum possible\n    # number of strings in a beautiful multiset with this prefix is `j`.\n    #\n    # For `i = n`: There is one string `s` of length `n`. We choose `c_s`.\n    # The maximum possible count for this string is `c_s`.\n    # So, `dp[n][j]` is the number of ways to choose `c_s` for *this specific string* such that its max count is `j`.\n    # This is 1 way (choose `c_s = j`).\n    # `dp[n][j] = 1` for `0 <= j <= k`.\n    #\n    # For `i < n`: Consider a string `s` of length `i-1`. Its children are `s0` and `s1`.\n    # We need to choose `c_s`, `c_{s0}`, `c_{s1}`, ..., `c_{leaf_nodes}`.\n    # The maximum count for `s` is `min(c_s, N(s0) + N(s1))`.\n    # `N(s0)` is the max count for `s0`'s subtree, `N(s1)` for `s1`'s subtree.\n    #\n    # Let `dp[i][j]` be the number of ways to choose `c_x` for all strings `x` of length `i` to `n`\n    # that are descendants of a fixed string `s` of length `i-1`, such that `N(s0) + N(s1)` (the sum of max counts\n    # from its children's subtrees) is `j`.\n    #\n    # Let `ways_subtree[i][j]` be the number of ways to choose `c_x` for all strings `x` of length `i` to `n`\n    # that are descendants of a fixed string `s` of length `i-1`, such that the sum of maximum counts\n    # from its children `s0` and `s1` (i.e., `N(s0) + N(s1)`) is `j`.\n    #\n    # Base case: `i = n`.\n    # For a string `s` of length `n-1`, its children are `s0` and `s1`, both of length `n`.\n    # `N(s0) = c_{s0}` and `N(s1) = c_{s1}`.\n    # We need to choose `c_{s0}` and `c_{s1}`.\n    # `ways_subtree[n][j]` is the number of ways to choose `c_{s0}` and `c_{s1}` such that `c_{s0} + c_{s1} = j`.\n    # Each `c_x` is from `0` to `k`.\n    # This is `j+1` ways if `j <= k`, `k - (j-k) + 1 = 2k - j + 1` if `k < j <= 2k`.\n    # Let `dp[j]` be the number of ways to pick two integers `a, b` s.t. `0 <= a, b <= k` and `a+b=j`.\n    # `dp[j] = j+1` for `0 <= j <= k`.\n    # `dp[j] = k - (j-k) + 1 = 2k - j + 1` for `k < j <= 2k`.\n    # `dp[j] = 0` otherwise.\n    # This `dp` array will be `ways_subtree[n]`.\n    # Let `S_n[j]` be this array.\n    #\n    # Now for `i` from `n-1` down to `1`:\n    # `ways_subtree[i][j]` is the number of ways to choose `c_x` for descendants of `s0` and `s1` (of length `i`)\n    # such that `N(s0) + N(s1) = j`.\n    # `N(s0)` is determined by `min(c_{s0}, N(s00) + N(s01))`.\n    # `N(s1)` is determined by `min(c_{s1}, N(s10) + N(s11))`.\n    #\n    # Let `dp_current_level[j]` be the number of ways to choose `c_x` for descendants of a string `s` of length `i`\n    # such that `N(s) = j`.\n    #\n    # `dp_current_level[j]` depends on `ways_subtree[i+1][sum_children]`.\n    # For a fixed string `s` of length `i`, we need to choose `c_s` from `0` to `k`.\n    # And we need to choose `c_x` for its descendants `s0` and `s1`.\n    # Let `sum_children = N(s0) + N(s1)`.\n    # The number of ways to get `sum_children` is `ways_subtree[i+1][sum_children] * ways_subtree[i+1][sum_children]`.\n    # No, this is wrong. It's `conv(ways_subtree[i+1], ways_subtree[i+1])`.\n    # Let `W_{i+1}` be `ways_subtree[i+1]`.\n    # Let `W'_{i+1} = W_{i+1} * W_{i+1}` (convolution).\n    # `W'_{i+1}[j]` = number of ways to choose `c_x` for descendants of `s0` and `s1`\n    #                  such that `N(s0) + N(s1) = j`.\n    #\n    # Now, for a fixed string `s` of length `i`, we choose `c_s` from `0` to `k`.\n    # And we have `W'_{i+1}[sum_children]` ways to choose `c_x` for descendants of `s0` and `s1`\n    # such that `N(s0) + N(s1) = sum_children`.\n    # The actual `N(s)` will be `min(c_s, sum_children)`.\n    #\n    # So `dp_val_for_one_node[i][j]` = number of ways to choose `c_s` for *one* string `s` of length `i`\n    #                                  and its descendants such that `N(s) = j`.\n    # `dp_val_for_one_node[i][j] = sum_{c_s=0 to k} sum_{sum_children=0 to MAX_SUM} [min(c_s, sum_children) == j] * W'_{i+1}[sum_children]`\n    #\n    # Let `P_{i+1}[val]` be the prefix sum of `W'_{i+1}`.\n    # `P_{i+1}[val] = sum_{x=0 to val} W'_{i+1}[x]`.\n    #\n    # `dp_val_for_one_node[i][j]`\n    # `j = min(c_s, sum_children)`\n    #\n    # Case 1: `c_s = j`. Then `sum_children >= j`.\n    # Sum over `sum_children` from `j` to `MAX_SUM`: `W'_{i+1}[sum_children]`.\n    # This is `P_{i+1}[MAX_SUM] - P_{i+1}[j-1]`.\n    #\n    # Case 2: `sum_children = j`. Then `c_s > j`.\n    # Sum over `c_s` from `j+1` to `k`: `1` (for each `c_s`).\n    # This is `k - (j+1) + 1 = k - j`.\n    # So, `(k-j) * W'_{i+1}[j]`.\n    #\n    # Combining:\n    # `dp_val_for_one_node[i][j] = (P_{i+1}[MAX_SUM] - P_{i+1}[j-1] + MOD) % MOD` (for `c_s = j`)\n    #                            `+ (k-j) * W'_{i+1}[j] % MOD` (for `sum_children = j`)\n    # This is for `0 <= j <= k`. If `j > k`, `c_s` cannot be `j`, so `dp_val_for_one_node[i][j] = 0`.\n    # The `P_{i+1}[MAX_SUM]` part is the total number of ways to choose `c_x` for descendants.\n    #\n    # `dp_val_for_one_node[i][j]` calculation:\n    # `term1 = (P_{i+1}[MAX_SUM] - (P_{i+1}[j-1] if j > 0 else 0) + MOD) % MOD`\n    # `term2 = (k - j) * W'_{i+1}[j] % MOD` if `j <= k` else `0`\n    # `dp_val_for_one_node[i][j] = (term1 + term2) % MOD`\n    #\n    # This `dp_val_for_one_node[i]` array becomes `ways_subtree[i]`.\n    #\n    # Max possible sum `f` is `2e5`. `k` is `2e5`.\n    # The maximum value for `j` (total count) is `f`.\n    # The maximum value for `sum_children` is `f`.\n    # So arrays should be of size `f+1`.\n    #\n    # Let `dp[i]` be the array `dp_val_for_one_node[i]`.\n    # `dp[n]` is special. For a string `s` of length `n`, `N(s) = c_s`.\n    # `dp[n][j] = 1` for `0 <= j <= k`.\n    # `dp[n][j] = 0` for `j > k`.\n    #\n    # Iteration:\n    # `dp[n]` is initialized as above.\n    # `MAX_SUM_CHILDREN = 2 * f` (since `N(s0)` and `N(s1)` can be up to `f`).\n    #\n    # For `i = n-1` down to `1`:\n    #   `W_prime_i_plus_1 = convolution(dp[i+1], dp[i+1])`\n    #   `P_i_plus_1 = prefix_sums(W_prime_i_plus_1)`\n    #   For `j = 0` to `f`:\n    #     `term1 = (P_i_plus_1[f] - (P_i_plus_1[j-1] if j > 0 else 0) + MOD) % MOD`\n    #     `term2 = 0`\n    #     If `j <= k`:\n    #       `term2 = (k - j) * W_prime_i_plus_1[j] % MOD`\n    #     `dp[i][j] = (term1 + term2) % MOD`\n    #\n    # The final answer is `dp[1][f]`.\n    #\n    # Convolution: `C[s] = sum_{x=0 to s} A[x] * B[s-x]`.\n    # Max `f` is `2e5`. Convolution of two arrays of size `f+1` takes `O(f^2)`.\n    # `n` is up to `15`. `O(n * f^2)` is too slow. `15 * (2e5)^2 = 15 * 4e10`.\n    #\n    # Convolution can be done using NTT (Number Theoretic Transform) in `O(f log f)`.\n    # Total `O(n * f log f)`. `15 * 2e5 * log(2e5) = 15 * 2e5 * 18 = 5.4e7`. This is feasible.\n\n    # NTT setup\n    # MOD = 998244353 is a prime, and 998244353 = 119 * 2^23 + 1.\n    # Primitive root g = 3.\n\n    def ntt(a, invert):\n        n = len(a)\n        j = 0\n        for i in range(1, n):\n            if i < j:\n                a[i], a[j] = a[j], a[i]\n            k = n // 2\n            while j >= k:\n                j -= k\n                k //= 2\n            j += k\n\n        root = pow(3, (MOD - 1) // n, MOD)\n        if invert:\n            root = pow(root, MOD - 2, MOD)\n\n        for length in range(2, n + 1, 2):\n            for i in range(0, n, length):\n                w = 1\n                for j in range(length // 2):\n                    u = a[i + j]\n                    v = a[i + j + length // 2] * w % MOD\n                    a[i + j] = (u + v) % MOD\n                    a[i + j + length // 2] = (u - v + MOD) % MOD\n                    w = w * root % MOD\n\n        if invert:\n            n_inv = pow(n, MOD - 2, MOD)\n            for i in range(n):\n                a[i] = a[i] * n_inv % MOD\n        return a\n\n    def multiply(a, b):\n        len_a = len(a)\n        len_b = len(b)\n        res_len = len_a + len_b - 1\n        \n        # Find smallest power of 2 greater than or equal to res_len\n        ntt_len = 1\n        while ntt_len < res_len:\n            ntt_len <<= 1\n        \n        a_padded = list(a) + [0] * (ntt_len - len_a)\n        b_padded = list(b) + [0] * (ntt_len - len_b)\n\n        a_fft = ntt(a_padded, False)\n        b_fft = ntt(b_padded, False)\n\n        c_fft = [a_fft[i] * b_fft[i] % MOD for i in range(ntt_len)]\n        \n        c = ntt(c_fft, True)\n        \n        return c[:res_len]\n\n    # Initialize dp[n]\n    # dp[n][j] = 1 for 0 <= j <= k, 0 otherwise\n    dp = [[0] * (f + 1) for _ in range(n + 1)]\n\n    for j in range(min(f, k) + 1):\n        dp[n][j] = 1\n\n    # Max possible sum for N(s) is f.\n    # Max possible sum for N(s0) + N(s1) is 2*f.\n    # So `W_prime` array size should be `2*f + 1`.\n    \n    # Precompute prefix sums for dp[n]\n    prefix_dp_n = [0] * (f + 2)\n    for j in range(f + 1):\n        prefix_dp_n[j+1] = (prefix_dp_n[j] + dp[n][j]) % MOD\n\n    for i in range(n - 1, 0, -1):\n        # W_prime_i_plus_1 = convolution(dp[i+1], dp[i+1])\n        # The length of dp[i+1] is f+1.\n        # The length of W_prime_i_plus_1 will be 2*(f+1) - 1 = 2f + 1.\n        # We only need values up to f for W_prime_i_plus_1[j] if j is used in (k-j)*W_prime_i_plus_1[j]\n        # But we need up to 2f for prefix sums.\n        \n        current_dp_len = f + 1\n        \n        # We need to compute convolution up to index 2*f.\n        # The length of the result array from multiply will be up to 2*f + 1.\n        # So pad dp[i+1] to `f+1` elements.\n        W_prime_i_plus_1 = multiply(dp[i+1], dp[i+1])\n        \n        # W_prime_i_plus_1 might be longer than 2*f+1. Truncate it to max_val + 1.\n        max_val_for_sum_children = min(2 * f, len(W_prime_i_plus_1) - 1)\n        \n        # Calculate prefix sums for W_prime_i_plus_1\n        P_i_plus_1 = [0] * (max_val_for_sum_children + 2)\n        for j in range(max_val_for_sum_children + 1):\n            P_i_plus_1[j+1] = (P_i_plus_1[j] + W_prime_i_plus_1[j]) % MOD\n\n        for j in range(f + 1): # j is the target N(s)\n            term1 = 0\n            if j <= max_val_for_sum_children: # sum_children >= j\n                term1 = (P_i_plus_1[max_val_for_sum_children + 1] - P_i_plus_1[j] + MOD) % MOD\n            else: # If j is greater than max possible sum_children, then sum_children >= j is impossible.\n                term1 = 0 # This case means N(s) can't be j if c_s=j and sum_children >= j is impossible.\n\n            term2 = 0\n            if j <= k: # c_s > j\n                if j <= max_val_for_sum_children:\n                    term2 = (k - j) * W_prime_i_plus_1[j] % MOD\n            \n            dp[i][j] = (term1 + term2) % MOD\n\n    print(dp[1][f])\n\nsolve()"}
