{"task_id": "E2H_CF1031A", "completion": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    w, h, k = map(int, data)\n    total = 0\n    for i in range(1, k+1):\n        wi = w - 4*(i-1)\n        hi = h - 4*(i-1)\n        if wi <= 0 or hi <= 0:\n            break\n        if wi == 1:\n            cells = hi\n        elif hi == 1:\n            cells = wi\n        else:\n            cells = 2*wi + 2*hi - 4\n        total += cells\n    print(total)\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF151A", "completion": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, k, l, c, d, p, nl, np = map(int, data)\n    total_drink_ml = k * l\n    drink_toasts = total_drink_ml // nl\n    lime_slices = c * d\n    lime_toasts = lime_slices\n    salt_toasts = p // np\n    max_toasts_total = min(drink_toasts, lime_toasts, salt_toasts)\n    print(max_toasts_total // n)\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF404A", "completion": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    rows = data[1:1+n]\n    diag_char = rows[0][0]\n    other_char = rows[0][1]\n    if diag_char == other_char:\n        print(\"NO\")\n        return\n    ok = True\n    for i in range(n):\n        row = rows[i]\n        for j in range(n):\n            if j == i or j == n-1-i:\n                if row[j] != diag_char:\n                    ok = False\n                    break\n            else:\n                if row[j] != other_char:\n                    ok = False\n                    break\n        if not ok:\n            break\n    print(\"YES\" if ok else \"NO\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF339B", "completion": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    pos = 1\n    time = 0\n    for _ in range(m):\n        a = int(next(it))\n        if a >= pos:\n            time += a - pos\n        else:\n            time += n - (pos - a)\n        pos = a\n    print(time)\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF492B", "completion": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    l = int(next(it))\n    a = [int(next(it)) for _ in range(n)]\n    a.sort()\n    max_gap = 0.0\n    for i in range(1, n):\n        diff = a[i] - a[i-1]\n        if diff > max_gap:\n            max_gap = diff\n    # need half of max gap between adjacent lanterns\n    radius = max_gap / 2.0\n    # consider edges\n    left = a[0] - 0\n    right = l - a[-1]\n    radius = max(radius, left, right)\n    print(\"{:.10f}\".format(radius))\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF88A", "completion": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    notes = data[:3]\n    order = [\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"B\",\"H\"]\n    idx = {n:i for i,n in enumerate(order)}\n    vals = [idx[n] for n in notes]\n    def dist(a,b):\n        return (b - a) % 12\n    is_major = False\n    is_minor = False\n    # try all permutations as X,Y,Z\n    from itertools import permutations\n    for x,y,z in permutations(vals,3):\n        d1 = dist(x,y)\n        d2 = dist(y,z)\n        if d1 == 4 and d2 == 3:\n            is_major = True\n        if d1 == 3 and d2 == 4:\n            is_minor = True\n    if is_major:\n        print(\"major\")\n    elif is_minor:\n        print(\"minor\")\n    else:\n        print(\"strange\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF173A", "completion": "import sys\nimport math\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    A = data[1].strip()\n    B = data[2].strip()\n    m = len(A)\n    k = len(B)\n    g = math.gcd(m, k)\n    l = m // g * k  # lcm\n    # Precompute outcome for one full period l\n    winA = 0\n    winB = 0\n    def outcome(a, b):\n        if a == b:\n            return 0\n        if (a == 'R' and b == 'S') or (a == 'S' and b == 'P') or (a == 'P' and b == 'R'):\n            return 1\n        return -1\n    for i in range(l):\n        res = outcome(A[i % m], B[i % k])\n        if res == 1:\n            winA += 1\n        elif res == -1:\n            winB += 1\n    full = n // l\n    rem = n % l\n    totalA = winA * full\n    totalB = winB * full\n    for i in range(rem):\n        res = outcome(A[i % m], B[i % k])\n        if res == 1:\n            totalA += 1\n        elif res == -1:\n            totalB += 1\n    print(totalB, totalA)  # Nikephoros and Polycarpus: Nikephoros is A so first output is Nikephoros? Problem asks numbers of red spots Nikephoros and Polycarpus.\n    \nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF633B", "completion": "import sys\n\ndef count_trailing_zeros(n):\n    cnt = 0\n    d = 5\n    while d <= n:\n        cnt += n // d\n        d *= 5\n    return cnt\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    m = int(data.strip())\n    lo = 0\n    hi = 5 * (m + 1)  # upper bound; safe\n    # find first n with count >= m\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if count_trailing_zeros(mid) >= m:\n            hi = mid\n        else:\n            lo = mid + 1\n    first = lo\n    if count_trailing_zeros(first) != m:\n        print(0)\n        return\n    res = []\n    for i in range(5):\n        if count_trailing_zeros(first + i) == m:\n            res.append(first + i)\n        else:\n            break\n    print(len(res))\n    if res:\n        print(\" \".join(map(str, res)))\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF1141D", "completion": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    l = next(it).strip()\n    r = next(it).strip()\n    posL = {}\n    posR = {}\n    qL = []\n    qR = []\n    for i, ch in enumerate(l, start=1):\n        if ch == '?':\n            qL.append(i)\n        else:\n            posL.setdefault(ch, []).append(i)\n    for i, ch in enumerate(r, start=1):\n        if ch == '?':\n            qR.append(i)\n        else:\n            posR.setdefault(ch, []).append(i)\n    res = []\n    # match same letters\n    for ch, lst in posL.items():\n        if ch in posR:\n            other = posR[ch]\n            m = min(len(lst), len(other))\n            for i in range(m):\n                res.append((lst[i], other[i]))\n            posL[ch] = lst[m:]\n            posR[ch] = other[m:]\n    # match remaining left specific to right '?'\n    for ch, lst in posL.items():\n        for idx in lst:\n            if qR:\n                res.append((idx, qR.pop()))\n            else:\n                break\n    # match remaining right specific to left '?'\n    for ch, lst in posR.items():\n        for idx in lst:\n            if qL:\n                res.append((qL.pop(), idx))\n            else:\n                break\n    # match remaining '?' with '?'\n    while qL and qR:\n        res.append((qL.pop(), qR.pop()))\n    print(len(res))\n    out = sys.stdout\n    for a, b in res:\n        out.write(f\"{a} {b}\\n\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF1767D", "completion": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    n = int(data[0])\n    s = data[1].strip()\n    N = 1 << n\n    good = []\n    for x in range(1, N+1):\n        lo = hi = x\n        possible = True\n        # process phases i=1..n (s[0] is phase1)\n        for i in range(1, n+1):\n            ch = s[i-1]\n            block = 1 << i\n            # compute new interval of possible winners after this phase\n            if ch == '1':\n                # higher wins in each match: winners are max of pairs\n                # For a given current possible interval [lo,hi], after grouping into blocks of size block,\n                # winners are those numbers which are the maximum in their pair: that means they must be in upper half of block.\n                # So map interval to possible winners by shifting to upper half.\n                lo = ((lo - 1) // (block) ) * (block) + (block//2 + 1)\n                hi = ((hi - 1) // (block) ) * (block) + block\n                # But lo may be larger than hi within same block; however union across blocks needed.\n                # To be safe, we need compute over all blocks overlapping [lo0,hi0] original.\n                # So instead better compute minimal lo and maximal hi across blocks covering original [orig_lo,orig_hi].\n                # Implement properly by using original interval each time.\n                pass\n            else:\n                pass\n        # Above approach incorrect; redo below properly.\n    # Let's implement correct simulation using intervals union: represent possible set as list of intervals.\ndef solve():\n    data = sys.stdin.read().strip().split()\n    n = int(data[0])\n    s = data[1].strip()\n    N = 1 << n\n    res = []\n    for x in range(1, N+1):\n        intervals = [(x, x)]\n        for i in range(1, n+1):\n            ch = s[i-1]\n            block = 1 << i\n            new_intervals = []\n            for (a,b) in intervals:\n                # consider all numbers y in [a,b], map to winners of their block\n                # For each block that intersects [a,b], determine winner range\n                first_block = (a-1)//block\n                last_block = (b-1)//block\n                for blk in range(first_block, last_block+1):\n                    L = blk*block +1\n                    R = (blk+1)*block\n                    segL = max(a, L)\n                    segR = min(b, R)\n                    if segL>segR: continue\n                    if ch=='1':\n                        # winners are upper half: [L+block/2, R]\n                        winL = L + (block>>1)\n                        winR = R\n                    else:\n                        # lower half\n                        winL = L\n                        winR = L + (block>>1) -1\n                    # but only if there exists y in [segL,segR] that can be that winner.\n                    # Since any y in seg range maps to the same winner set for block, include whole win interval.\n                    new_intervals.append((winL, winR))\n            if not new_intervals:\n                intervals = []\n                break\n            # merge intervals\n            new_intervals.sort()\n            merged = []\n            curL,curR = new_intervals[0]\n            for L,R in new_intervals[1:]:\n                if L<=curR+1:\n                    curR = max(curR,R)\n                else:\n                    merged.append((curL,curR))\n                    curL,curR = L,R\n            merged.append((curL,curR))\n            intervals = merged\n        # after all phases, winner must be in intervals and equal to some number (1..N). We check if 1..N contains some value? Actually we want that starting from x as initial skill, after process x wins i.e., final winner equals some value? Wait we check if x can be champion: we simulated mapping of possible winners given initial set containing x. After all phases, if intervals non-empty and contain some number â€” but champion must be some skill value; we need to check if final winner equals anything; but we started with only x present, so champion must be some value possibly different. But we need x to be champion so final intervals must include x.\n        ok = False\n        for a,b in intervals:\n            if a<=x<=b:\n                ok = True\n                break\n        if ok:\n            res.append(str(x))\n    print(\" \".join(res))\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF822C", "completion": "import sys\nimport threading\n\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    vouchers = []\n    maxR = 0\n    for _ in range(n):\n        l = int(next(it)); r = int(next(it)); c = int(next(it))\n        vouchers.append((l, r, c))\n        if r > maxR: maxR = r\n    MAXT = maxR + 5\n    INF = 10**30\n    # group by duration\n    by_len = dict()\n    for l,r,c in vouchers:\n        d = r - l + 1\n        if d not in by_len:\n            by_len[d] = []\n        by_len[d].append((l,r,c))\n    # build best prefix minima for ending at or before t for each duration\n    # For efficiency, for each duration d we build array best_end[t] = minimal cost of interval of length d that ends at <= t\n    best_end = dict()\n    # also build best_start for starting at or after t\n    best_start = dict()\n    # initialize arrays of size MAXT+2\n    for d, arr in by_len.items():\n        be = [INF] * (MAXT + 3)\n        bs = [INF] * (MAXT + 4)\n        # for each interval, update end at r with min cost\n        for l,r,c in arr:\n            if be[r] > c:\n                be[r] = c\n            if bs[l] > c:\n                bs[l] = c\n        # prefix minima for be\n        for t in range(1, MAXT+2):\n            if be[t] > be[t-1]:\n                be[t] = be[t-1]\n        # suffix minima for bs\n        for t in range(MAXT, 0, -1):\n            if bs[t] > bs[t+1]:\n                bs[t] = bs[t+1]\n        best_end[d] = be\n        best_start[d] = bs\n    ans = INF\n    # for each voucher i, consider pairing with duration x - dur\n    for l,r,c in vouchers:\n        d = r - l + 1\n        need = x - d\n        if need <= 0:\n            continue\n        if need not in best_end:\n            continue\n        be = best_end[need]\n        bs = best_start[need]\n        # non-overlap: either partner ends before l (r_partner < l) -> be[l-1]\n        cost1 = be[l-1] if l-1 >= 0 else INF\n        # or partner starts after r (l_partner > r) -> bs[r+1]\n        cost2 = bs[r+1] if r+1 < len(bs) else INF\n        best_partner = cost1 if cost1 < cost2 else cost2\n        if best_partner < INF:\n            total = c + best_partner\n            if total < ans:\n                # need ensure partner is not same interval; since durations differ or same but different interval: but be/bs may pick same interval if identical l,r,c and need==d. We must avoid pairing same interval.\n                # However we are using different durations (need != d) unless need==d. If need!=d, safe. If need==d, could pick same; need to ensure not same.\n                if need != d:\n                    ans = total\n                else:\n                    # need == d: ensure partner different. We must check if the best partner chosen could be same interval. To handle, we can try to find minimal partner cost excluding this exact interval.\n                    # We'll check two options: best ending before l and best starting after r are necessarily different interval since they don't overlap; but they could be same interval if interval both ends before l and starts after r impossible. The only problematic is when partner chosen is same interval but non-overlap impossible because same interval overlaps itself. So be[l-1] and bs[r+1] cannot be this interval because same interval's r >= l and l <= r, so cannot be before l-1 or after r+1. So safe.\n                    ans = total\n    if ans >= INF:\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF498A", "completion": "import sys\nimport threading\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    x1 = int(next(it)); y1 = int(next(it))\n    x2 = int(next(it)); y2 = int(next(it))\n    n = int(next(it))\n    cnt = 0\n    for _ in range(n):\n        a = int(next(it)); b = int(next(it)); c = int(next(it))\n        v1 = a*x1 + b*y1 + c\n        v2 = a*x2 + b*y2 + c\n        if v1 < 0 and v2 > 0 or v1 > 0 and v2 < 0:\n            cnt += 1\n    print(cnt)\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF1846E2", "completion": "import sys\nimport threading\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    t = int(data[0])\n    ns = list(map(int, data[1:]))\n    res = []\n    for n in ns:\n        ok = False\n        if n <= 2:\n            res.append(\"NO\")\n            continue\n        # Try branching factor k from 2 upwards while minimal sum <= n\n        # sum S = 1 + k + k*(k) + k*(k^2) + ...? Actually structure: center connects to k leaves; each leaf (degree1) grows k new leaves in next layer, etc.\n        # Total vertices after m layers (m>=1): 1 + k * (1 + k + k^2 + ... + k^{m-1}) = 1 + k * (k^m -1)/(k-1)\n        # Let m>=1 integer.\n        # So check for k>1 and m>=1 if S==n.\n        # For given k, increase m until S>=n or overflow.\n        max_k = int(n**0.5) + 2\n        # But k can be large; however for m=1, S = 1 + k*1 = 1+k -> so k = n-1 possible if n>2. But k must be >1, m at least 1. But growth formula for m=1 holds.\n        # But our formula for m=1 gives S = 1 + k*(k^1 -1)/(k-1) = 1 + k*(k-1)/(k-1)=1+k. OK.\n        # For k up to n-1, but we can consider small m: we need efficient search.\n        # We iterate k from 2 to max_k, and separately consider k large where m=1 or m=2 maybe.\n        for k in range(2, max_k+1):\n            S = 1\n            term = 1\n            # compute sum = 1 + k * (1 + k + ... + k^{m-1})\n            # iterate m\n            total = 1\n            curr = 1\n            while True:\n                curr *= k  # k^m\n                add = k * (curr // k) if False else None\n                # simpler: maintain geometric sum inside: after m layers, inner_sum = (k^m -1)/(k-1)\n                # but we can iteratively build total: total = 1 + k * inner_sum, where inner_sum accumulates terms of k^{0..m-1}\n                # Let's do iterative:\n                break\n            # redo iterative properly\n            inner = 1  # k^0\n            total = 1 + k * inner  # m=1\n            if total == n:\n                ok = True\n                break\n            if total > n:\n                continue\n            while True:\n                inner *= k\n                total = 1 + k * ( (inner * k - 1) // (k - 1) ) if False else None\n                # avoid division formula to prevent overflow: accumulate inner_sum\n                # We'll maintain inner_sum separately\n                break\n        if ok:\n            res.append(\"YES\")\n            continue\n        # Simpler approach: for each k from 2 to sqrt(n), iterate m building inner_sum until total>=n\n        for k in range(2, int(n**0.5)+2):\n            inner_sum = 1  # sum k^0..k^{m-1}\n            total = 1 + k * inner_sum\n            if total == n:\n                ok = True\n                break\n            if total > n:\n                continue\n            pow_k = k\n            while True:\n                pow_k *= k\n                inner_sum += pow_k\n                # check overflow\n                if inner_sum > (n-1)//k:\n                    break\n                total = 1 + k * inner_sum\n                if total == n:\n                    ok = True\n                    break\n                if total > n:\n                    break\n            if ok:\n                break\n        if ok:\n            res.append(\"YES\")\n            continue\n        # Handle large k where m=1: n = 1 + k -> k = n-1 >1 -> valid only if n-1>1 -> n>2. But m should be done at least once which ok.\n        # But that corresponds to a snowflake where only one growth step performed; allowed. The problem however requires at least once; m>=1 satisfied.\n        if n-1 > 1:\n            res.append(\"YES\")\n            continue\n        res.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(res))\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF1092C", "completion": "import sys\n\ndef solve():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    n = int(data[0].strip())\n    arr = [data[i+1].strip() for i in range(2*n-2)]\n    # group by length\n    bylen = {}\n    for s in arr:\n        bylen.setdefault(len(s), []).append(s)\n    # attempt to build candidate s from two length n-1 strings (they must be one prefix and one suffix)\n    cand1 = bylen[n-1][0] + bylen[n-1][1][-1]  # not used but keep\n    a = bylen[n-1][0]\n    b = bylen[n-1][1]\n    candidates = [a + b[-1], b + a[-1]]  # actually wrong concatenation; correct is a + last char of b etc.\n    # Actually proper candidates are a + last char of b and b + last char of a\n    candidates = [a + b[-1], b + a[-1]]\n    # But simpler: full string must be either a + last char of b or b + last char of a\n    # We'll test both\n    def try_candidate(sfull):\n        res = []\n        used = [False]*(2*n-2)\n        # For each length from n-1 down to 1, we need to assign which of the two strings is prefix/suffix.\n        # We'll attempt greedy: for each input in order, check if matches prefix and suffix and prefer prefix if available.\n        pref_counts = {}\n        suff_counts = {}\n        for l in range(1, n):\n            pref = sfull[:l]\n            suff = sfull[-l:]\n            pref_counts[l] = pref\n            suff_counts[l] = suff\n        ans = []\n        for idx, s in enumerate(arr):\n            l = len(s)\n            isP = (s == pref_counts[l])\n            isS = (s == suff_counts[l])\n            if isP and not isS:\n                ans.append('P')\n            elif isS and not isP:\n                ans.append('S')\n            elif isP and isS:\n                # ambiguous, decide later: tentatively P\n                ans.append('?')\n            else:\n                return None\n        # Now resolve '?' by ensuring exactly one P and one S among each length\n        # For each length, count assigned P and S\n        for l in range(1, n):\n            idxs = [i for i,s in enumerate(arr) if len(s)==l]\n            cntP = sum(1 for i in idxs if ans[i]=='P')\n            cntS = sum(1 for i in idxs if ans[i]=='S')\n            for i in idxs:\n                if ans[i]=='?':\n                    if cntP < 1:\n                        ans[i] = 'P'\n                        cntP += 1\n                    else:\n                        ans[i] = 'S'\n                        cntS += 1\n            if cntP != 1 or cntS != 1:\n                return None\n        return ''.join(ans)\n\n    possible = []\n    # Build correct candidates properly:\n    a = bylen[n-1][0]\n    b = bylen[n-1][1]\n    candA = a + b[-1]\n    candB = b + a[-1]\n    for cand in [candA, candB]:\n        res = try_candidate(cand)\n        if res is not None:\n            print(res)\n            return\n    # As fallback, try all permutations of which n-1 is prefix/suffix\n    # Try a as prefix, b as suffix -> s = a + last char of b already tried. If none, try reverse positions of identicals:\n    # As guaranteed solvable, we shouldn't reach here, but print something\n    print('P'*(n-1) + 'S'*(n-1))\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF270E", "completion": "import sys\nfrom collections import deque\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    a = [0]*m\n    b = [0]*m\n    c = [0]*m\n    adj = [[] for _ in range(n+1)]\n    deg = [0]*(n+1)\n    for i in range(m):\n        ai = int(next(it)); bi = int(next(it)); ci = int(next(it))\n        a[i]=ai; b[i]=bi; c[i]=ci\n        adj[ai].append((bi, ci, i))\n        adj[bi].append((ai, ci, i))\n        deg[ai]+=ci\n        deg[bi]+=ci\n    need = [0]*(n+1)\n    for v in range(1,n+1):\n        if v==1 or v==n:\n            need[v]=0\n        else:\n            need[v]=deg[v]//2\n    used = [False]*m\n    ans = [0]*m\n    q = deque()\n    for v in range(1,n+1):\n        if v!=1 and v!=n and need[v]==0:\n            q.append(v)\n    while q:\n        v = q.popleft()\n        for to, w, idx in adj[v]:\n            if used[idx]:\n                continue\n            used[idx]=True\n            # edge between v and to. We need send flow from to->v to satisfy v (since need[v]==0 now)\n            if a[idx]==v and b[idx]==to:\n                # direction a->b would be v->to, but we want to reduce need[v] so flow must be to->v => direction 1\n                ans[idx]=1\n            else:\n                # a=to, b=v ; setting direction a->b means to->v which is desired => ans=0\n                ans[idx]=0\n            # subtract from need[to]\n            if to!=1 and to!=n:\n                need[to]-=w\n                if need[to]==0:\n                    q.append(to)\n    # For any remaining unused edges, direct from 1 outwards or towards n appropriately.\n    # For safety, direct remaining edges so that edges incident to 1 are outgoing (ans 0 if a==1->b).\n    for idx in range(m):\n        if not used[idx]:\n            used[idx]=True\n            ai=a[idx]; bi=b[idx]\n            # prefer edge directed away from 1. If ai==1 -> 0, if bi==1 ->1, else direct towards n if possible\n            if ai==1:\n                ans[idx]=0\n            elif bi==1:\n                ans[idx]=1\n            elif ai==n:\n                ans[idx]=1\n            elif bi==n:\n                ans[idx]=0\n            else:\n                ans[idx]=0\n    out = '\\n'.join(str(x) for x in ans)\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF1146D", "completion": "import sys\nimport threading\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    m = int(data[0]); a = int(data[1]); b = int(data[2])\n    from collections import deque\n    import math\n    g = math.gcd(a,b)\n    # reachable minimal positions by remainder using Dijkstra-like BFS\n    INF = 10**30\n    dist = [INF]*g\n    dist[0]=0\n    # use Dijkstra with small weights a and b\n    # we can do 0-1? but weights positive. Use priority queue.\n    import heapq\n    pq = [(0,0)]\n    while pq:\n        d,u = heapq.heappop(pq)\n        if d!=dist[u]: continue\n        # move +a: remainder (u+a)%g, cost +a\n        v = (u + a) % g\n        nd = d + a\n        if nd < dist[v]:\n            dist[v]=nd\n            heapq.heappush(pq,(nd,v))\n        # move -b: remainder (u - b) % g\n        v = (u - b) % g\n        nd = d + b\n        if nd < dist[v]:\n            dist[v]=nd\n            heapq.heappush(pq,(nd,v))\n    # For x, f(x) = sum over remainders r of max(0, floor((x - dist[r])/g) +1) if dist[r] <= x\n    # We need sum_{i=0..m} f(i) = sum over r sum_{i=0..m} [dist[r] <= i] * ( floor((i - dist[r])/g) +1 )\n    # For fixed r, let d0 = dist[r]. If d0>m contributes 0. Else sum_{i=d0..m} (floor((i-d0)/g)+1)\n    # Let t = m - d0. Number of terms = t+1. Sum_{i=0..t} (floor(i/g)+1) = (t+1) + sum_{i=0..t} floor(i/g)\n    # sum floor(i/g) = for q from0..floor(t/g): q * count where i in [q*g .. min((q+1)g-1, t)] => count = min(t, (q+1)g-1)-q*g+1\n    # We can compute closed form: let Q = t//g, R = t%g. Then sum = g * (Q*(Q-1)//2) + (Q)*(R+1)\n    # because sum_{q=0..Q} q * cnt_q where cnt_q = g except last cnt_Q = R+1. So sum = g * sum_{q=0..Q-1} q + Q*(R+1) = g*(Q*(Q-1)//2) + Q*(R+1)\n    res = 0\n    for d0 in dist:\n        if d0 > m: continue\n        t = m - d0\n        Q = t // g\n        R = t % g\n        s_floor = g * (Q*(Q-1)//2) + Q*(R+1)\n        total = (t+1) + s_floor\n        res += total\n    print(res)\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF808E", "completion": "import sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    w1 = []\n    w2 = []\n    w3 = []\n    for _ in range(n):\n        wi = int(next(it)); ci = int(next(it))\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    # prefix sums\n    pref1 = [0]\n    for v in w1:\n        pref1.append(pref1[-1] + v)\n    pref2 = [0]\n    for v in w2:\n        pref2.append(pref2[-1] + v)\n    pref3 = [0]\n    for v in w3:\n        pref3.append(pref3[-1] + v)\n    # Precompute best using only weights 1 and 2 for any capacity up to m\n    # dp_cap[c] = max value using only w1 and w2 with total weight <= c\n    # But we can compute array best12 where best12[cap] is max cost.\n    best12 = [0] * (m + 1)\n    # consider taking k twos (weight 2*k) and fill remainder with ones\n    max_twos = min(len(w2), m // 2)\n    for k in range(0, max_twos + 1):\n        weight_twos = 2 * k\n        value_twos = pref2[k]\n        rem = m - weight_twos\n        take1 = min(len(w1), rem)\n        value1 = pref1[take1]\n        total = value_twos + value1\n        cap = weight_twos + take1  # actual weight used\n        if best12[cap] < total:\n            best12[cap] = total\n    # Also consider taking different number of ones alone (when no twos chosen)\n    # Already covered with k=0 above, but ensure other capacities filled: we want for any cap<=m best achievable.\n    # Now propagate maxima to fill capacities: for increasing cap, best12[cap] = max(best12[cap], best12[cap-1])\n    for i in range(1, m + 1):\n        if best12[i] < best12[i-1]:\n            best12[i] = best12[i-1]\n    # Now iterate over number of threes\n    ans = 0\n    max_threes = min(len(w3), m // 3)\n    for t in range(0, max_threes + 1):\n        weight3 = 3 * t\n        value3 = pref3[t]\n        rem = m - weight3\n        total = value3 + best12[rem]\n        if total > ans:\n            ans = total\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF980E", "completion": "import sys\nimport threading\n\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it)); k = int(next(it))\n    adj = [[] for _ in range(n+1)]\n    for _ in range(n-1):\n        a = int(next(it)); b = int(next(it))\n        adj[a].append(b)\n        adj[b].append(a)\n    parent = [0]*(n+1)\n    order = []\n    stack = [1]\n    parent[1]= -1\n    while stack:\n        v = stack.pop()\n        order.append(v)\n        for u in adj[v]:\n            if parent[u]==0:\n                parent[u]=v\n                stack.append(u)\n    size = [1]*(n+1)\n    for v in reversed(order):\n        p = parent[v]\n        if p>0:\n            size[p]+=size[v]\n    score = [0]*(n+1)\n    for i in range(1,n+1):\n        score[i] = i - (size[i]-1)\n    nodes = list(range(1,n+1))\n    nodes.sort(key=lambda x: score[x], reverse=True)\n    removed = set(nodes[:k])\n    res = sorted(removed)\n    print(\" \".join(map(str,res)))\n\nif __name__ == \"__main__\":\n    threading.Thread(target=solve).start()"}
{"task_id": "E2H_CF409I", "completion": "import sys\nfrom collections import deque\n\ndef solve():\n    s = sys.stdin.read().strip()\n    if not s:\n        return\n    name = s.strip()\n    # We need to extract the \"jaws\" part which is between '?' and '):' presumably.\n    # From samples, structure: starts with '?' then jaws in parentheses then ':-' then stomach; overall valid.\n    # Find first '?' then matching ')' before ':-'\n    try:\n        q = name.index('?')\n        colon = name.index('):', q)\n        jaws = name[q+1:colon+1]  # include closing ')'\n    except ValueError:\n        print(\"false\")\n        return\n    # jaws like (pattern)\n    # inside jaws, jaws shape characters: '_' is hole? From samples variables get into stomach via jaws.\n    # Observing sample1: '?(_-_/___*__):-___>__.' output '0010' length 4 equals count of underscores in jaws before )?\n    # Let's count '_' characters inside the parentheses before ')'\n    inner = jaws.strip()\n    if inner.startswith('(') and inner.endswith(')'):\n        core = inner[1:-1]\n    else:\n        core = inner\n    holes = []\n    for i,ch in enumerate(core):\n        if ch == '_':\n            holes.append(i)\n    n = len(holes)\n    # If no holes impossible? But maybe zero-length allowed -> output empty? Not seen.\n    # Need to determine constraints from stomach part after '):'\n    # The stomach part seems to be after '):-' and contains sequence of comparisons and directions like '__>__.' or '__<___,___<____' etc.\n    # Essentially each variable goes into stomach and must satisfy constraints: positions in stomach compare sums or values?\n    # From typical problem \"Feed the Golorp\" (ICPC) it's about stack/queue? But due to time, we'll infer: constraints are comparisons between variables values digits represented by underscores count.\n    # Approach: parse stomach as sequence of comparisons of form sequences of underscores, operator '>' or '<' or ',' or '.' delimiting; each operand is underscores count referencing variable index by position order they arrive.\n    # In samples:\n    # sample1 stomach '___>__.' meaning var3 > var2? Underscores counts map to variable indices: which order? They said values listed in order they get into the jaws.\n    # Probably each group of k underscores refers to variable number k-th? No, underscores represent references to positions into jaws: each group length equals index (1-based).\n    # For sample1 jaws core '_-_/___*__' holes at positions maybe 1,5,9,... but counts: total holes 4 -> indices 1..4.\n    # stomach '___>__.' has operands '___' length3 -> var3, '__' length2 -> var2. Constraint var3 > var2. Among digits 0-9 choose lexicographically smallest sequence satisfying all constraints.\n    # For sample1 output '0010' => vars [0,0,1,0]. var3 (index3) =1, var2=0 OK. Works.\n    # Sample2: '?(__-_+_/_____):-__>__,_____<__.' stomach segments '__>__' => var2 > var2? That can't be; so false. Matches sample2 false.\n    # Sample3 large sample produce digits '0250341' check constraints presumably hold.\n    # So parse stomach into list of comparisons separated by commas and ending with '.'. Each comparison is like A < B or A > B or equality? only < or > shown.\n    # Implement parser: after '):-' get substring until final '.' then split by ',' each comp ends with maybe nothing.\n    try:\n        start = name.index('):-', q) + 3\n    except ValueError:\n        print(\"false\"); return\n    stomach = name[start:]\n    # remove trailing '.' at end\n    if stomach.endswith('.'):\n        stomach = stomach[:-1]\n    comps = stomach.split(',')\n    constraints = []\n    for comp in comps:\n        comp = comp.strip()\n        if not comp:\n            continue\n        if '<' in comp:\n            a,b = comp.split('<',1)\n            op = '<'\n        elif '>' in comp:\n            a,b = comp.split('>',1)\n            op = '>'\n        else:\n            print(\"false\"); return\n        a_idx = a.count('_')\n        b_idx = b.count('_')\n        # indices are 1-based; ensure within n\n        if a_idx<1 or b_idx<1 or a_idx>n or b_idx>n:\n            print(\"false\"); return\n        constraints.append((a_idx-1, op, b_idx-1))\n    # Now we need lexicographically smallest sequence of length n digits 0..9 satisfying all pairwise constraints.\n    # Backtracking assign variables in order 0..n-1 choosing smallest possible digit consistent with constraints among assigned ones and allowing future ones.\n    # Constraints only between variables indices. We can do DFS with pruning using simple consistency: for unassigned variables we need possible domain 0..9; but constraints involving two unassigned can't prune.\n    # For efficiency n maybe up to number of underscores in input length ~ up to 1024. But typical probably small. We'll attempt BFS with backtracking and forward checking via bounds (min,max) using graph of inequalities to deduce ranges through longest path?\n    # Convert constraints to graph: for x - y < 0 for x<y ; etc. We can model as difference constraints: x - y <= -1 for x<y, y - x <= -1 for x>y. Also bounds 0<=x<=9.\n    # Use Bellman-Ford to check feasibility and derive bounds. For lexicographic minimal, assign greedily each variable lowest value 0..9 such that remaining system feasible.\n    m = len(constraints)\n    # Build edges for difference constraints with nodes 0..n-1 plus source.\n    def feasible_with_partial(assign):\n        # assign: dict idx->value\n        # produce difference constraints edges list (u,v,w) meaning v - u <= w\n        edges = []\n        S = n  # source\n        # bounds 0<=x<=9 -> x - S >= 0 => S - x <= 0? We set edges: x - S >=0 -> S - x <= 0 ; and S - x >= -9 -> x - S <=9\n        for i in range(n):\n            edges.append((i, S, 0))  # S - i <= 0\n            edges.append((S, i, 9))  # i - S <=9\n        for (a,op,b) in constraints:\n            if op == '<':\n                # a - b <= -1 -> edge a->b weight -1\n                edges.append((a,b,-1))\n            else:\n                edges.append((b,a,-1))\n        # incorporate assigned: x = val -> x - S <= val and S - x <= -val\n        for i,v in assign.items():\n            edges.append((S, i, v))\n            edges.append((i, S, -v))\n        # Bellman-Ford to detect negative cycles for feasibility. We have nodes 0..S inclusive.\n        V = n+1\n        dist = [0]*(V)\n        # relax V times\n        for _ in range(V):\n            updated = False\n            for u,v,w in edges:\n                if dist[v] > dist[u] + w:\n                    dist[v] = dist[u] + w\n                    updated = True\n            if not updated:\n                break\n        else:\n            # if updated on V-th iteration -> negative cycle -> infeasible\n            return False\n        # Also ensure integer bounds? variables must be integers but constraints integers so OK.\n        # Check dist satisfies bounds? It's fine.\n        return True\n\n    assign = {}\n    result = [0]*n\n    for i in range(n):\n        found = False\n        for d in range(10):\n            assign[i]=d\n            if feasible_with_partial(assign):\n                result[i]=d\n                found = True\n                break\n            del assign[i]\n        if not found:\n            print(\"false\")\n            return\n    print(''.join(str(d) for d in result))\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF1709F", "completion": "unknown\nimport sys\nimport threading\ndef solve():\n    import sys\n    MOD=998244353\n    data=sys.stdin.read().strip().split()\n    n=int(data[0]); k=int(data[1]); f=int(data[2])\n    # dp over tree: nodes are all binary strings length 1..n\n    # We'll compute number of assignments c_s in [0,k] such that max multiset size = f\n    # For a node at depth d (1-based), subtree leaves count = 2^(n-d)\n    # For node v, constraint c_v caps number of leaves in its subtree that can be chosen cumulatively.\n    # Standard: For each node, the maximum achievable count is min(c_v, sum over children achievable)\n    # We need number of assignments c_v so that root achievable = f.\n    # We can do DP from leaves up: for leaves (depth n), node has no children; achievable = min(c_v,1)\n    # For each node, given distributions of child achievable values, but c_v independently chosen.\n    # Observed that achievable at node is min(c_v, sum children achievable). So count of assignments that give achievable = x equals number of choices of c_v such that min(c_v, S)=x where S is sum children achievable. That is:\n    # if x < S: need c_v = x (1 way) ; if x == S: need c_v in [S..k] -> max(0, k-S+1) ways; if x > S: impossible.\n    # So we only need distribution of S (sum of children achievable). For leaves, S=0 (no children), but leaf node achievable = min(c_v,1). Represent leaf as having S=0 and special handling? Better treat nodes as having children count: internal nodes have two children except at last depth where children are leaves considered as having achievable in {0,1}.\n    # We'll process full binary tree of depth n with nodes at depths 1..n. Leaves at depth n have achievable = min(c_v,1).\n    # For leaf: achievable can be 0 (if c_v=0) or 1 (if c_v>=1). Number of choices: count0 = 1 (c_v=0), count1 = k (c_v=1..k) -> if k>=1 else 0.\n    # For internal node with two children, children achievable distributions give polynomial conv. For each possible S (0..maxsum), ways_S = sum over a+b=S ways_a_child1 * ways_b_child2.\n    # Then node achievable x in 0..min(S,max_leaves_in_subtree). But formula: for fixed S, contribution to node having achievable x:\n    # if x < S: need c_v = x -> 1 way (if 0<=x<=k)\n    # if x == S: c_v in [S..k] ways = max(0,k-S+1)\n    # So for each S and each x<=S, add ways_S * (1 or k-S+1) to node_ways[x].\n    # Complexity: number of possible achievable values per node equals up to leaves in subtree = 2^{n-depth}. That can be big but n<=15 so max leaves 2^{14}=16384 manageable. Number of nodes ~2^{n}-1 ~ 32767. But naive convolution at each node could be heavy. But tree is perfect so many repeated patterns; we can build from bottom merging identical distributions.\n    from collections import defaultdict\n    # Precompute leaf distribution\n    if k>=1:\n        leaf = [1, k % MOD]  # ways to have achievable 0 and 1\n    else:\n        leaf = [1]  # only 0\n    # We'll build distributions by depth: depth n nodes are leaves; we move upward merging two identical children distributions.\n    # For depth d node, subtree leaf count = 2^{n-d}\n    # Start with distribution for depth n: leaf\n    dist_by_depth = {}\n    dist_by_depth[n] = [x%MOD for x in leaf]\n    # For depth from n-1 down to 1:\n    for d in range(n-1,0,-1):\n        left = dist_by_depth[d+1]\n        right = left  # identical\n        la = len(left); lb = la\n        # convolution of left and right to get S distribution\n        Slen = la+lb-1\n        S = [0]*Slen\n        for i in range(la):\n            ai = left[i]\n            if ai==0: continue\n            for j in range(lb):\n                S[i+j] = (S[i+j] + ai * right[j])%MOD\n        # Now for each S value, map to node achievable x from 0..maxS\n        maxS = Slen-1\n        # node achievable max is maxS but also limited by k maybe? Achievable can't exceed subtree leaves which is maxS.\n        node = [0]*(maxS+1)\n        for Sval in range(len(S)):\n            waysS = S[Sval]\n            if waysS==0: continue\n            # x from 0..Sval-1 : each has factor 1 (choose c_v = x) provided x<=k\n            upto = min(Sval-1, k)\n            if upto>=0:\n                # add waysS to node[0..upto]\n                w = waysS\n                # accumulate\n                node[0] = (node[0] + w)%MOD\n                if upto+1 < len(node):\n                    node[upto+1] = (node[upto+1] - w)%MOD\n            # x == Sval:\n            if Sval<=k:\n                cnt = (k - Sval + 1)%MOD\n            else:\n                cnt = 0\n            if cnt:\n                node[Sval] = (node[Sval] + waysS * cnt)%MOD\n        # prefix sum for range adds\n        cur = 0\n        for i in range(len(node)):\n            cur = (cur + node[i])%MOD\n            node[i] = cur\n        dist_by_depth[d]=node\n    # root is at depth 1\n    root = dist_by_depth[1]\n    if f < len(root):\n        print(root[f]%MOD)\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    solve()"}
