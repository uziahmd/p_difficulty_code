{"task_id": "E2H_CF1031A", "completion": "w, h, k = map(int, input().split())\n\ntotal = 0\nfor i in range(k):\n    current_w = w - 4 * i\n    current_h = h - 4 * i\n    # Perimeter of the inner rectangle (each ring)\n    perimeter = 2 * (current_w + current_h - 2)\n    total += perimeter\n\nprint(total)"}
{"task_id": "E2H_CF404A", "completion": "n = int(input())\ngrid = [input().strip() for _ in range(n)]\n\n# Check if all characters on the diagonals are the same\ndiag1 = set()\ndiag2 = set()\nfor i in range(n):\n    diag1.add(grid[i][i])\n    diag2.add(grid[i][n - 1 - i])\n\nif len(diag1) != 1 or len(diag2) != 1:\n    print(\"NO\")\nelse:\n    # Check if all non-diagonal characters are the same and different from diagonal\n    diag_char = grid[0][0]\n    other_char = None\n    for i in range(n):\n        for j in range(n):\n            if i == j or i + j == n - 1:\n                if grid[i][j] != diag_char:\n                    print(\"NO\")\n                    exit()\n            else:\n                if other_char is None:\n                    other_char = grid[i][j]\n                elif grid[i][j] != other_char:\n                    print(\"NO\")\n                    exit()\n    print(\"YES\")"}
{"task_id": "E2H_CF492B", "completion": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    l = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    a.sort()\n    \n    max_gap = 0\n    prev = 0\n    \n    for pos in a:\n        gap = pos - prev\n        if gap > max_gap:\n            max_gap = gap\n        prev = pos\n    \n    # Check the gap between last lantern and end of street\n    if l - prev > max_gap:\n        max_gap = l - prev\n    \n    print(\"{0:.10f}\".format(max_gap))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF173A", "completion": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    A = data[1]\n    B = data[2]\n    \n    m = len(A)\n    k = len(B)\n    \n    # Determine who wins each round\n    def get_winner(a, b):\n        if a == b:\n            return 0  # Draw\n        if (a == 'R' and b == 'S') or (a == 'S' and b == 'P') or (a == 'P' and b == 'R'):\n            return 1  # Nikephoros wins\n        else:\n            return 2  # Polycarpus wins\n    \n    # Precompute the results for one full cycle of both sequences\n    cycle_result = []\n    for i in range(m):\n        for j in range(k):\n            res = get_winner(A[i], B[j])\n            cycle_result.append(res)\n    \n    # Count the number of rounds in one full cycle\n    cycle_length = m * k\n    \n    # Total number of full cycles\n    full_cycles = n // cycle_length\n    # Remaining rounds after full cycles\n    remaining_rounds = n % cycle_length\n    \n    # Count results in one full cycle\n    nikephoros_wins = 0\n    polycarpus_wins = 0\n    draws = 0\n    for res in cycle_result:\n        if res == 1:\n            nikephoros_wins += 1\n        elif res == 2:\n            polycarpus_wins += 1\n        else:\n            draws += 1\n    \n    # Total wins from full cycles\n    total_nikephoros_wins = full_cycles * nikephoros_wins\n    total_polycarpus_wins = full_cycles * polycarpus_wins\n    total_draws = full_cycles * draws\n    \n    # Count results in remaining rounds\n    for i in range(remaining_rounds):\n        a_idx = i // k\n        b_idx = i % k\n        res = get_winner(A[a_idx], B[b_idx])\n        if res == 1:\n            total_nikephoros_wins += 1\n        elif res == 2:\n            total_polycarpus_wins += 1\n    \n    print(total_nikephoros_wins, total_polycarpus_wins)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1141D", "completion": "import sys\nfrom collections import defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    l = data[1]\n    r = data[2]\n    \n    left_counts = defaultdict(int)\n    right_counts = defaultdict(int)\n    \n    left_indices = defaultdict(list)\n    right_indices = defaultdict(list)\n    \n    for i in range(n):\n        if l[i] != '?':\n            left_counts[l[i]] += 1\n            left_indices[l[i]].append(i + 1)\n        else:\n            left_counts['?'] += 1\n            left_indices['?'].append(i + 1)\n    \n    for i in range(n):\n        if r[i] != '?':\n            right_counts[r[i]] += 1\n            right_indices[r[i]].append(i + 1)\n        else:\n            right_counts['?'] += 1\n            right_indices['?'].append(i + 1)\n    \n    result = []\n    used_left = set()\n    used_right = set()\n    \n    # Match specific colors\n    for color in left_counts:\n        if color == '?':\n            continue\n        if color in right_counts:\n            count = min(left_counts[color], right_counts[color])\n            for _ in range(count):\n                left_idx = left_indices[color].pop(0)\n                right_idx = right_indices[color].pop(0)\n                result.append((left_idx, right_idx))\n                used_left.add(left_idx)\n                used_right.add(right_idx)\n    \n    # Match question marks with remaining specific colors\n    for color in right_counts:\n        if color == '?':\n            continue\n        if color in left_counts and left_counts[color] > 0:\n            count = min(left_counts[color], right_counts[color])\n            for _ in range(count):\n                left_idx = left_indices[color].pop(0)\n                right_idx = right_indices[color].pop(0)\n                result.append((left_idx, right_idx))\n                used_left.add(left_idx)\n                used_right.add(right_idx)\n    \n    # Match question marks with question marks\n    left_q = left_indices['?']\n    right_q = right_indices['?']\n    for i in range(min(len(left_q), len(right_q))):\n        result.append((left_q[i], right_q[i]))\n    \n    print(len(result))\n    for a, b in result:\n        print(a, b)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF822C", "completion": "import sys\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    idx = 2\n    \n    for _ in range(n):\n        l = int(data[idx])\n        r = int(data[idx+1])\n        cost = int(data[idx+2])\n        idx += 3\n        vouchers.append((l, r, cost))\n    \n    # Preprocess vouchers by duration\n    from collections import defaultdict\n    duration_map = defaultdict(list)\n    \n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        duration_map[duration].append((l, r, cost))\n    \n    min_total_cost = float('inf')\n    \n    # For each possible duration d, check if x - d is also present\n    for d in duration_map:\n        if (x - d) not in duration_map:\n            continue\n        \n        # Get all vouchers with duration d and x - d\n        list_d = duration_map[d]\n        list_xd = duration_map[x - d]\n        \n        # Sort by end time for efficient binary search\n        list_d.sort()\n        list_xd.sort()\n        \n        # For each voucher in list_d, find the best matching voucher in list_xd\n        for l1, r1, cost1 in list_d:\n            # Find all vouchers in list_xd that end before l1\n            # Using binary search to find the first voucher in list_xd with r < l1\n            left = 0\n            right = len(list_xd)\n            while left < right:\n                mid = (left + right) // 2\n                if list_xd[mid][1] >= l1:\n                    right = mid\n                else:\n                    left = mid + 1\n            # All vouchers before index left are valid\n            if left > 0:\n                min_cost = min([cost2 for _, _, cost2 in list_xd[:left]])\n                min_total_cost = min(min_total_cost, cost1 + min_cost)\n            \n            # Find all vouchers in list_xd that start after r1\n            left = 0\n            right = len(list_xd)\n            while left < right:\n                mid = (left + right) // 2\n                if list_xd[mid][0] <= r1:\n                    left = mid + 1\n                else:\n                    right = mid\n            # All vouchers from index left are valid\n            if left < len(list_xd):\n                min_cost = min([cost2 for _, _, cost2 in list_xd[left:]])\n                min_total_cost = min(min_total_cost, cost1 + min_cost)\n    \n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1846E2", "completion": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n < 2:\n        return False\n    # Try all possible k from 2 to sqrt(n)\n    max_k = int(math.isqrt(n)) + 1\n    for k in range(2, max_k + 1):\n        total = 1  # initial node\n        current = 1\n        while True:\n            next_nodes = current * k\n            if total + next_nodes > n:\n                break\n            total += next_nodes\n            current = next_nodes\n        if total == n:\n            return True\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n = int(data[i])\n        if is_snowflake(n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF270E", "completion": "import sys\nimport heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    edges = []\n    for _ in range(m):\n        a = int(data[idx])\n        idx += 1\n        b = int(data[idx])\n        idx += 1\n        c = int(data[idx])\n        idx += 1\n        edges.append((a, b, c))\n    \n    # Build adjacency list with flow and index\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b, c = edges[i]\n        adj[a].append((b, c, i))\n        adj[b].append((a, c, i))\n    \n    # BFS to assign directions based on flow conservation\n    # We will use a priority queue to process nodes with minimal residual flow\n    from collections import deque\n    \n    # Initialize flow conservation\n    flow_in = [0] * (n + 1)\n    flow_out = [0] * (n + 1)\n    \n    # We start from node 1, which has no incoming flow\n    flow_in[1] = 0\n    flow_out[1] = 0\n    \n    # Use a priority queue to process nodes with minimal residual flow\n    pq = []\n    heapq.heappush(pq, (0, 1))\n    \n    while pq:\n        res, u = heapq.heappop(pq)\n        if res > flow_in[u] - flow_out[u]:\n            continue\n        \n        for v, c, i in adj[u]:\n            if u == v:\n                continue\n            # Check if we can direct this edge from u to v\n            if flow_out[u] + c <= flow_in[u]:\n                # Direct from u to v\n                flow_out[u] += c\n                flow_in[v] += c\n                # Mark direction\n                dir = 0 if u == edges[i][0] else 1\n                print(dir)\n            elif flow_in[u] + c <= flow_out[u]:\n                # Direct from v to u\n                flow_in[u] += c\n                flow_out[v] += c\n                # Mark direction\n                dir = 1 if u == edges[i][0] else 0\n                print(dir)\n            else:\n                # This edge is part of a cycle, handle it later\n                pass\n    \nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF808E", "completion": "import sys\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    items = []\n    idx = 2\n    for _ in range(n):\n        w = int(data[idx])\n        c = int(data[idx + 1])\n        items.append((w, c))\n        idx += 2\n    \n    # Group items by weight\n    from collections import defaultdict\n    weight_groups = defaultdict(list)\n    for w, c in items:\n        weight_groups[w].append(c)\n    \n    # Sort each group and compute prefix sums\n    dp = [0] * (m + 1)\n    \n    for w in sorted(weight_groups.keys()):\n        costs = weight_groups[w]\n        costs.sort(reverse=True)\n        prefix = [0] * (len(costs) + 1)\n        for i in range(len(costs)):\n            prefix[i + 1] = prefix[i] + costs[i]\n        \n        # For each possible weight we can take this item\n        # We use binary search to find the maximum number of items we can take\n        for j in range(m, w - 1, -1):\n            k = (j - w) // w\n            if k >= len(prefix):\n                k = len(prefix) - 1\n            dp[j] = max(dp[j], dp[j - w * k] + prefix[k])\n    \n    print(dp[m])\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF409I", "completion": "import sys\nimport re\n\ndef parse_golorp_name(name):\n    # Extract the expression part inside the parentheses\n    match = re.search(r'\\(([^)]+)\\)', name)\n    if not match:\n        return None, None\n    \n    expr = match.group(1)\n    \n    # Extract the conditions\n    conditions = []\n    for condition in re.split(r'[:-]', expr):\n        if condition.strip():\n            conditions.append(condition.strip())\n    \n    return expr, conditions\n\ndef is_valid_condition(condition):\n    # Check if the condition is valid (contains only digits and operators)\n    return all(c.isdigit() or c in '+-*/()' for c in condition)\n\ndef parse_conditions(conditions):\n    # Parse each condition into a tuple of (left, op, right)\n    parsed = []\n    for cond in conditions:\n        parts = re.split(r'([+\\\\-*/])', cond)\n        left = parts[0]\n        op = parts[1]\n        right = parts[2]\n        parsed.append((left, op, right))\n    return parsed\n\ndef evaluate_condition(left, op, right, values):\n    # Evaluate the condition with given values\n    left_val = int(values[int(left) - 1]) if left.isdigit() else int(values[int(left[1:]) - 1])\n    right_val = int(values[int(right) - 1]) if right.isdigit() else int(values[int(right[1:]) - 1])\n    \n    if op == '+':\n        return left_val + right_val\n    elif op == '-':\n        return left_val - right_val\n    elif op == '*':\n        return left_val * right_val\n    elif op == '/':\n        return left_val // right_val\n    else:\n        raise ValueError(f\"Unknown operator: {op}\")\n\ndef is_valid_sequence(values, conditions):\n    for left, op, right in conditions:\n        try:\n            result = evaluate_condition(left, op, right, values)\n            if op == '>':\n                if result <= 0:\n                    return False\n            elif op == '<':\n                if result >= 0:\n                    return False\n        except:\n            return False\n    return True\n\ndef find_lex_smallest_sequence(length, conditions):\n    # Try to find the lexicographically smallest sequence\n    from itertools import product\n    \n    for seq in product(range(10), repeat=length):\n        if is_valid_sequence(seq, conditions):\n            return ''.join(map(str, seq))\n    return None\n\ndef main():\n    input_str = sys.stdin.read().strip()\n    expr, conditions = parse_golorp_name(input_str)\n    \n    if not expr or not conditions:\n        print(\"false\")\n        return\n    \n    if not all(is_valid_condition(cond) for cond in conditions):\n        print(\"false\")\n        return\n    \n    conditions = parse_conditions(conditions)\n    \n    length = len(expr) - expr.count('(') - expr.count(')')\n    if length < 1:\n        print(\"false\")\n        return\n    \n    result = find_lex_smallest_sequence(length, conditions)\n    if result:\n        print(result)\n    else:\n        print(\"false\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF151A", "completion": "# Read input\nn, k, l, c, d, p, nl, np = map(int, input().split())\n\n# Calculate total drink, lime slices, and salt\ntotal_drink = k * l\ntotal_lime_slices = c * d\ntotal_salt = p\n\n# Calculate how many toasts can be made based on each resource\ntoasts_drink = total_drink // nl\ntoasts_lime = total_lime_slices // n\ntoasts_salt = total_salt // np\n\n# The answer is the minimum of the three values\nprint(min(toasts_drink, toasts_lime, toasts_salt))"}
{"task_id": "E2H_CF339B", "completion": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2 + m]))\n    \n    current = 1\n    time = 0\n    \n    for task in a:\n        if task > current:\n            time += task - current\n        else:\n            time += (n - current + task)\n        current = task\n    \n    print(time)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF88A", "completion": "import sys\n\ndef note_to_index(note):\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    return notes.index(note)\n\ndef get_distances(notes):\n    indices = [note_to_index(note) for note in notes]\n    unique_indices = list(set(indices))\n    if len(unique_indices) != 3:\n        return None\n    unique_indices.sort()\n    d1 = (unique_indices[1] - unique_indices[0]) % 12\n    d2 = (unique_indices[2] - unique_indices[1]) % 12\n    return d1, d2\n\ndef classify_chord(notes):\n    distances = get_distances(notes)\n    if not distances:\n        return \"strange\"\n    d1, d2 = distances\n    if d1 == 4 and d2 == 3:\n        return \"major\"\n    if d1 == 3 and d2 == 4:\n        return \"minor\"\n    return \"strange\"\n\ndef main():\n    input_notes = sys.stdin.read().strip().split()\n    result = classify_chord(input_notes)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF633B", "completion": "import sys\n\ndef count_trailing_zeros(n):\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n\ndef find_n_for_m_zeros(m):\n    low = 0\n    high = 5 * m\n    while low <= high:\n        mid = (low + high) // 2\n        zeros = count_trailing_zeros(mid)\n        if zeros < m:\n            low = mid + 1\n        elif zeros > m:\n            high = mid - 1\n        else:\n            # Find the first occurrence of m trailing zeros\n            first = mid\n            while count_trailing_zeros(first) == m:\n                first -= 1\n            first += 1\n            # Find the last occurrence of m trailing zeros\n            last = mid\n            while count_trailing_zeros(last) == m:\n                last += 1\n            last -= 1\n            return (last - first + 1, list(range(first, last + 1)))\n    return (0, [])\n\ndef main():\n    m = int(sys.stdin.readline())\n    k, ns = find_n_for_m_zeros(m)\n    print(k)\n    if k > 0:\n        print(' '.join(map(str, ns)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1767D", "completion": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    s = data[1]\n    \n    total_teams = 2 ** n\n    \n    # Initialize the range of possible skill levels\n    min_skill = 1\n    max_skill = total_teams\n    \n    for i in range(n):\n        phase = i + 1\n        current_phase_games = 2 ** (n - phase)\n        \n        if s[i] == '0':\n            # In this phase, lower skill wins\n            # So we narrow down the range to the lower half\n            max_skill = (min_skill + max_skill) // 2\n        else:\n            # In this phase, higher skill wins\n            # So we narrow down the range to the upper half\n            min_skill = (min_skill + max_skill + 1) // 2\n    \n    # All integers from min_skill to max_skill inclusive are winning\n    result = list(range(min_skill, max_skill + 1))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF498A", "completion": "import sys\nimport math\nfrom collections import deque\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef sign(x):\n    return 1 if x > 0 else -1\n\ndef cross(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef intersect(line1, line2):\n    a1, b1, c1 = line1\n    a2, b2, c2 = line2\n    det = a1 * b2 - a2 * b1\n    if det == 0:\n        return None\n    x = (b1 * c2 - b2 * c1) / det\n    y = (a2 * c1 - a1 * c2) / det\n    return (x, y)\n\ndef is_point_on_line(x, y, a, b, c):\n    return abs(a * x + b * y + c) < 1e-8\n\ndef get_block_id(point, lines):\n    x, y = point\n    block_id = 0\n    for i in range(len(lines)):\n        a, b, c = lines[i]\n        val = a * x + b * y + c\n        if val > 0:\n            block_id |= (1 << i)\n    return block_id\n\ndef main():\n    x1, y1 = readints()\n    x2, y2 = readints()\n    n = int(sys.stdin.readline())\n    lines = []\n    for _ in range(n):\n        a, b, c = readints()\n        lines.append((a, b, c))\n    \n    home = (x1, y1)\n    uni = (x2, y2)\n    \n    # Get block IDs of home and university\n    home_block = get_block_id(home, lines)\n    uni_block = get_block_id(uni, lines)\n    \n    if home_block == uni_block:\n        print(0)\n        return\n    \n    # Build graph: block ID -> adjacent block IDs\n    graph = {}\n    for i in range(n):\n        a1, b1, c1 = lines[i]\n        for j in range(i + 1, n):\n            a2, b2, c2 = lines[j]\n            pt = intersect((a1, b1, c1), (a2, b2, c2))\n            if pt is not None:\n                # Check if the intersection is valid\n                if not is_point_on_line(pt[0], pt[1], a1, b1, c1) or not is_point_on_line(pt[0], pt[1], a2, b2, c2):\n                    continue\n                # Find regions around the intersection\n                # We can use a BFS approach to find connected regions\n                pass  # This part is complex and requires more detailed geometry logic\n    \n    # Since building the graph is complex, we use BFS on the block IDs directly\n    visited = set()\n    queue = deque()\n    queue.append((home_block, 0))\n    visited.add(home_block)\n    \n    while queue:\n        current_block, steps = queue.popleft()\n        if current_block == uni_block:\n            print(steps)\n            return\n        # Generate all possible neighboring blocks\n        for i in range(n):\n            a, b, c = lines[i]\n            val = a * x1 + b * y1 + c\n            if val > 0:\n                neighbor = current_block ^ (1 << i)\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, steps + 1))\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1092C", "completion": "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    candidates = data[1:]\n    \n    # Group candidates by length\n    length_to_candidates = defaultdict(list)\n    for i, s in enumerate(candidates):\n        length_to_candidates[len(s)].append((i, s))\n    \n    # Try all possible combinations of prefixes and suffixes\n    from itertools import product\n    \n    for prefix_indices, suffix_indices in product(\n        product(range(2), repeat=n-1), \n        repeat=2\n    ):\n        # Check if the assignment is valid\n        prefix_set = set()\n        suffix_set = set()\n        for i in range(n-1):\n            if prefix_indices[i] == 1:\n                prefix_set.add(candidates[i])\n            else:\n                suffix_set.add(candidates[i])\n        \n        # Check if all candidates are used exactly once\n        if len(prefix_set) != n-1 or len(suffix_set) != n-1:\n            continue\n        \n        # Check if there exists a string s of length n such that\n        # all prefixes and suffixes match\n        # We try all possible combinations of the two strings of each length\n        for lengths in length_to_candidates:\n            candidates_of_length = length_to_candidates[lengths]\n            for p, s in product(candidates_of_length, repeat=2):\n                if p[1] == s[1]:\n                    continue\n                # Try to build a string s of length n\n                # Check if the first string can be a prefix and the second a suffix\n                # or vice versa\n                # Check if the first string is a prefix and the second is a suffix\n                if len(p[1]) + len(s[1]) <= n and p[1] == s[1][:len(p[1])] and s[1] == p[1][:-len(s[1])]:\n                    # Valid combination found\n                    result = ['P' if prefix_indices[i] == 1 else 'S' for i in range(n-1)]\n                    print(''.join(result))\n                    return\n                # Check if the second string is a prefix and the first is a suffix\n                if len(s[1]) + len(p[1]) <= n and s[1] == p[1][:len(s[1])] and p[1] == s[1][:-len(p[1])]:\n                    # Valid combination found\n                    result = ['P' if prefix_indices[i] == 1 else 'S' for i in range(n-1)]\n                    print(''.join(result))\n                    return\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1146D", "completion": "import sys\nimport math\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    m, a, b = map(int, input().split())\n\n    # Compute gcd of a and b\n    g = math.gcd(a, b)\n\n    # If a and b are not coprime, then the reachable numbers are multiples of g\n    # So for any x >= 0, f(x) is the number of multiples of g in [0, x]\n    # Which is (x // g) + 1\n\n    # But if a and b are coprime, then the frog can reach all numbers >= some value\n    # We need to find the minimal number that can be reached using combinations of a and b\n\n    # Let's check if a and b are coprime\n    if g == 1:\n        # The frog can reach all numbers >= (a * b - a - b)\n        # So for x >= (a * b - a - b), f(x) = x + 1\n        # For x < (a * b - a - b), f(x) is the count of reachable numbers <= x\n        # We need to find how many numbers <= x can be expressed as a linear combination of a and b with non-negative coefficients\n\n        # To find the minimal number that can be reached, we use the Chicken McNugget theorem\n        min_reachable = a * b - a - b\n        # All numbers >= min_reachable can be reached\n\n        # Now calculate sum from i=0 to m of f(i)\n        total = 0\n        for i in range(m + 1):\n            if i < min_reachable:\n                # We need to count how many numbers <= i can be written as x*a + y*b where x, y >= 0\n                # This is equivalent to solving x*a + y*b <= i\n                # It's a bit complex to compute directly, but for small values, we can simulate\n                count = 0\n                for x in range(i // a + 1):\n                    remainder = i - x * a\n                    if remainder >= 0 and remainder % b == 0:\n                        count += 1\n                total += count\n            else:\n                total += i + 1\n        print(total)\n    else:\n        # Reachable numbers are multiples of g\n        # So for any x, f(x) = (x // g) + 1\n        total = 0\n        for i in range(m + 1):\n            total += (i // g) + 1\n        print(total)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF980E", "completion": "import sys\nimport heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    k = int(data[idx + 1])\n    idx += 2\n    \n    edges = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a = int(data[idx])\n        b = int(data[idx + 1])\n        edges[a].append(b)\n        edges[b].append(a)\n        idx += 2\n    \n    # We want to keep the districts with highest 2^i values\n    # So we should remove the ones with smallest i, but ensuring connectivity\n    # We can use a max-heap to track the nodes we want to keep\n    # But since we need to maintain connectivity, we can use a greedy approach:\n    # Keep the nodes with the highest 2^i values and ensure they form a connected subgraph\n    \n    # First, we'll use a priority queue (min-heap) to select the nodes to remove\n    # We will try to remove the nodes with the smallest i, but only if they are not critical for connectivity\n    \n    # Let's find the minimum spanning tree (MST) and then decide which nodes to remove\n    # But since the graph is a tree, any subset of nodes that forms a connected subgraph is a subtree\n    \n    # To maximize the sum of 2^i, we should keep the nodes with the largest i\n    # So we can greedily remove the smallest i nodes that are not critical to the connectivity\n    \n    # We will use a priority queue (min-heap) to keep track of the nodes to remove\n    # We will also track the number of nodes in the current connected component\n    # We will use a Union-Find (Disjoint Set Union - DSU) structure to manage connectivity\n    \n    parent = list(range(n + 1))\n    \n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    \n    def union(u, v):\n        pu = find(u)\n        pv = find(v)\n        if pu != pv:\n            parent[pu] = pv\n    \n    # Build the DSU structure\n    for a, b in edges:\n        union(a, b)\n    \n    # Now we collect all the nodes in the same component as node 1\n    # Since the graph is connected, all nodes are in the same component\n    # So we can just take all nodes and sort them by their value (i)\n    nodes = list(range(1, n + 1))\n    nodes.sort()\n    \n    # We want to remove k nodes with the smallest i values\n    # But we must ensure that the remaining nodes form a connected subgraph\n    # So we can remove the smallest i nodes that are not on the path from the largest i node to the root\n    \n    # To do this, we can use a greedy approach:\n    # We will keep the nodes with the highest 2^i values and remove the smallest ones\n    # We can use a priority queue (min-heap) to select the nodes to remove\n    \n    # Sort the nodes by their value (i)\n    nodes.sort()\n    \n    # Use a min-heap to keep track of the nodes to remove\n    to_remove = []\n    for i in range(k):\n        to_remove.append(nodes[i])\n    \n    # Sort the to_remove list\n    to_remove.sort()\n    print(' '.join(map(str, to_remove)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1709F", "completion": "import sys\nimport math\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    n = int(data[0])\n    k = int(data[1])\n    f = int(data[2])\n\n    # Precompute factorial and inverse factorial for combinations\n    max_n = 2 * n\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n\n    inv_fact[max_n] = pow(fact[max_n], MOD - 2, MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\n    def comb(a, b):\n        if a < 0 or b < 0 or a < b:\n            return 0\n        return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD\n\n    # For each string s of length 1 to n, we choose c_s from 0 to k\n    # We need to count the number of ways such that the maximum size of a beautiful multiset is exactly f\n\n    # Let dp[i][j] be the number of ways to assign c_s for all strings of length <= i such that the maximum size of a beautiful multiset is exactly j\n    # We will use dynamic programming with memoization\n\n    # Initialize dp[0][0] = 1\n    dp = [defaultdict(int) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for length in range(1, n + 1):\n        new_dp = defaultdict(int)\n        for prev_count in dp[length - 1]:\n            for c in range(0, k + 1):\n                # For each string of length 'length', we can choose c_s = c\n                # The constraint is that for all prefixes of this string, the count must not exceed their respective c_s\n                # The maximum size of a beautiful multiset is the minimum over all constraints\n                # So we need to compute the number of ways where the minimal constraint is exactly f\n                # But since we are building up, we track the current max possible size of a beautiful multiset\n\n                # The maximum size of a beautiful multiset for strings of length <= length is min(prev_max, c)\n                # We update accordingly\n                new_max = min(prev_count, c)\n                new_dp[new_max] = (new_dp[new_max] + dp[length - 1][prev_count]) % MOD\n\n        dp[length] = new_dp\n\n    # The answer is the number of ways to assign c_s for all strings of length <= n such that the maximum size of a beautiful multiset is exactly f\n    print(dp[n].get(f, 0))\n\nif __name__ == \"__main__\":\n    main()"}
