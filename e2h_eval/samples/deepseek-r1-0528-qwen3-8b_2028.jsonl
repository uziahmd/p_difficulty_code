{"task_id": "E2H_CF1031A", "completion": "w, h, k = map(int, input().split())\n\ntotal = 0\nfor i in range(k):\n    current_w = w - 4 * i\n    current_h = h - 4 * i\n    # Perimeter of the inner rectangle (each ring)\n    perimeter = 2 * (current_w + current_h - 2)\n    total += perimeter\n\nprint(total)"}
{"task_id": "E2H_CF404A", "completion": "n = int(input())\ngrid = [input().strip() for _ in range(n)]\n\n# Check if all diagonal elements are the same\ndiag1 = set()\ndiag2 = set()\nfor i in range(n):\n    diag1.add(grid[i][i])\n    diag2.add(grid[i][n - 1 - i])\n\nif len(diag1) != 1 or len(diag2) != 1:\n    print(\"NO\")\nelse:\n    # Check if all non-diagonal elements are the same and different from diagonal\n    other_char = grid[0][1]\n    for i in range(n):\n        for j in range(n):\n            if i == j or i + j == n - 1:\n                continue\n            if grid[i][j] != other_char:\n                print(\"NO\")\n                exit()\n    print(\"YES\")"}
{"task_id": "E2H_CF492B", "completion": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    l = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    a.sort()\n    \n    max_gap = 0\n    prev = 0\n    \n    for pos in a:\n        gap = pos - prev\n        if gap > max_gap:\n            max_gap = gap\n        prev = pos\n    \n    # Check the gap between last lantern and end of street\n    if l - prev > max_gap:\n        max_gap = l - prev\n    \n    print(\"{0:.10f}\".format(max_gap))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF173A", "completion": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    A = data[1]\n    B = data[2]\n    \n    m, k = len(A), len(B)\n    \n    # Precompute the results for one full cycle of A and B\n    results = []\n    for i in range(m):\n        for j in range(k):\n            a = A[i]\n            b = B[j]\n            if a == b:\n                results.append((0, 0))  # Draw\n            elif (a == 'R' and b == 'S') or (a == 'S' and b == 'P') or (a == 'P' and b == 'R'):\n                results.append((1, 0))  # Nikephoros wins\n            else:\n                results.append((0, 1))  # Polycarpus wins\n    \n    # Total number of rounds in one full cycle of both sequences\n    cycle_len = m * k\n    \n    # Number of full cycles\n    full_cycles = n // cycle_len\n    # Remaining rounds\n    remaining_rounds = n % cycle_len\n    \n    # Count total red spots\n    nikephoros_red = 0\n    polycarpus_red = 0\n    \n    # Add contributions from full cycles\n    for res in results:\n        nikephoros_red += res[0] * full_cycles\n        polycarpus_red += res[1] * full_cycles\n    \n    # Add contributions from remaining rounds\n    for i in range(remaining_rounds):\n        a = A[i % m]\n        b = B[i % k]\n        if a == b:\n            continue\n        elif (a == 'R' and b == 'S') or (a == 'S' and b == 'P') or (a == 'P' and b == 'R'):\n            nikephoros_red += 1\n        else:\n            polycarpus_red += 1\n    \n    print(nikephoros_red, polycarpus_red)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1141D", "completion": "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    l = data[1]\n    r = data[2]\n    \n    left_counts = defaultdict(int)\n    right_counts = defaultdict(int)\n    \n    left_indices = defaultdict(list)\n    right_indices = defaultdict(list)\n    \n    for i in range(n):\n        color = l[i]\n        if color != '?':\n            left_counts[color] += 1\n            left_indices[color].append(i + 1)\n        else:\n            left_counts['?'] += 1\n            left_indices['?'].append(i + 1)\n    \n    for i in range(n):\n        color = r[i]\n        if color != '?':\n            right_counts[color] += 1\n            right_indices[color].append(i + 1)\n        else:\n            right_counts['?'] += 1\n            right_indices['?'].append(i + 1)\n    \n    result = []\n    used_left = set()\n    used_right = set()\n    \n    # Match specific colors\n    for color in left_counts:\n        if color == '?':\n            continue\n        if color in right_counts:\n            count = min(left_counts[color], right_counts[color])\n            for _ in range(count):\n                left_idx = left_indices[color].pop(0)\n                right_idx = right_indices[color].pop(0)\n                result.append((left_idx, right_idx))\n                used_left.add(left_idx)\n                used_right.add(right_idx)\n    \n    # Match question marks with specific colors\n    for color in right_counts:\n        if color == '?':\n            continue\n        if color in left_counts:\n            count = min(left_counts[color], right_counts[color])\n            for _ in range(count):\n                left_idx = left_indices[color].pop(0)\n                right_idx = right_indices[color].pop(0)\n                result.append((left_idx, right_idx))\n                used_left.add(left_idx)\n                used_right.add(right_idx)\n    \n    # Match question marks with question marks\n    left_q = left_indices['?']\n    right_q = right_indices['?']\n    for i in range(min(len(left_q), len(right_q))):\n        result.append((left_q[i], right_q[i]))\n    \n    print(len(result))\n    for a, b in result:\n        print(a, b)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF822C", "completion": "import sys\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    idx = 2\n    \n    for _ in range(n):\n        l = int(data[idx])\n        r = int(data[idx + 1])\n        cost = int(data[idx + 2])\n        idx += 3\n        vouchers.append((l, r, cost))\n    \n    # Group vouchers by duration\n    from collections import defaultdict\n    duration_map = defaultdict(list)\n    \n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        duration_map[duration].append((l, r, cost))\n    \n    min_total_cost = float('inf')\n    \n    for duration, vouchers_list in duration_map.items():\n        if x - duration < 0:\n            continue\n        \n        other_duration = x - duration\n        if other_duration not in duration_map:\n            continue\n        \n        # Sort vouchers by end time\n        vouchers_list.sort(key=lambda v: v[1])\n        other_vouchers = duration_map[other_duration]\n        other_vouchers.sort(key=lambda v: v[1])\n        \n        # For each voucher in first group, find the best non-overlapping voucher in second group\n        for l1, r1, cost1 in vouchers_list:\n            # Find all vouchers in other_vouchers that end before l1 (i.e., don't overlap)\n            # Use binary search to find the rightmost voucher that ends before l1\n            left = 0\n            right = len(other_vouchers) - 1\n            best_idx = -1\n            \n            while left <= right:\n                mid = (left + right) // 2\n                l2, r2, cost2 = other_vouchers[mid]\n                if r2 < l1:\n                    best_idx = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            \n            if best_idx != -1:\n                min_total_cost = min(min_total_cost, cost1 + other_vouchers[best_idx][2])\n        \n        # Also check for the reverse case (other_duration first, duration second)\n        for l1, r1, cost1 in other_vouchers:\n            left = 0\n            right = len(vouchers_list) - 1\n            best_idx = -1\n            \n            while left <= right:\n                mid = (left + right) // 2\n                l2, r2, cost2 = vouchers_list[mid]\n                if r2 < l1:\n                    best_idx = mid\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            \n            if best_idx != -1:\n                min_total_cost = min(min_total_cost, cost1 + vouchers_list[best_idx][2])\n    \n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1846E2", "completion": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n < 2:\n        return False\n    # Check for k from 2 to sqrt(n)\n    for k in range(2, int(math.isqrt(n)) + 1):\n        total = 1  # initial vertex\n        current = 1\n        while True:\n            current *= k\n            total += current\n            if total == n:\n                return True\n            elif total > n:\n                break\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n = int(data[i])\n        if is_snowflake(n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF270E", "completion": "import sys\nimport heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    edges = []\n    for _ in range(m):\n        a = int(data[idx])\n        idx += 1\n        b = int(data[idx])\n        idx += 1\n        c = int(data[idx])\n        idx += 1\n        edges.append((a, b, c))\n    \n    # Build graph with flow values\n    from collections import defaultdict\n    graph = defaultdict(list)\n    for i, (a, b, c) in enumerate(edges):\n        graph[a].append((b, c, i))\n        graph[b].append((a, c, i))\n    \n    # Compute flow balance for each node\n    flow_balance = [0] * (n + 1)\n    for a, b, c in edges:\n        flow_balance[a] += c\n        flow_balance[b] += c\n    \n    # We need to direct the edges so that flow_balance[v] == 0 for 2 <= v <= n-1\n    # and source has no incoming edges\n    \n    # Use BFS to assign directions\n    from collections import deque\n    \n    visited = [False] * (n + 1)\n    direction = [0] * m\n    \n    q = deque()\n    q.append(1)\n    visited[1] = True\n    \n    while q:\n        u = q.popleft()\n        for v, c, i in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                q.append(v)\n                # Assign direction from u to v\n                direction[i] = 0\n            else:\n                # If already visited, check if flow balance is satisfied\n                pass\n    \n    # Now adjust direction to satisfy flow balance\n    # We can use a priority queue to process nodes with positive flow balance\n    # and assign flow to their neighbors\n    pq = []\n    for i in range(1, n + 1):\n        if i != 1 and i != n:\n            if flow_balance[i] > 0:\n                heapq.heappush(pq, (flow_balance[i], i))\n    \n    while pq:\n        bal, u = heapq.heappop(pq)\n        if bal == 0:\n            continue\n        for v, c, i in graph[u]:\n            if flow_balance[v] < 0:\n                # Flow should go from v to u\n                direction[i] = 1\n                flow_balance[u] -= c\n                flow_balance[v] += c\n                if flow_balance[v] < 0:\n                    heapq.heappush(pq, (flow_balance[v], v))\n    \n    # Output the directions\n    for d in direction:\n        print(d)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF808E", "completion": "import sys\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    items = []\n    idx = 2\n    for _ in range(n):\n        w = int(data[idx])\n        c = int(data[idx + 1])\n        items.append((w, c))\n        idx += 2\n    \n    # Group items by weight\n    from collections import defaultdict\n    weight_groups = defaultdict(list)\n    for w, c in items:\n        weight_groups[w].append(c)\n    \n    # Sort each group and compute prefix sums\n    dp = [0] * (m + 1)\n    \n    for w in sorted(weight_groups.keys()):\n        costs = weight_groups[w]\n        costs.sort(reverse=True)\n        prefix = [0]\n        for c in costs:\n            prefix.append(prefix[-1] + c)\n        \n        # Try to update dp for all possible weights\n        for j in range(m, w - 1, -1):\n            # Find the maximum number of items we can take\n            k = min(len(prefix) - 1, j // w)\n            dp[j] = max(dp[j], dp[j - w * k] + prefix[k])\n    \n    print(dp[m])\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF409I", "completion": "import sys\nimport re\n\ndef parse_golorp(name):\n    # Extract the pattern from the name\n    pattern = re.search(r'^(?:\\?|\\.)(.*?)(?=\\:)', name).group(1)\n    \n    # Parse the constraints\n    constraints = []\n    parts = name.split(':')\n    for part in parts[1:]:\n        if not part:\n            continue\n        if ',' in part:\n            left, right = part.split(',')\n            left_var = left[0]\n            left_val = int(left[1:])\n            right_var = right[0]\n            right_val = int(right[1:])\n            constraints.append((left_var, left_val, right_var, right_val))\n        else:\n            var = part[0]\n            val = int(part[1:])\n            constraints.append((var, val, None, None))\n    \n    # Determine the number of variables needed\n    vars_needed = set()\n    for c in constraints:\n        if c[1] is not None:\n            vars_needed.add(c[0])\n        if c[3] is not None:\n            vars_needed.add(c[2])\n    vars_needed = sorted(vars_needed)\n    \n    # Create a list of variables and their constraints\n    var_constraints = {var: [] for var in vars_needed}\n    for c in constraints:\n        if c[1] is not None:\n            var_constraints[c[0]].append(('<=', c[1]))\n        if c[3] is not None:\n            var_constraints[c[2]].append(('>=', c[3]))\n    \n    return vars_needed, var_constraints, pattern\n\ndef is_valid_sequence(vars_needed, var_constraints, sequence):\n    for i, var in enumerate(vars_needed):\n        val = int(sequence[i])\n        for op, limit in var_constraints[var]:\n            if op == '<=' and val > limit:\n                return False\n            if op == '>=' and val < limit:\n                return False\n    return True\n\ndef find_lex_smallest_sequence(vars_needed, var_constraints, pattern):\n    from itertools import product\n    \n    # Generate all possible sequences of length len(vars_needed) with digits 0-9\n    for seq in product(range(10), repeat=len(vars_needed)):\n        seq_str = ''.join(map(str, seq))\n        if is_valid_sequence(vars_needed, var_constraints, seq_str):\n            return seq_str\n    return \"false\"\n\ndef main():\n    input_str = sys.stdin.read().strip()\n    result = find_lex_smallest_sequence(*parse_golorp(input_str))\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF151A", "completion": "# Read input\nn, k, l, c, d, p, nl, np = map(int, input().split())\n\n# Calculate total drink, lime slices, and salt\ntotal_drink = k * l\ntotal_lime_slices = c * d\ntotal_salt = p\n\n# Calculate how many toasts can be made based on each resource\ntoasts_by_drink = total_drink // nl\ntoasts_by_lime = total_lime_slices // n\ntoasts_by_salt = total_salt // np\n\n# The answer is the minimum of the three values\nprint(min(toasts_by_drink, toasts_by_lime, toasts_by_salt))"}
{"task_id": "E2H_CF339B", "completion": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2 + m]))\n    \n    current = 1\n    time = 0\n    \n    for task in a:\n        if task > current:\n            time += task - current\n        else:\n            time += (n - current + task)\n        current = task\n    \n    print(time)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF88A", "completion": "import sys\n\ndef note_to_index(note):\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    return notes.index(note)\n\ndef get_distances(notes):\n    indices = [note_to_index(note) for note in notes]\n    unique_indices = list(set(indices))\n    if len(unique_indices) != 3:\n        return None\n    unique_indices.sort()\n    d1 = (unique_indices[1] - unique_indices[0]) % 12\n    d2 = (unique_indices[2] - unique_indices[1]) % 12\n    d3 = (unique_indices[0] - unique_indices[2]) % 12\n    return sorted([d1, d2, d3])\n\ndef classify_chord(notes):\n    distances = get_distances(notes)\n    if not distances:\n        return \"strange\"\n    if distances == [3, 4, 5]:\n        return \"minor\"\n    if distances == [4, 3, 5]:\n        return \"major\"\n    return \"strange\"\n\ndef main():\n    input_notes = sys.stdin.read().strip().split()\n    result = classify_chord(input_notes)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF633B", "completion": "import sys\n\ndef count_trailing_zeros(n):\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n\ndef find_n_for_m_zeros(m):\n    low = 0\n    high = 5 * m\n    while low <= high:\n        mid = (low + high) // 2\n        zeros = count_trailing_zeros(mid)\n        if zeros < m:\n            low = mid + 1\n        elif zeros > m:\n            high = mid - 1\n        else:\n            break\n    res = []\n    if low > high:\n        return [0]\n    # Find the first n with exactly m trailing zeros\n    while count_trailing_zeros(low) == m:\n        res.append(low)\n        low += 1\n    return [len(res)] + res\n\ndef main():\n    m = int(sys.stdin.readline())\n    result = find_n_for_m_zeros(m)\n    print(result[0])\n    if result[0] > 0:\n        print(' '.join(map(str, result[1:])))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1767D", "completion": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    s = data[1]\n    \n    total_teams = 1 << n  # 2^n\n    \n    # Initialize the range of possible skill levels\n    min_skill = 1\n    max_skill = total_teams\n    \n    for i in range(n):\n        phase = n - i - 1  # 0-based phase index from 0 to n-1\n        if s[i] == '0':\n            # In this phase, lower skill wins\n            # So the current min_skill can be promoted to the next level\n            # We need to find the smallest number that can reach this phase\n            # and win all matches\n            # To do that, we find the smallest number that is at least the current min_skill\n            # and can be promoted through all previous phases\n            # Since it's a binary tournament, we can use binary search\n            # Find the smallest x such that x can reach this phase\n            # The range for this phase is [min_skill, max_skill]\n            # We need to find the smallest x in [min_skill, max_skill] that can win this phase\n            # Since it's 0, lower skill wins, so the minimum skill can be promoted\n            # So we update min_skill to the smallest number that can reach this phase\n            # The minimum number that can reach this phase is the smallest number that can be promoted\n            # which is the same as the current min_skill\n            # Wait, we need to find the range of numbers that can reach this phase\n            # For example, in phase 0 (first round), the numbers are from 1 to 2^n\n            # In phase 1, only the winners of first round can proceed\n            # So we need to track the range of possible winners at each phase\n            # Let's track the possible range of skill levels that can reach the current phase\n            # Initially, all numbers from 1 to 2^n are possible\n            # After each phase, we narrow down the range based on s[i]\n            # If s[i] is '0', lower skill wins: the minimum skill can be promoted\n            # So the new min_skill is the current min_skill\n            # But the max_skill is halved\n            # Because only half of the teams can proceed\n            # Wait, no. For phase i, there are 2^(n-i) games\n            # So the number of teams halves each time\n            # So the range of possible skill levels is halved each time\n            # So for phase i, the range is [min_skill, max_skill]\n            # If s[i] is '0', lower skill wins: the new min_skill remains the same\n            # But the max_skill is halved\n            # Because only the lower skilled teams can proceed\n            # Wait, no. If lower skill wins, then the winners are the lower skilled teams\n            # So the new max_skill is the current min_skill + (max_skill - min_skill) // 2\n            # Because the winners are the lower half\n            # Wait, no. If you have a range [a, b], and lower skill wins, then the winners are the lower half\n            # So the new range is [a, (a + b) // 2]\n            # Because the winners are the first half of the range\n            # So we update max_skill = (min_skill + max_skill) // 2\n            max_skill = (min_skill + max_skill) // 2\n        else:\n            # s[i] is '1', higher skill wins\n            # So the new max_skill remains the same\n            # But the min_skill is updated to the middle of the range\n            # Because the winners are the upper half\n            min_skill = (min_skill + max_skill) // 2 + 1\n    \n    # The winning integers are from min_skill to max_skill inclusive\n    result = list(range(min_skill, max_skill + 1))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF498A", "completion": "import sys\nimport math\nfrom collections import deque\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef cross(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef line_intersection(line1, line2):\n    a1, b1, c1 = line1\n    a2, b2, c2 = line2\n    det = a1 * b2 - a2 * b1\n    if det == 0:\n        return None\n    x = (b1 * c2 - b2 * c1) / det\n    y = (a2 * c1 - a1 * c2) / det\n    return (x, y)\n\ndef is_point_on_line(x, y, a, b, c):\n    return abs(a * x + b * y + c) < 1e-8\n\ndef main():\n    x1, y1 = readints()\n    x2, y2 = readints()\n    n = int(sys.stdin.readline())\n    roads = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n)]\n\n    # Function to check if two lines are parallel\n    def are_parallel(line1, line2):\n        a1, b1, _ = line1\n        a2, b2, _ = line2\n        return abs(a1 * b2 - a2 * b1) < 1e-8\n\n    # Build graph of blocks\n    # Each block is represented by a tuple (x, y) of a point inside it\n    # We use BFS to find the minimum steps from home to university\n\n    # Create a set of all intersections\n    intersections = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            line1 = roads[i]\n            line2 = roads[j]\n            pt = line_intersection(line1, line2)\n            if pt is not None:\n                intersections.add(pt)\n\n    # Function to check if two points are in the same block\n    def same_block(p1, p2):\n        for line in roads:\n            a, b, c = line\n            val1 = a * p1[0] + b * p1[1] + c\n            val2 = a * p2[0] + b * p2[1] + c\n            if (val1 > 0 and val2 <= 0) or (val1 < 0 and val2 >= 0):\n                return False\n        return True\n\n    # Use BFS to find the shortest path from home to university\n    visited = set()\n    queue = deque()\n    queue.append((x1, y1))\n    visited.add((x1, y1))\n    steps = 0\n\n    while queue:\n        for _ in range(len(queue)):\n            x, y = queue.popleft()\n            if (x, y) == (x2, y2):\n                print(steps)\n                return\n            for line in roads:\n                a, b, c = line\n                val = a * x + b * y + c\n                if abs(val) < 1e-8:\n                    continue\n                # Find a point on the other side of the line\n                dx, dy = 1, 1\n                if abs(b) > abs(a):\n                    dx, dy = 1, 0\n                else:\n                    dx, dy = 0, 1\n                new_x = x + dx * 10\n                new_y = y + dy * 10\n                if not is_point_on_line(new_x, new_y, a, b, c):\n                    new_p = (new_x, new_y)\n                    if new_p not in visited:\n                        visited.add(new_p)\n                        queue.append(new_p)\n        steps += 1\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1092C", "completion": "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    strings = data[1:]\n    \n    # Group strings by length\n    length_map = defaultdict(list)\n    for s in strings:\n        length_map[len(s)].append(s)\n    \n    # Try all possible combinations of prefixes and suffixes\n    # For each length, we have two strings, one is prefix, one is suffix\n    # So for each length, we try both possibilities\n    from itertools import product\n    \n    # Generate all possible assignments of P and S\n    possible_assignments = []\n    for length in range(1, n):\n        options = [(i, j) for i in range(2) for j in range(2)]\n        possible_assignments.append(options)\n    \n    # Try all combinations of prefix/suffix assignments\n    from itertools import product\n    for assignment in product(*possible_assignments):\n        # Build the candidate string based on the assignment\n        prefix_candidates = []\n        suffix_candidates = []\n        for i in range(1, n):\n            if assignment[i-1][0] == 0:\n                prefix_candidates.append(length_map[i][0])\n            else:\n                prefix_candidates.append(length_map[i][1])\n        \n        for i in range(1, n):\n            if assignment[i-1][1] == 0:\n                suffix_candidates.append(length_map[i][0])\n            else:\n                suffix_candidates.append(length_map[i][1])\n        \n        # Check if there exists a string that matches all prefixes and suffixes\n        # Try all possible combinations of prefixes and suffixes to form the full string\n        from itertools import product\n        for prefix in product(*prefix_candidates):\n            for suffix in product(*suffix_candidates):\n                candidate = prefix + suffix\n                if len(candidate) == n:\n                    # Check if all prefixes and suffixes match\n                    valid = True\n                    for i in range(1, n):\n                        prefix_str = ''.join(prefix[:i])\n                        if assignment[i-1][0] == 0:\n                            if prefix_str != length_map[i][0]:\n                                valid = False\n                                break\n                        else:\n                            if prefix_str != length_map[i][1]:\n                                valid = False\n                                break\n                    if valid:\n                        # Build the output string\n                        output = ['P' if assignment[i][0] == 0 else 'S' for i in range(n-1)]\n                        output += ['P' if assignment[i][1] == 0 else 'S' for i in range(n-1)]\n                        print(''.join(output))\n                        return\n    \nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1146D", "completion": "import sys\nimport math\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    m, a, b = map(int, input().split())\n\n    # Compute gcd of a and b\n    g = math.gcd(a, b)\n    \n    # If a and b are not coprime, then the reachable positions are multiples of g\n    # So f(x) = number of multiples of g in [0, x]\n    # Which is (x // g) + 1\n    # But if the frog can't jump at all (a >= b), then f(x) = 1 for all x\n    if a >= b:\n        # Frog can't make any jumps\n        total = (m + 1) * (m + 2) // 2\n        print(total)\n        return\n\n    # Otherwise, the reachable positions are multiples of g\n    # So f(x) = (x // g) + 1\n    # Sum from i=0 to m: sum_{i=0}^m ((i // g) + 1)\n    # = sum_{i=0}^m (i // g) + (m + 1)\n    # We need to compute sum_{i=0}^m (i // g)\n\n    def sum_division(n, d):\n        # sum_{i=0}^n (i // d)\n        q, r = divmod(n, d)\n        return (q * (q - 1) // 2) * d + (q * (n - r + 1)) // 2\n\n    total = sum_division(m, g) + (m + 1)\n    print(total)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF980E", "completion": "import sys\nimport heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    k = int(data[idx + 1])\n    idx += 2\n    \n    edges = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a = int(data[idx])\n        b = int(data[idx + 1])\n        edges[a].append(b)\n        edges[b].append(a)\n        idx += 2\n    \n    # Use a max-heap to keep track of the most valuable districts\n    # We use negative values to simulate a max-heap using Python's min-heap\n    heap = []\n    \n    # Perform DFS to find all districts and their fans count\n    visited = [False] * (n + 1)\n    \n    def dfs(u):\n        visited[u] = True\n        heapq.heappush(heap, -u)  # Push negative for max-heap behavior\n        for v in edges[u]:\n            if not visited[v]:\n                dfs(v)\n    \n    dfs(1)\n    \n    # Remove k smallest districts (by value) from the heap\n    for _ in range(k):\n        removed = -heapq.heappop(heap)\n        print(removed, end=' ')\n    \n    print()\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1709F", "completion": "import sys\nimport itertools\nimport math\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    n, k, f = map(int, input().split())\n\n    # Precompute factorials and inverse factorials for binomial coefficients\n    max_fact = 2 * 10**5 + 10\n    fact = [1] * (max_fact)\n    inv_fact = [1] * (max_fact)\n    for i in range(1, max_fact):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact[max_fact - 1] = pow(fact[max_fact - 1], MOD - 2, MOD)\n    for i in range(max_fact - 2, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\n    def comb(n, k):\n        if n < 0 or k < 0 or k > n:\n            return 0\n        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\n\n    # We need to count the number of ways to choose c_s such that the maximum size of a beautiful multiset is exactly f\n\n    # For each string s of length from 1 to n, we can choose c_s from 0 to k\n    # The maximum possible size of a beautiful multiset is determined by the minimal c_s among all prefixes of any string in the multiset\n\n    # To maximize the size of a beautiful multiset, we should choose c_s as large as possible for all strings\n    # However, the constraint is that for every string s, the number of strings in the multiset with s as prefix must not exceed c_s\n    # So the maximum size is the minimum of c_s over all strings s\n\n    # Let's define dp[i][m] = number of ways to assign c_s to all strings of length up to i such that the minimum c_s is m\n    # Then the answer is dp[n][f]\n\n    # We will use dynamic programming with memoization\n\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def solve(i, m):\n        if i == 0:\n            return 1 if m == 0 else 0\n        res = 0\n        # For each string of length i, we can choose c_s from 0 to k\n        # But we have to ensure that the minimum c_s among all strings is at least m\n        # So for each string of length i, we can choose c_s >= m\n        # But also, the minimum c_s among all strings of length up to i must be exactly m\n        # So we need to consider how many strings of length i have c_s >= m\n        # And then multiply by the number of ways to assign c_s to the previous strings\n        # But this seems complex, so instead, let's think recursively\n        # The minimum c_s among all strings of length up to i is m\n        # So for the current level (length i), we can choose c_s >= m\n        # But the overall minimum must be exactly m\n        # So we need to count the number of ways where the minimum is exactly m\n        # This is equivalent to: total ways with min >= m minus total ways with min >= m+1\n        # So we can use inclusion-exclusion\n        # So dp[i][m] = dp[i-1][m] * (number of choices for c_s of length i that are >= m) - dp[i-1][m+1] * (same)\n        # Wait, no. We need to track the minimum\n        # Let's try another approach\n\n        # Let's think of it as for each string of length i, we can choose c_s from 0 to k\n        # But we want the minimum c_s among all strings of length up to i to be exactly m\n        # So for all strings of length <= i, their c_s must be >= m\n        # And at least one string has c_s = m\n        # So we can compute the number of ways where all c_s >= m, and subtract the number of ways where all c_s >= m+1\n        # That gives us the number of ways where the minimum c_s is exactly m\n\n        # So for each i, we compute the number of ways to assign c_s to all strings of length up to i such that all c_s >= m\n        # Then the answer is dp[i][m] = ways_all_ge_m - ways_all_ge_m_plus_1\n\n        # So first, compute ways_all_ge_m for all m\n        # Let's compute the number of ways to assign c_s to all strings of length up to i such that c_s >= m for all s\n        # For each string s, we have (k - m + 1) choices\n        # Number of strings of length up to i is 2^1 + 2^2 + ... + 2^i = 2^(i+1) - 2\n        # So total ways = (k - m + 1) ^ (2^(i+1) - 2)\n\n        # But since we're working modulo MOD, we need to compute this efficiently\n        # So for each i, we can precompute the number of strings of length up to i\n\n        num_strings = 2 ** (i + 1) - 2\n        if num_strings < 0:\n            return 0\n        # Now, compute the number of ways to assign c_s to all strings of length up to i such that c_s >= m\n        # This is (k - m + 1)^num_strings\n        # But we need to compute this mod MOD\n        power = pow(k - m + 1, num_strings, MOD)\n        # Now, compute the number of ways where all c_s >= m+1\n        power_plus_1 = pow(k - (m + 1) + 1, num_strings, MOD) if (k - m) >= 1 else 0\n        return (power - power_plus_1) % MOD\n\n    # Now, we need to compute the number of ways to choose c_s for all strings of length up to n such that the minimum c_s is exactly f\n    # Which is solve(n, f)\n\n    # But wait, the problem says \"the maximum possible size of a beautiful multiset is exactly f\"\n    # Which is the same as the minimum c_s among all strings being exactly f\n    # Because the maximum size of a beautiful multiset is the minimum c_s among all strings\n    # Because the multiset can't have more than the minimum c_s for any prefix\n\n    # So the answer is the number of ways to assign c_s such that the minimum c_s is exactly f\n\n    # So the final answer is solve(n, f)\n\n    print(solve(n, f))\n\nif __name__ == \"__main__\":\n    main()"}
