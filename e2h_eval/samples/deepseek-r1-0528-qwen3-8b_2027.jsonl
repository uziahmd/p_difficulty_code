{"task_id": "E2H_CF1031A", "completion": "w, h, k = map(int, input().split())\n\ntotal = 0\nfor i in range(k):\n    current_w = w - 4 * i\n    current_h = h - 4 * i\n    # Perimeter of the inner rectangle (each ring)\n    perimeter = 2 * (current_w + current_h - 2)\n    total += perimeter\n\nprint(total)"}
{"task_id": "E2H_CF404A", "completion": "n = int(input())\ngrid = [input().strip() for _ in range(n)]\n\n# Check if all characters on the diagonals are the same\ndiag1_char = grid[0][0]\ndiag2_char = grid[0][n-1]\n\nfor i in range(n):\n    if grid[i][i] != diag1_char or grid[i][n-1-i] != diag2_char:\n        print(\"NO\")\n        exit()\n\n# Check if all non-diagonal characters are the same and different from diagonal characters\nother_char = grid[0][1]\nfor i in range(n):\n    for j in range(n):\n        if i == j or i + j == n - 1:\n            continue\n        if grid[i][j] != other_char:\n            print(\"NO\")\n            exit()\n\n# Check if other_char is different from diagonal characters\nif other_char == diag1_char or other_char == diag2_char:\n    print(\"NO\")\nelse:\n    print(\"YES\")"}
{"task_id": "E2H_CF492B", "completion": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    l = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    a.sort()\n    \n    max_gap = 0\n    prev = 0\n    \n    for pos in a:\n        gap = pos - prev\n        if gap > max_gap:\n            max_gap = gap\n        prev = pos\n    \n    # Check the gap between last lantern and end of street\n    if l - prev > max_gap:\n        max_gap = l - prev\n    \n    print(\"{0:.10f}\".format(max_gap))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF173A", "completion": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    A = data[1]\n    B = data[2]\n    \n    m = len(A)\n    k = len(B)\n    \n    # Precompute the results for one full cycle of A and B\n    results = []\n    for i in range(m):\n        for j in range(k):\n            a = A[i]\n            b = B[j]\n            if a == b:\n                results.append((0, 0))  # Draw\n            elif (a == 'R' and b == 'S') or (a == 'S' and b == 'P') or (a == 'P' and b == 'R'):\n                results.append((0, 1))  # B wins\n            else:\n                results.append((1, 0))  # A wins\n    \n    # Number of full cycles and remaining rounds\n    total_rounds = len(results)\n    full_cycles = n // total_rounds\n    remainder = n % total_rounds\n    \n    # Count red spots from full cycles\n    red_a = full_cycles * sum(1 for x in results if x[0] == 1)\n    red_b = full_cycles * sum(1 for x in results if x[1] == 1)\n    \n    # Count red spots from remaining rounds\n    for i in range(remainder):\n        a = A[i % m]\n        b = B[i % k]\n        if a == b:\n            continue\n        elif (a == 'R' and b == 'S') or (a == 'S' and b == 'P') or (a == 'P' and b == 'R'):\n            red_b += 1\n        else:\n            red_a += 1\n    \n    print(red_a, red_b)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1141D", "completion": "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    l = data[1]\n    r = data[2]\n\n    left_counts = defaultdict(int)\n    right_counts = defaultdict(int)\n\n    for i in range(n):\n        left_counts[l[i]] += 1\n        right_counts[r[i]] += 1\n\n    result = []\n    used_left = [False] * n\n    used_right = [False] * n\n\n    # Process '?' in left and right\n    for i in range(n):\n        if l[i] == '?':\n            left_counts['?'] += 1\n            left_counts[l[i]] -= 1\n        if r[i] == '?':\n            right_counts['?'] += 1\n            right_counts[r[i]] -= 1\n\n    # Match specific colors\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        count_l = left_counts[c]\n        count_r = right_counts[c]\n        min_count = min(count_l, count_r)\n        for _ in range(min_count):\n            # Find first unused left and right with color c\n            for i in range(n):\n                if not used_left[i] and l[i] == c:\n                    for j in range(n):\n                        if not used_right[j] and r[j] == c:\n                            result.append((i + 1, j + 1))\n                            used_left[i] = True\n                            used_right[j] = True\n                            break\n                    break\n\n    # Match '?'\n    left_q = [i for i in range(n) if l[i] == '?']\n    right_q = [i for i in range(n) if r[i] == '?']\n\n    for i in range(len(left_q)):\n        for j in range(len(right_q)):\n            if not used_left[left_q[i]] and not used_right[right_q[j]]:\n                result.append((left_q[i] + 1, right_q[j] + 1))\n                used_left[left_q[i]] = True\n                used_right[right_q[j]] = True\n                break\n\n    print(len(result))\n    for a, b in result:\n        print(a, b)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF822C", "completion": "import sys\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    \n    for _ in range(n):\n        l = int(data[index])\n        r = int(data[index + 1])\n        cost = int(data[index + 2])\n        vouchers.append((l, r, cost))\n        index += 3\n    \n    min_total_cost = float('inf')\n    \n    # Group vouchers by their duration\n    from collections import defaultdict\n    duration_map = defaultdict(list)\n    \n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        duration_map[duration].append((l, r, cost))\n    \n    # For each duration d, check if x - d is also present\n    for d in duration_map:\n        if (x - d) not in duration_map:\n            continue\n        \n        # Get all vouchers with duration d and x - d\n        list_d = duration_map[d]\n        list_xd = duration_map[x - d]\n        \n        # Sort list_d by end time\n        list_d.sort(key=lambda x: x[1])\n        # Sort list_xd by start time\n        list_xd.sort(key=lambda x: x[0])\n        \n        # Use two pointers to find non-overlapping pairs\n        i = 0\n        j = 0\n        len_d = len(list_d)\n        len_xd = len(list_xd)\n        \n        while i < len_d and j < len_xd:\n            l1, r1, cost1 = list_d[i]\n            l2, r2, cost2 = list_xd[j]\n            \n            if r1 < l2:\n                # Vouchers do not overlap, update min_total_cost\n                min_total_cost = min(min_total_cost, cost1 + cost2)\n                i += 1\n            elif r2 < l1:\n                # Vouchers do not overlap, update min_total_cost\n                min_total_cost = min(min_total_cost, cost1 + cost2)\n                j += 1\n            else:\n                # Overlap, move the one that ends earlier\n                if r1 < r2:\n                    i += 1\n                else:\n                    j += 1\n    \n    print(min_total_cost if min_total_cost != float('inf') else -1)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1846E2", "completion": "import sys\n\ndef is_snowflake(n):\n    if n < 2:\n        return False\n    # Try all possible k > 1 such that the snowflake can be formed\n    # The number of vertices in a snowflake with parameter k after m steps is:\n    # 1 + k + k^2 + ... + k^m = (k^(m+1) - 1) / (k - 1)\n    # We need to find if there exists k > 1 and m >= 1 such that this sum equals n\n    # So we iterate over possible k from 2 to some upper bound\n    # Since (k^m - 1)/(k - 1) <= n, we can estimate the upper bound for k\n    # For example, for k=2, the maximum m such that 2^m - 1 <= n is log2(n+1)\n    # So we try k from 2 to around sqrt(n)\n    for k in range(2, int(n**0.5) + 2):\n        total = 1  # initial vertex\n        current = k\n        while current <= n:\n            total += current\n            if total == n:\n                return True\n            if total > n:\n                break\n            current *= k\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n = int(data[i])\n        if is_snowflake(n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF270E", "completion": "import sys\nimport heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    edges = []\n    for _ in range(m):\n        a = int(data[idx])\n        idx += 1\n        b = int(data[idx])\n        idx += 1\n        c = int(data[idx])\n        idx += 1\n        edges.append((a, b, c))\n    \n    # Build adjacency list with flow and index\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b, c = edges[i]\n        adj[a].append((b, c, i))\n        adj[b].append((a, c, i))\n    \n    # BFS to assign directions\n    from collections import deque\n    visited = [False] * (n + 1)\n    parent = [0] * (n + 1)\n    direction = [0] * m\n    \n    q = deque()\n    q.append(1)\n    visited[1] = True\n    \n    while q:\n        u = q.popleft()\n        for v, c, i in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                parent[v] = u\n                q.append(v)\n    \n    # Assign directions based on parent\n    for i in range(m):\n        a, b, c = edges[i]\n        if parent[b] == a:\n            direction[i] = 0  # a -> b\n        elif parent[a] == b:\n            direction[i] = 1  # b -> a\n        else:\n            # This edge is not part of the BFS tree, so we need to assign it arbitrarily\n            # We can use a DFS or another method to ensure no cycles\n            pass\n    \n    # Now, we need to assign directions to remaining edges to avoid cycles\n    # We'll do this using a DFS to assign directions in a way that avoids cycles\n    \n    visited = [False] * (n + 1)\n    stack = [(1, -1)]  # (node, parent)\n    while stack:\n        u, p = stack.pop()\n        if visited[u]:\n            continue\n        visited[u] = True\n        for v, c, i in adj[u]:\n            if v == p:\n                continue\n            if not visited[v]:\n                stack.append((v, u))\n                if parent[v] == u:\n                    direction[i] = 0\n                elif parent[u] == v:\n                    direction[i] = 1\n                else:\n                    # Edge is not part of the BFS tree, assign arbitrarily\n                    # For simplicity, we can assign based on which node has higher number\n                    if u < v:\n                        direction[i] = 0\n                    else:\n                        direction[i] = 1\n            else:\n                # Already visited, assign direction based on parent\n                if parent[v] == u:\n                    direction[i] = 0\n                elif parent[u] == v:\n                    direction[i] = 1\n                else:\n                    if u < v:\n                        direction[i] = 0\n                    else:\n                        direction[i] = 1\n    \n    for d in direction:\n        print(d)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF808E", "completion": "import sys\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    items = []\n    idx = 2\n    for _ in range(n):\n        w = int(data[idx])\n        c = int(data[idx + 1])\n        items.append((w, c))\n        idx += 2\n    \n    # Group items by weight\n    from collections import defaultdict\n    weight_groups = defaultdict(list)\n    for w, c in items:\n        weight_groups[w].append(c)\n    \n    # Sort each group and compute prefix sums\n    dp = [0] * (m + 1)\n    \n    for w in sorted(weight_groups.keys()):\n        costs = weight_groups[w]\n        costs.sort(reverse=True)\n        prefix = [0] * (len(costs) + 1)\n        for i in range(len(costs)):\n            prefix[i + 1] = prefix[i] + costs[i]\n        \n        # Update dp array\n        for j in range(m, w - 1, -1):\n            for k in range(1, len(prefix) + 1):\n                if j - k * w >= 0:\n                    dp[j] = max(dp[j], dp[j - k * w] + prefix[k])\n    \n    print(dp[m])\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF409I", "completion": "import sys\nimport re\n\ndef parse_golorp(name):\n    # Extract the pattern from the name\n    pattern = re.search(r'\\?([^:]+):([^,]+)', name).groups()\n    jaws_pattern, stomach_pattern = pattern\n    \n    # Parse jaws pattern\n    jaws = []\n    i = 0\n    while i < len(jaws_pattern):\n        if jaws_pattern[i] == '(':\n            j = i + 1\n            count = 0\n            while j < len(jaws_pattern) and jaws_pattern[j] != ')':\n                if jaws_pattern[j] == '_':\n                    count += 1\n                j += 1\n            jaws.append(count)\n            i = j + 1\n        else:\n            i += 1\n    \n    # Parse stomach pattern\n    stomach = []\n    i = 0\n    while i < len(stomach_pattern):\n        if stomach_pattern[i] == '_':\n            j = i + 1\n            count = 0\n            while j < len(stomach_pattern) and stomach_pattern[j] == '_':\n                count += 1\n                j += 1\n            stomach.append(count)\n            i = j\n        else:\n            i += 1\n    \n    return jaws, stomach\n\ndef is_valid_sequence(jaws, sequence):\n    # Check if the sequence matches the jaws pattern\n    idx = 0\n    for count in jaws:\n        if idx + count > len(sequence):\n            return False\n        idx += count\n    return True\n\ndef find_lex_smallest(jaws, stomach):\n    # Find the lexicographically smallest sequence of digits that fits\n    # We use BFS to explore the smallest sequences first\n    from collections import deque\n    \n    # Initialize with empty string\n    queue = deque([''])\n    visited = set()\n    \n    while queue:\n        seq = queue.popleft()\n        if len(seq) > max(len(jaws), len(stomach)):\n            continue\n        \n        # Check if sequence matches jaws pattern\n        if not is_valid_sequence(jaws, seq):\n            continue\n        \n        # Check if we have enough characters for stomach\n        if len(seq) < sum(stomach):\n            continue\n        \n        # Try to build the sequence by adding digits\n        for digit in range(10):\n            new_seq = seq + str(digit)\n            if new_seq not in visited:\n                visited.add(new_seq)\n                queue.append(new_seq)\n        \n        # If we have a valid sequence of required length, return it\n        if len(seq) == sum(jaws) and is_valid_sequence(jaws, seq):\n            return seq\n    \n    return 'false'\n\ndef main():\n    input_str = sys.stdin.read().strip()\n    result = find_lex_smallest(*parse_golorp(input_str))\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF151A", "completion": "# Read input\nn, k, l, c, d, p, nl, np = map(int, input().split())\n\n# Calculate total drink, lime slices, and salt\ntotal_drink = k * l\ntotal_lime_slices = c * d\ntotal_salt = p\n\n# Calculate how many toasts can be made based on each resource\ntoasts_by_drink = total_drink // nl\ntoasts_by_lime = total_lime_slices // n\ntoasts_by_salt = total_salt // np\n\n# The answer is the minimum of these values\nprint(min(toasts_by_drink, toasts_by_lime, toasts_by_salt))"}
{"task_id": "E2H_CF339B", "completion": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2 + m]))\n    \n    current = 1\n    time = 0\n    \n    for task in a:\n        if task > current:\n            time += task - current\n        else:\n            time += (n - current + task)\n        current = task\n    \n    print(time)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF88A", "completion": "import sys\n\ndef note_to_index(note):\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    return notes.index(note)\n\ndef is_major(notes):\n    indices = [note_to_index(note) for note in notes]\n    for i in range(3):\n        x, y, z = indices[i], indices[(i+1)%3], indices[(i+2)%3]\n        dist_xy = (y - x) % 12\n        dist_yz = (z - y) % 12\n        if dist_xy == 4 and dist_yz == 3:\n            return True\n    return False\n\ndef is_minor(notes):\n    indices = [note_to_index(note) for note in notes]\n    for i in range(3):\n        x, y, z = indices[i], indices[(i+1)%3], indices[(i+2)%3]\n        dist_xy = (y - x) % 12\n        dist_yz = (z - y) % 12\n        if dist_xy == 3 and dist_yz == 4:\n            return True\n    return False\n\ndef classify_chord(notes):\n    if is_major(notes):\n        return \"major\"\n    elif is_minor(notes):\n        return \"minor\"\n    else:\n        return \"strange\"\n\ndef main():\n    notes = sys.stdin.read().strip().split()\n    print(classify_chord(notes))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF633B", "completion": "import sys\n\ndef count_trailing_zeros(n):\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n\ndef find_n_for_m_zeros(m):\n    low = 0\n    high = 5 * m\n    result = []\n    \n    while low <= high:\n        mid = (low + high) // 2\n        zeros = count_trailing_zeros(mid)\n        if zeros < m:\n            low = mid + 1\n        elif zeros > m:\n            high = mid - 1\n        else:\n            # Find the first occurrence of m zeros\n            first = mid\n            while first > 0 and count_trailing_zeros(first) == m:\n                first -= 1\n            first += 1\n            # Find the last occurrence of m zeros\n            last = mid\n            while last > 0 and count_trailing_zeros(last) == m:\n                last += 1\n            last -= 1\n            result = list(range(first, last + 1))\n            break\n    \n    return result\n\ndef main():\n    m = int(sys.stdin.readline())\n    result = find_n_for_m_zeros(m)\n    print(len(result))\n    if result:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1767D", "completion": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    s = data[1]\n    \n    total_teams = 1 << n  # 2^n\n    \n    # Initialize the range of possible skill levels\n    min_skill = 1\n    max_skill = total_teams\n    \n    for i in range(n):\n        phase = n - i - 1  # 0-based phase index\n        if s[i] == '0':\n            # In this phase, lower skill wins\n            # So the winner is the minimum of the current range\n            min_skill = min(min_skill, max_skill)\n        else:\n            # In this phase, higher skill wins\n            # So the winner is the maximum of the current range\n            max_skill = max(min_skill, max_skill)\n    \n    # All x from min_skill to max_skill inclusive are winning integers\n    result = list(range(min_skill, max_skill + 1))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF498A", "completion": "import sys\nimport math\nfrom collections import deque\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef cross(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\ndef line_intersection(line1, line2):\n    a1, b1, c1 = line1\n    a2, b2, c2 = line2\n    det = a1 * b2 - a2 * b1\n    if det == 0:\n        return None\n    x = (b1 * c2 - b2 * c1) / det\n    y = (a2 * c1 - a1 * c2) / det\n    return (x, y)\n\ndef is_point_on_line(x, y, a, b, c):\n    return abs(a * x + b * y + c) < 1e-8\n\ndef get_neighbors(point, lines):\n    x, y = point\n    neighbors = []\n    for i in range(len(lines)):\n        for j in range(i + 1, len(lines)):\n            line1 = lines[i]\n            line2 = lines[j]\n            inter = line_intersection(line1, line2)\n            if inter is not None:\n                if not is_point_on_line(x, y, line1[0], line1[1], line1[2]):\n                    if not is_point_on_line(x, y, line2[0], line2[1], line2[2]):\n                        neighbors.append(inter)\n    return neighbors\n\ndef bfs(start, end, lines):\n    visited = set()\n    queue = deque()\n    queue.append((start, 0))\n    visited.add(start)\n    \n    while queue:\n        point, steps = queue.popleft()\n        if point == end:\n            return steps\n        for neighbor in get_neighbors(point, lines):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, steps + 1))\n    return -1\n\ndef main():\n    x1, y1 = readints()\n    x2, y2 = readints()\n    n = int(sys.stdin.readline())\n    lines = []\n    for _ in range(n):\n        a, b, c = map(int, sys.stdin.readline().split())\n        lines.append((a, b, c))\n    \n    start = (x1, y1)\n    end = (x2, y2)\n    \n    print(bfs(start, end, lines))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1092C", "completion": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    strings = [sys.stdin.readline().strip() for _ in range(2 * n - 2)]\n\n    # Group strings by their length\n    from collections import defaultdict\n    length_map = defaultdict(list)\n    for s in strings:\n        length_map[len(s)].append(s)\n\n    # Try all possible combinations of prefixes and suffixes\n    from itertools import product\n\n    # For each length, we need to choose one string as prefix and the other as suffix\n    for prefix_candidate in length_map[1]:\n        for suffix_candidate in length_map[1]:\n            if prefix_candidate == suffix_candidate:\n                continue\n            # Assume prefix_candidate is prefix and suffix_candidate is suffix\n            # Build the full string s\n            s = prefix_candidate + suffix_candidate[-(n - len(prefix_candidate)):]\n            # Check if all given strings are either prefix or suffix of s\n            valid = True\n            for idx, s_str in enumerate(strings):\n                if s_str in [s[:i] for i in range(1, n)]:\n                    result[idx] = 'P'\n                elif s_str in [s[i:] for i in range(1, n)]:\n                    result[idx] = 'S'\n                else:\n                    valid = False\n                    break\n            if valid:\n                print(''.join(result))\n                return\n\n    # If no combination works (should not happen due to problem statement)\n    print('P' * (2 * n - 2))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1146D", "completion": "import sys\nimport math\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    m, a, b = map(int, input().split())\n\n    # If a == b, then the frog can only jump to 0 or a (if a <= m)\n    if a == b:\n        if a > m:\n            # Can't make any jumps\n            total = m + 1\n        else:\n            # Can reach 0 and a, so f(i) = i + 1 for all i\n            total = (m + 1) * (m + 2) // 2\n        print(total)\n        return\n\n    # Compute gcd of a and b\n    g = math.gcd(a, b)\n\n    # The reachable positions are multiples of g within [0, m]\n    # So the number of reachable positions is floor(m / g) + 1\n    count = (m // g) + 1\n\n    # Sum of f(i) from i=0 to m is sum_{i=0}^m (floor(i / g) + 1)\n    # This is equivalent to sum_{k=0}^{floor(m/g)} (k + 1) * (number of i where floor(i/g) = k)\n    # For each k, there are g values of i (from kg to (k+1)g - 1), except possibly the last one\n    total = 0\n    max_k = m // g\n    for k in range(max_k + 1):\n        # Number of i such that floor(i/g) = k is min(g, m - k*g + 1)\n        num_i = min(g, m - k * g + 1)\n        total += (k + 1) * num_i\n\n    print(total)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF980E", "completion": "import sys\nimport heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    k = int(data[idx + 1])\n    idx += 2\n    \n    edges = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a = int(data[idx])\n        b = int(data[idx + 1])\n        edges[a].append(b)\n        edges[b].append(a)\n        idx += 2\n    \n    # We want to keep districts with higher values (since 2^i is higher for larger i)\n    # So we will remove the smallest k districts that are not on the path from the largest district to others\n    # Use a max-heap to select the largest districts first\n    \n    # First, find the largest district\n    max_district = n\n    visited = [False] * (n + 1)\n    \n    # Perform DFS from the largest district to mark all reachable districts\n    stack = [max_district]\n    visited[max_district] = True\n    while stack:\n        u = stack.pop()\n        for v in edges[u]:\n            if not visited[v]:\n                visited[v] = True\n                stack.append(v)\n    \n    # Collect all districts not visited (to be removed)\n    to_remove = []\n    for i in range(1, n + 1):\n        if not visited[i]:\n            to_remove.append(i)\n    \n    # Sort and print the result\n    to_remove.sort()\n    print(' '.join(map(str, to_remove[:k])))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1709F", "completion": "import sys\nimport itertools\nimport math\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    n, k, f = map(int, data)\n    \n    # Precompute powers of 2 up to n\n    pow2 = [1] * (n + 1)\n    for i in range(1, n + 1):\n        pow2[i] = (pow2[i - 1] * 2) % MOD\n    \n    # dp[i][j] = number of ways to assign c_s for strings of length <= i such that the maximum size is j\n    dp = [[0] * (f + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for length in range(1, n + 1):\n        new_dp = [0] * (f + 1)\n        for prev_max in range(f + 1):\n            if dp[length - 1][prev_max] == 0:\n                continue\n            # For each string of length 'length', we can choose c_s from 0 to k\n            # The max possible size of the multiset is limited by the minimum c_s among all prefixes\n            # So the maximum size of the multiset is at most the minimum c_s among all prefixes\n            # We need to ensure that the maximum size is exactly f\n            # So for each choice of c_s for the current string, we check if it's compatible with the previous constraints\n            \n            # For the current string, the number of strings in the multiset with this string as a prefix is at most c_s\n            # But since we are choosing c_s for all strings of length <= n, we need to ensure that the constraints are consistent\n            # To simplify, we consider that the maximum size of the multiset is determined by the minimal c_s among all prefixes\n            # So the maximum size is the minimal c_s among all prefixes of the current string and all previous ones\n            \n            # To compute the number of valid ways, we iterate over all possible values of c_s for the current string\n            # and update the dp accordingly\n            \n            # For the current string, the maximum possible size of the multiset is the minimum between the previous max and c_s\n            # So for each possible value of c_s (from 0 to k), we update the new_dp accordingly\n            for c in range(0, k + 1):\n                new_max = min(prev_max, c)\n                if new_max > f:\n                    continue\n                new_dp[new_max] = (new_dp[new_max] + dp[length - 1][prev_max]) % MOD\n        dp[length] = new_dp\n    \n    # The answer is the number of ways to assign c_s such that the maximum size is exactly f\n    print(dp[n][f] % MOD)\n\nif __name__ == \"__main__\":\n    main()"}
