{"task_id": "E2H_CF1031A", "completion": "def golden_plate():\n    w, h, k = map(int, input().split())\n    result = 0\n\n    for i in range(1, k + 1):\n        width = w - 4 * (i - 1)\n        height = h - 4 * (i - 1)\n        if width > 0 and height > 0:\n            result += 2 * ((width + height) - 4)\n\n    print(result)\n\nif __name__ == \"__main__\":\n    for _ in range(int(input())):\n        golden_plate()"}
{"task_id": "E2H_CF404A", "completion": "def check_x(n, grid):\n    # Check if the letters on the diagonals are the same\n    diagonal_letter = grid[0][0]\n    for i in range(n):\n        if grid[i][i] != diagonal_letter:\n            return False\n        if grid[i][n - i - 1] != diagonal_letter:\n            return False\n\n    # Check if the letters on the rest of the grid are the same and different from the diagonal letter\n    for i in range(1, n):\n        for j in range(n):\n            if (i != 0 or j != 0) and grid[i][j] != diagonal_letter:\n                return False\n\n    return True\n\n\ndef main():\n    n = int(input())\n    grid = []\n    for _ in range(n):\n        grid.append(input())\n\n    result = 'YES' if check_x(n, grid) else 'NO'\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF492B", "completion": "import sys\n\ndef read_input():\n    n, l = map(int, input().split())\n    a = list(map(int, input().split()))\n    return n, l, a\n\ndef solve(n, l, a):\n    a.sort()\n    max_d = 0\n    for i in range(1, n):\n        max_d = max(max_d, (a[i] - a[i-1]) // 2)\n    if a[0] != 0:\n        max_d = max(max_d, a[0])\n    if a[-1] != l:\n        max_d = max(max_d, l - a[-1])\n    return max_d\n\ndef main():\n    t = 1  # int(input())\n    for _ in range(t):\n        n, l, a = read_input()\n        print(f\"{solve(n, l, a):.10f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF173A", "completion": "from math import gcd\n\ndef lcm(a, b):\n    \"\"\"Compute the lowest common multiple of a and b\"\"\"\n    return a * b // gcd(a, b)\n\ndef solve():\n    n = int(input())\n    m = len(input())\n    k = len(input())\n\n    # Find the GCD of m and k to determine the cycle length\n    cycle_length = gcd(m, k)\n\n    # Initialize counters for red spots\n    nikephoros_spots = 0\n    polycarpus_spots = 0\n\n    # Iterate over the game rounds\n    for i in range(1, n + 1):\n        # Calculate the index within the cycle for both players\n        nikephoros_index = (i - 1) % cycle_length\n        polycarpus_index = ((i - 1) % cycle_length + k - m) % cycle_length\n\n        # Determine the winner of the round\n        if m > k:\n            if input()[nikephoros_index] == 'R' and input()[polycarpus_index] == 'S':\n                nikephoros_spots += 1\n            elif input()[nikephoros_index] == 'S' and input()[polycarpus_index] == 'P':\n                nikephoros_spots += 1\n            elif input()[nikephoros_index] == 'P' and input()[polycarpus_index] == 'R':\n                nikephoros_spots += 1\n        else:\n            if input()[nikephoros_index] == 'R' and input()[polycarpus_index] == 'S':\n                polycarpus_spots += 1\n            elif input()[nikephoros_index] == 'S' and input()[polycarpus_index] == 'P':\n                polycarpus_spots += 1\n            elif input()[nikephoros_index] == 'P' and input()[polycarpus_index] == 'R':\n                polycarpus_spots += 1\n\n    # Print the final counts of red spots\n    print(nikephoros_spots, polycarpus_spots)\n\n# Read input and solve the problem\nsolve()"}
{"task_id": "E2H_CF1141D", "completion": "from sys import stdin, stdout\n\ndef solve():\n    n = int(stdin.readline())\n    l = stdin.readline().strip()\n    r = stdin.readline().strip()\n\n    left = {}\n    right = {}\n\n    for i in range(n):\n        if l[i] != '?' and r[i] != '?':\n            if l[i] not in left or right[l[i]] < right[r[i]]:\n                left[l[i]] = (r[i], i + 1)\n                right[r[i]] = i + 1\n        elif l[i] == '?' and r[i] != '?':\n            right[r[i]] = i + 1\n        elif l[i] != '?' and r[i] == '?':\n            left[l[i]] = (r[i], i + 1)\n\n    pairs = []\n    for key in sorted(left.keys()):\n        val = left[key]\n        if val[0] in right:\n            pairs.append((val[1], right[val[0]]))\n            del right[val[0]]\n\n    for key in sorted(right.keys()):\n        val = right[key]\n        pairs.append((key, val))\n\n    stdout.write(str(len(pairs)) + '\\n')\n    for pair in pairs:\n        stdout.write(str(pair[0]) + ' ' + str(pair[1]) + '\\n')\n\nif __name__ == \"__main__\":\n    solve()"}
{"task_id": "E2H_CF822C", "completion": "import sys\n\ndef read_input():\n    n, x = map(int, input().split())\n    vouchers = []\n    for _ in range(n):\n        li, ri, costi = map(int, input().split())\n        vouchers.append((li, ri, costi))\n    return n, x, vouchers\n\ndef solve(n, x, vouchers):\n    vouchers.sort(key=lambda x: x[2])\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if vouchers[i][0] > vouchers[j][1] or vouchers[j][0] > vouchers[i][1]:\n                continue\n            if vouchers[i][1] - vouchers[i][0] + 1 + vouchers[j][1] - vouchers[j][0] + 1 == x:\n                min_cost = min(min_cost, vouchers[i][2] + vouchers[j][2])\n    return -1 if min_cost == float('inf') else min_cost\n\ndef main():\n    n, x, vouchers = read_input()\n    result = solve(n, x, vouchers)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1846E2", "completion": "def is_power_of_two(n):\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        k = 2\n        while k < 1000000000000000000 and k * 2 <= n:\n            a = k + 1\n            b = k * 2 + 1\n            c = k * 2 + 2\n            d = k * 3 + 3\n            e = k * 4 + 4\n            f = k * 5 + 5\n            g = k * 6 + 6\n            h = k * 7 + 7\n            i = k * 8 + 8\n            j = k * 9 + 9\n            l = k * 10 + 10\n            m = k * 11 + 11\n            o = k * 12 + 12\n            p = k * 13 + 13\n            q = k * 14 + 14\n            r = k * 15 + 15\n            s = k * 16 + 16\n            u = k * 17 + 17\n            v = k * 18 + 18\n            w = k * 19 + 19\n            x = k * 20 + 20\n            y = k * 21 + 21\n            z = k * 22 + 22\n            if n == k or n == a or n == b or n == c or n == d or n == e or n == f or n == g or n == h or n == i or n == j or n == l or n == m or n == o or n == p or n == q or n == r or n == s or n == u or n == v or n == w or n == x or n == y or n == z:\n                print(\"YES\")\n                break\n            elif n % k == 0 and is_power_of_two(n // k):\n                print(\"YES\")\n                break\n            k += 1\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF270E", "completion": "from sys import stdin, stdout\n\ndef dfs(u, parent, graph, edges):\n    global visited\n    global direction\n    visited[u] = True\n    for v in range(len(graph[u])):\n        if graph[u][v] > 0:\n            if not visited[v]:\n                dfs(v, u, graph, edges)\n            elif v != parent:\n                if graph[u][v] < graph[v][u]:\n                    direction[edges[(u-1)*n + v]] = 1\n                else:\n                    direction[edges[(u-1)*n + v]] = 0\n\nn, m = map(int, stdin.readline().split())\ngraph = [[0]*(n+1) for _ in range(n+1)]\nedges = []\ndirection = [0]*m\nvisited = [False]*(n+1)\n\nfor i in range(m):\n    a, b, c = map(int, stdin.readline().split())\n    graph[a][b] += c\n    graph[b][a] += c\n    edges.append(i)\n\ndfs(1, -1, graph, edges)\n\nfor i in range(m):\n    stdout.write(str(direction[i]) + '\\n')"}
{"task_id": "E2H_CF808E", "completion": "import sys\n\ndef solve():\n    n, m = map(int, input().split())\n    items = []\n    for _ in range(n):\n        w, c = map(int, input().split())\n        items.append((w, c))\n\n    dp = [[0] * (m + 1) for _ in range(4)]\n    for w, c in sorted(items, key=lambda x: x[1], reverse=True):\n        for i in range(3, 0, -1):\n            if w + i <= m:\n                dp[i][w + i] = max(dp[i][w + i], dp[i][w] + c)\n                for j in range(w + i - 1, -1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i][j + 1])\n                for j in range(i - 1, 0, -1):\n                    dp[j][w + i] = max(dp[j][w + i], dp[j][w] + c)\n                    for k in range(w + i - 1, w - 1, -1):\n                        dp[j][k] = max(dp[j][k], dp[j][k + 1])\n\n    ans = 0\n    for i in range(1, 4):\n        for j in range(m + 1):\n            ans = max(ans, dp[i][j])\n    print(ans)\n\nif __name__ == \"__main__\":\n    t = 1\n    while t > 0:\n        solve()\n        t -= 1"}
{"task_id": "E2H_CF409I", "completion": "import sys\n\ndef read():\n    return sys.stdin.readline().strip()\n\ndef get_min_seq(s):\n    s = s.replace(\"(\", \"0\").replace(\")\", \"0\").replace(\"_\", \"0\")\n    n = len(s)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    last = 0\n    for i in range(n):\n        if s[i] == '-':\n            last = -1\n        elif s[i] == '+':\n            last = 1\n        else:\n            last = 0\n        for j in range(i, -1, -1):\n            if s[j] == '>' and dp[j] < float('inf') and dp[j+1] < float('inf'):\n                dp[j+1] = min(dp[j+1], dp[j] + last)\n            elif s[j] == '<' and dp[j] < float('inf') and dp[j-1] < float('inf'):\n                dp[j-1] = min(dp[j-1], dp[j] + last)\n            elif s[j] == '_' and dp[j] < float('inf') and dp[j+1] < float('inf') and dp[j-1] < float('inf'):\n                dp[j-1] = min(dp[j-1], dp[j] + last)\n                dp[j+1] = min(dp[j+1], dp[j] + last)\n    if dp[-1] == float('inf'):\n        return 'false'\n    res = ''\n    i = n - 1\n    while i >= 0:\n        if s[i] == '_':\n            res = '0' + res\n            i -= 1\n        elif s[i] == '<':\n            res = '0' + res\n            i -= 1\n        elif s[i] == '>':\n            res = '0' + res\n            i -= 1\n        else:\n            res = str(abs(int(res) + last)) + res\n            last = 0\n            i -= 1\n    return res\n\nt = 1\nfor _ in range(t):\n    s = read()\n    print(get_min_seq(s))"}
{"task_id": "E2H_CF151A", "completion": "def soft_drinking():\n    # Read input from standard input\n    n, k, l, c, d, p, nl, np = map(int, input().split())\n\n    # Calculate the total amount of drink, limes, and salt\n    total_drink = k * l\n    total_limes = c * d\n    total_salt = p\n\n    # Calculate the number of toasts each friend can make\n    toasts_drink = total_drink // (n * nl)\n    toasts_limes = total_limes // n\n    toasts_salt = total_salt // (n * np)\n\n    # Return the minimum number of toasts each friend can make\n    return min(toasts_drink, toasts_limes, toasts_salt)\n\n\nif __name__ == \"__main__\":\n    # Test the function with the provided examples\n    test_cases = [\n        ['3 4 5 10 8 100 3 1'],\n        ['5 100 10 1 19 90 4 3'],\n        ['10 1000 1000 25 23 1 50 1']\n    ]\n\n    for test_case in test_cases:\n        print(soft_drinking())"}
{"task_id": "E2H_CF339B", "completion": "import sys\n\ndef xenia_and_ringroad():\n    n, m = map(int, input().split())\n    tasks = list(map(int, input().split()))\n\n    last_task = 0\n    time = 0\n    for task in tasks:\n        if task > last_task:\n            time += task - last_task\n        else:\n            time += (n - last_task) + task\n        last_task = task\n\n    return str(time)\n\nif __name__ == \"__main__\":\n    t = 1\n    for _ in range(t):\n        print(xenia_and_ringroad())"}
{"task_id": "E2H_CF88A", "completion": "from collections import defaultdict\n\ndef calculate_distance(note1, note2):\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    index1 = notes.index(note1)\n    index2 = notes.index(note2)\n    return (index2 - index1) % 12\n\ndef check_triad(notes):\n    for i in range(3):\n        for j in range(i+1, 3):\n            for k in range(j+1, 3):\n                distance1 = calculate_distance(notes[i], notes[j])\n                distance2 = calculate_distance(notes[j], notes[k])\n                if (distance1 == 4 and distance2 == 3) or (distance1 == 3 and distance2 == 4):\n                    return 'major'\n                elif (distance1 == 3 and distance2 == 4):\n                    return 'minor'\n    return 'strange'\n\ndef main():\n    notes = input().split()\n    print(check_triad(notes))\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF633B", "completion": "import sys\n\ndef solve(m):\n    count = 0\n    result = []\n    i = 5\n    while True:\n        if m == 0:\n            break\n        zeros = m // i\n        m -= zeros * i\n        count += zeros\n        i *= 5\n    for n in range(1, count + 1):\n        if m >= 5 ** n:\n            m -= 5 ** n\n            result.append(n)\n    return len(result), result\n\nm = int(input())\nk, result = solve(m)\nprint(k)\nif k > 0:\n    print(' '.join(map(str, result)))"}
{"task_id": "E2H_CF1767D", "completion": "def get_winning_numbers(n, s):\n    count_ones = sum(1 for c in s if c == '1')\n    low = 2 ** (n - count_ones)\n    high = 2 ** n - 2 ** count_ones + 1\n\n    winning_numbers = []\n    for i in range(low, high + 1):\n        winning_numbers.append(i)\n\n    return ' '.join(map(str, winning_numbers))\n\n\ndef main():\n    n = int(input())\n    s = input()\n    print(get_winning_numbers(n, s))\n\n\nif __name__ == \"__main__\":\n    t = 1\n    for _ in range(t):\n        main()"}
{"task_id": "E2H_CF498A", "completion": "from sys import stdin, stdout\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef main():\n    x1, y1 = map(int, stdin.readline().split())\n    x2, y2 = map(int, stdin.readline().split())\n    n = int(stdin.readline())\n\n    points = []\n    for _ in range(n):\n        a, b, c = map(int, stdin.readline().split())\n        points.append((a, b, c))\n\n    sgn_x1 = -1 if x1 < 0 else 1\n    sgn_y1 = -1 if y1 < 0 else 1\n    sgn_x2 = -1 if x2 < 0 else 1\n    sgn_y2 = -1 if y2 < 0 else 1\n\n    cnt = 0\n    for a, b, c in points:\n        if (sgn_x1 * a + sgn_y1 * b) * (sgn_x2 * a + sgn_y2 * b) > 0:\n            cnt += 1\n\n    stdout.write(str(cnt - 1) + '\\n')\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1092C", "completion": "from collections import defaultdict\n\ndef solve():\n    n = int(input())\n    prefix = defaultdict(list)\n    suffix = defaultdict(list)\n\n    for i in range(2*n-2):\n        s = input()\n        prefix[len(s)].append(s)\n        suffix[len(s)].append(s)\n\n    ans = ['P'] * (2*n - 2)\n    for i in range(1, n):\n        for s in prefix[i]:\n            if s in suffix[n-i]:\n                ans[prefix[i].index(s)] = 'S'\n                ans[suffix[n-i].index(s)] = 'S'\n\n    print(''.join(ans))\n\nt = 1\nfor _ in range(t):\n    solve()"}
{"task_id": "E2H_CF1146D", "completion": "from sys import stdin, stdout\n\ndef solve():\n    m, a, b = map(int, input().split())\n    ans = 0\n    for i in range(m + 1):\n        ans += max(0, min(i // a + 1, (i + b) // b + 1))\n    print(ans)\n\nif __name__ == \"__main__\":\n    t = 1\n    while t > 0:\n        solve()\n        t -= 1"}
{"task_id": "E2H_CF980E", "completion": "from collections import deque\n\ndef find_root(u, parent):\n    if parent[u] != u:\n        parent[u] = find_root(parent[u], parent)\n    return parent[u]\n\ndef main():\n    n, k = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    parent = [i for i in range(n + 1)]\n    size = [1] * (n + 1)\n\n    queue = deque()\n    for i in range(1, n + 1):\n        if len(graph[i]) == 1:\n            queue.append(i)\n\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if find_root(u, parent) != find_root(v, parent):\n                parent[find_root(v, parent)] = find_root(u, parent)\n                size[find_root(u, parent)] += size[find_root(v, parent)]\n                queue.append(v)\n\n    root_to_node = {}\n    for i in range(1, n + 1):\n        root = find_root(i, parent)\n        if root not in root_to_node:\n            root_to_node[root] = []\n        root_to_node[root].append(i)\n\n    max_size = 0\n    max_root = 0\n    for root, nodes in root_to_node.items():\n        total_size = sum(size[node] for node in nodes)\n        if total_size > max_size:\n            max_size = total_size\n            max_root = root\n\n    result = []\n    for i in range(1, n + 1):\n        if find_root(i, parent) != max_root:\n            result.append(i)\n\n    print(*sorted(result)[:k])\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "E2H_CF1709F", "completion": "import sys\ninput = sys.stdin.readline\n\ndef read_int():\n    return int(input())\n\ndef read_ints():\n    return map(int, input().split())\n\nMOD = 998244353\n\ndef solve():\n    n, k, f = read_ints()\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            for c in range(min(j + 1, k + 1)):\n                dp[i][j] += dp[i - 1][c]\n                dp[i][j] %= MOD\n    ans = 0\n    for j in range(f, min(f + 1, k + 1)):\n        for c in range(min(j + 1, k + 1)):\n            ans += dp[n][c] * (k - c + 1) ** (f - j)\n            ans %= MOD\n    print(ans)\n\nif __name__ == '__main__':\n    t = 1\n    while t:\n        solve()\n        t -= 1"}
