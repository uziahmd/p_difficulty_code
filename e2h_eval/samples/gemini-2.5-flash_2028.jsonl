{"task_id": "E2H_CF1031A", "completion": "def solve():\n    w, h, k = map(int, input().split())\n\n    total_gilded_cells = 0\n\n    for i in range(k):\n        current_w = w - 4 * i\n        current_h = h - 4 * i\n\n        if current_w <= 0 or current_h <= 0:\n            break\n\n        # Calculate the perimeter of the current rectangle\n        # A rectangle of size current_w x current_h has a perimeter of 2 * (current_w + current_h - 2)\n        # if current_w and current_h are both > 1.\n        # If current_w = 1 and current_h > 1, it's current_h cells.\n        # If current_h = 1 and current_w > 1, it's current_w cells.\n        # If current_w = 1 and current_h = 1, it's 1 cell.\n        \n        if current_w == 1 and current_h == 1:\n            gilded_cells_in_ring = 1\n        elif current_w == 1:\n            gilded_cells_in_ring = current_h\n        elif current_h == 1:\n            gilded_cells_in_ring = current_w\n        else:\n            gilded_cells_in_ring = 2 * (current_w + current_h) - 4\n        \n        total_gilded_cells += gilded_cells_in_ring\n\n    print(total_gilded_cells)\n\nif __name__ == '__main__':\n    solve()"}
{"task_id": "E2H_CF404A", "completion": "def solve():\n    n = int(input())\n    grid = [input() for _ in range(n)]\n\n    if n < 3 or n % 2 == 0:\n        print(\"NO\")\n        return\n\n    diag_char = grid[0][0]\n    other_char = ''\n    \n    # Check if all diagonal characters are the same\n    # And simultaneously find the 'other' character\n    for i in range(n):\n        # Main diagonal\n        if grid[i][i] != diag_char:\n            print(\"NO\")\n            return\n        \n        # Anti-diagonal\n        if grid[i][n - 1 - i] != diag_char:\n            print(\"NO\")\n            return\n\n    # Check all other squares\n    for r in range(n):\n        for c in range(n):\n            if r == c or r == n - 1 - c:  # On a diagonal\n                if grid[r][c] != diag_char:\n                    print(\"NO\")\n                    return\n            else:  # Not on a diagonal\n                if other_char == '':\n                    other_char = grid[r][c]\n                elif grid[r][c] != other_char:\n                    print(\"NO\")\n                    return\n\n    # Check if other_char is different from diag_char\n    if other_char == diag_char:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n\nsolve()"}
{"task_id": "E2H_CF492B", "completion": "def solve():\n    n, l = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n\n    max_gap = 0\n    for i in range(1, n):\n        max_gap = max(max_gap, a[i] - a[i-1])\n\n    d_interior = max_gap / 2.0\n\n    d_start = a[0]\n    d_end = l - a[-1]\n\n    result = max(d_interior, d_start, d_end)\n\n    print(f\"{result:.10f}\")\n\nif __name__ == '__main__':\n    solve()"}
{"task_id": "E2H_CF173A", "completion": "import sys\n\ndef solve():\n    lines = sys.stdin.readlines()\n    n = int(lines[0].strip())\n    a_str = lines[1].strip()\n    b_str = lines[2].strip()\n\n    m = len(a_str)\n    k = len(b_str)\n\n    def get_winner(choice1, choice2):\n        if choice1 == choice2:\n            return 0  # Draw\n        if (choice1 == 'R' and choice2 == 'S') or \\\n           (choice1 == 'S' and choice2 == 'P') or \\\n           (choice1 == 'P' and choice2 == 'R'):\n            return 1  # Player 1 wins\n        return 2  # Player 2 wins\n\n    nikephoros_losses = 0\n    polycarpus_losses = 0\n\n    # Calculate losses in one full cycle of (a_str, b_str)\n    # The length of this cycle is LCM(m, k)\n    from math import gcd\n    lcm_mk = (m * k) // gcd(m, k)\n\n    nikephoros_losses_cycle = 0\n    polycarpus_losses_cycle = 0\n\n    for i in range(lcm_mk):\n        nikephoros_choice = a_str[i % m]\n        polycarpus_choice = b_str[i % k]\n        \n        winner = get_winner(nikephoros_choice, polycarpus_choice)\n        if winner == 1:\n            polycarpus_losses_cycle += 1\n        elif winner == 2:\n            nikephoros_losses_cycle += 1\n\n    # Calculate how many full cycles fit into n rounds\n    num_full_cycles = n // lcm_mk\n    nikephoros_losses += num_full_cycles * nikephoros_losses_cycle\n    polycarpus_losses += num_full_cycles * polycarpus_losses_cycle\n\n    # Calculate losses for the remaining rounds\n    remaining_rounds = n % lcm_mk\n    for i in range(remaining_rounds):\n        nikephoros_choice = a_str[i % m]\n        polycarpus_choice = b_str[i % k]\n        \n        winner = get_winner(nikephoros_choice, polycarpus_choice)\n        if winner == 1:\n            polycarpus_losses += 1\n        elif winner == 2:\n            nikephoros_losses += 1\n\n    sys.stdout.write(f\"{nikephoros_losses} {polycarpus_losses}\\n\")\n\nsolve()"}
{"task_id": "E2H_CF1141D", "completion": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    l_str = sys.stdin.readline().strip()\n    r_str = sys.stdin.readline().strip()\n\n    l_indices = [[] for _ in range(27)]  # 0-25 for 'a'-'z', 26 for '?'\n    r_indices = [[] for _ in range(27)]\n\n    for i in range(n):\n        if l_str[i] == '?':\n            l_indices[26].append(i + 1)\n        else:\n            l_indices[ord(l_str[i]) - ord('a')].append(i + 1)\n\n    for i in range(n):\n        if r_str[i] == '?':\n            r_indices[26].append(i + 1)\n        else:\n            r_indices[ord(r_str[i]) - ord('a')].append(i + 1)\n\n    pairs = []\n\n    # 1. Match specific colors (e.g., 'a' with 'a')\n    for i in range(26):\n        while l_indices[i] and r_indices[i]:\n            pairs.append((l_indices[i].pop(), r_indices[i].pop()))\n\n    # 2. Match specific colors with '?' (e.g., 'a' with '?', or '?' with 'a')\n    #    Prioritize matching left specific with right '?'\n    for i in range(26):\n        while l_indices[i] and r_indices[26]:\n            pairs.append((l_indices[i].pop(), r_indices[26].pop()))\n\n    #    Then match left '?' with right specific\n    for i in range(26):\n        while l_indices[26] and r_indices[i]:\n            pairs.append((l_indices[26].pop(), r_indices[i].pop()))\n\n    # 3. Match '?' with '?'\n    while l_indices[26] and r_indices[26]:\n        pairs.append((l_indices[26].pop(), r_indices[26].pop()))\n\n    sys.stdout.write(str(len(pairs)) + '\\n')\n    for l_idx, r_idx in pairs:\n        sys.stdout.write(f\"{l_idx} {r_idx}\\n\")\n\nif __name__ == '__main__':\n    solve()"}
{"task_id": "E2H_CF822C", "completion": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    min_cost = float('inf')\n\n    # Store minimum cost for a given duration ending at a specific day\n    # min_cost_for_duration_ending[duration][end_day] = cost\n    # This approach is too memory intensive.\n    # Instead, let's process vouchers by their end day.\n    # We need to find min cost for a voucher with duration D1 ending at R1\n    # and another voucher with duration D2 starting at L2\n    # such that D1 + D2 = X and R1 < L2.\n\n    # Max possible day is 2 * 10^5\n    MAX_DAY = 2 * 10**5 + 5\n\n    # min_cost_for_duration[duration_val][end_day] = min_cost\n    # This is also too much.\n    # We need to efficiently query for minimum cost of a voucher with duration D1\n    # that ends before L2, for a specific D1.\n\n    # Let's group vouchers by their duration\n    vouchers_by_duration = [[] for _ in range(x + 1)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if 1 <= duration <= x:\n            vouchers_by_duration[duration].append((l, r, cost))\n\n    # Sort vouchers within each duration group by their end day\n    for i in range(1, x + 1):\n        vouchers_by_duration[i].sort(key=lambda v: v[1]) # Sort by end day 'r'\n\n    # This will store the minimum cost for a voucher of a specific duration\n    # that ends at or before a certain day.\n    # min_cost_ending_at[day][duration] = cost\n    # This is also too memory intensive.\n\n    # Instead, let's iterate through vouchers, and for each voucher (l1, r1, cost1):\n    #   1. Add it to a data structure that allows efficient queries for\n    #      min_cost_for_duration D1 ending at R1 <= r1.\n    #   2. Query for another voucher (l2, r2, cost2) such that\n    #      r1 < l2 and (r1-l1+1) + (r2-l2+1) = x.\n\n    # Let's process vouchers sorted by their start day 'l'.\n    # This might allow us to use a data structure that updates minimum costs\n    # for durations as we sweep through days.\n\n    # Option: Iterate through all possible pairs of durations (d1, d2) such that d1 + d2 = x.\n    # For each pair, we need to find min_cost(d1) and min_cost(d2) such that they don't intersect.\n    # This still requires an efficient way to find non-intersecting vouchers.\n\n    # Let's create a list of all vouchers, sorted by their start day.\n    # (l, r, cost, duration)\n    all_vouchers_with_duration = []\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        all_vouchers_with_duration.append((l, r, cost, duration))\n\n    all_vouchers_with_duration.sort() # Sort by start day 'l'\n\n    # min_cost_for_duration_ending_before[day][duration] = min_cost\n    # This is too much.\n    # We need to find min_cost_for_duration_ending_at_or_before[day_limit][duration]\n    # For a fixed duration D, we need to query for min cost of a voucher of duration D\n    # that ends before a certain day.\n\n    # Let's use an array `min_cost_ending_at_day[day]`\n    # `min_cost_ending_at_day[day]` will store a dictionary or list of (duration, cost)\n    # for vouchers ending on `day`.\n    # This is not enough. We need to query for min cost for duration D ending *before* a day.\n\n    # The standard approach for this kind of problem is often to use a sweep-line algorithm\n    # or to iterate through one voucher and query for the other.\n\n    # Let's iterate through all vouchers (l1, r1, cost1, d1).\n    # For each voucher, we need to find a voucher (l2, r2, cost2, d2) such that:\n    #   1. d1 + d2 = x\n    #   2. r1 < l2 or r2 < l1\n    #   3. cost1 + cost2 is minimal.\n\n    # If we iterate through (l1, r1, cost1, d1), we can try to find (l2, r2, cost2, d2).\n    # Case 1: r1 < l2.\n    # We need to find a voucher (l2, r2, cost2, d2) such that d2 = x - d1, l2 > r1, and cost2 is minimal.\n    # Case 2: r2 < l1.\n    # We need to find a voucher (l2, r2, cost2, d2) such that d2 = x - d1, r2 < l1, and cost2 is minimal.\n\n    # Let's iterate through vouchers sorted by their right endpoint `r`.\n    # This allows us to efficiently update minimum costs for vouchers ending at or before `r`.\n\n    # `min_cost_for_duration_ending_at_or_before[duration]`\n    # This will store the minimum cost of a voucher with that duration\n    # that we have processed so far (i.e., its `r` is less than or equal to current `r`).\n    # This is not enough, as we need to query based on `l2 > r1`.\n\n    # Let's try iterating through all possible values of `r1`.\n    # For each `r1`, we want to find a voucher (l1, r1, cost1, d1) and a voucher (l2, r2, cost2, d2)\n    # such that d1 + d2 = x and r1 < l2.\n\n    # This suggests a sweep-line approach.\n    # We will process events at each day `k` from 1 to MAX_DAY.\n    # Events:\n    #   - A voucher starts at `k` (l_i = k)\n    #   - A voucher ends at `k` (r_i = k)\n\n    # Let's maintain `min_cost_for_duration[duration]`\n    # This array will store the minimum cost of a voucher with `duration`\n    # that has already \"passed\" (i.e., its `r` is less than the current day `k`).\n\n    # `min_cost_for_duration_ending_at_day[duration]`\n    # `min_cost_for_duration_starting_at_day[duration]`\n\n    # Let's define `dp[d]` as the minimum cost of a voucher with duration `d`\n    # that has already finished (its `r` is less than the current day `k`).\n    # Initialize `dp` array with infinity.\n    dp = [float('inf')] * (x + 1)\n\n    # Group vouchers by start day `l` and end day `r`.\n    vouchers_starting_at = [[] for _ in range(MAX_DAY)] # List of (r, cost, duration)\n    vouchers_ending_at = [[] for _ in range(MAX_DAY)]   # List of (l, cost, duration)\n\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        if duration <= x:\n            vouchers_starting_at[l].append((r, cost, duration))\n            vouchers_ending_at[r].append((l, cost, duration))\n\n    overall_min_cost = float('inf')\n\n    # Iterate day `k` from 1 to MAX_DAY\n    for k in range(1, MAX_DAY):\n        # Process vouchers that end at `k-1`. These vouchers are now \"available\"\n        # to be paired with vouchers starting at `k` or later.\n        # So, for each voucher (l, k-1, cost, duration) that ends at `k-1`:\n        # Update `dp[duration]` with `min(dp[duration], cost)`.\n        for l_prev, cost_prev, duration_prev in vouchers_ending_at[k-1]:\n            dp[duration_prev] = min(dp[duration_prev], cost_prev)\n\n        # Now, consider vouchers that start at `k`.\n        # For each voucher (k, r_curr, cost_curr, duration_curr) starting at `k`:\n        # We need to find a previous voucher (l_prev, r_prev, cost_prev, duration_prev)\n        # such that r_prev < k and duration_prev + duration_curr = x.\n        # This means duration_prev = x - duration_curr.\n        # We can query `dp[x - duration_curr]` for the minimum cost of such a voucher.\n        # If `dp[x - duration_curr]` is not infinity, we can form a pair.\n        for r_curr, cost_curr, duration_curr in vouchers_starting_at[k]:\n            required_duration = x - duration_curr\n            if 1 <= required_duration <= x:\n                if dp[required_duration] != float('inf'):\n                    overall_min_cost = min(overall_min_cost, cost_curr + dp[required_duration])\n\n    if overall_min_cost == float('inf'):\n        print(-1)\n    else:\n        print(overall_min_cost)\n\nsolve()"}
{"task_id": "E2H_CF1846E2", "completion": "import math\n\ndef solve():\n    n = int(input())\n\n    if n <= 6:\n        print(\"NO\")\n        return\n\n    # Case 1: Snowflake with 2 levels (root + k children + k*k grandchildren)\n    # Total vertices = 1 + k + k*k\n    # We need to find if n = 1 + k + k*k for some integer k > 1\n    # k*k + k + (1 - n) = 0\n    # Using quadratic formula: k = (-1 +/- sqrt(1 - 4*(1-n))) / 2\n    # k = (-1 +/- sqrt(1 - 4 + 4n)) / 2\n    # k = (-1 +/- sqrt(4n - 3)) / 2\n    # For k to be an integer > 1, 4n - 3 must be a perfect square, say s*s.\n    # And (-1 + s) must be an even positive number greater than 2.\n    # So s must be odd and s > 5.\n    \n    discriminant = 4 * n - 3\n    s = int(math.isqrt(discriminant))\n    if s * s == discriminant:\n        # Check if k is an integer and k > 1\n        if (s - 1) % 2 == 0:\n            k_val = (s - 1) // 2\n            if k_val > 1:\n                print(\"YES\")\n                return\n\n    # Case 2: Snowflake with more than 2 levels\n    # Total vertices = 1 + k + k^2 + ... + k^(d-1) where d >= 3\n    # This is a geometric series sum: (k^d - 1) / (k - 1)\n    # We need to find if n = (k^d - 1) / (k - 1) for some integers k > 1 and d >= 3.\n    # n * (k - 1) = k^d - 1\n    # n*k - n = k^d - 1\n    # n*k - k^d = n - 1\n    # k * (n - k^(d-1)) = n - 1\n\n    # Since k > 1 and d >= 3:\n    # Smallest possible sum for d=3: 1 + k + k^2\n    # Smallest possible sum for k=2, d=3: 1 + 2 + 4 = 7\n    # Smallest possible sum for k=2, d=4: 1 + 2 + 4 + 8 = 15\n    # Smallest possible sum for k=2, d=5: 1 + 2 + 4 + 8 + 16 = 31\n    # ...\n    # Smallest possible sum for k=3, d=3: 1 + 3 + 9 = 13\n    # Smallest possible sum for k=3, d=4: 1 + 3 + 9 + 27 = 40\n    \n    # Iterate over possible values of d (number of levels)\n    # Since k >= 2, k^d - 1 >= 2^d - 1\n    # And (k^d - 1) / (k - 1) >= (2^d - 1) / (2 - 1) = 2^d - 1\n    # So n >= 2^d - 1 => 2^d <= n + 1 => d <= log2(n + 1)\n    # Since n <= 10^18, log2(10^18 + 1) approx 18 * log2(10) approx 18 * 3.32 approx 59.79\n    # So d can go up to around 60.\n    \n    for d in range(3, 61): # d is number of levels\n        # We need to find integer k > 1 such that n = (k^d - 1) / (k - 1)\n        # This is equivalent to n*(k-1) = k^d - 1\n        # Or n*k - n = k^d - 1\n        # k^d - n*k + (n - 1) = 0\n        \n        # We can use binary search for k.\n        # Lower bound for k is 2.\n        # Upper bound for k: k^d - 1 <= n*(k-1) => k^d - 1 < n*k\n        # If k >= n^(1/(d-1)), then k^(d-1) >= n, so k^d >= n*k, which means k^d - n*k >= 0.\n        # More precisely, (k^d - 1) / (k - 1) approx k^(d-1) for large k.\n        # So k^(d-1) approx n => k approx n^(1/(d-1)).\n        # Let's set a safe upper bound: k can't be much larger than n^(1/(d-1)).\n        # For d=3, k approx n^(1/2) = sqrt(n). Max sqrt(10^18) = 10^9.\n        # For d=60, k approx n^(1/59). Max (10^18)^(1/59) approx 10^(18/59) approx 10^0.3 = 2.\n        \n        low = 2\n        high = int(n**(1/(d-1))) + 2 # Add some buffer for floating point issues and small d\n        \n        # Clamp high to a reasonable maximum if it's too large (e.g., for d=3)\n        # Max k for d=3 is around sqrt(10^18) = 10^9.\n        # Max k for d=60 is around 2.\n        # The largest k for any d is when d=3, which is 10^9.\n        # For d > 3, k is much smaller.\n        # For example, if k=2, d can be up to 60.\n        # If k=3, d can be up to log3(10^18) approx 18 * log3(10) approx 18 * 2.09 approx 37.\n        # If k=10^9, d must be 3.\n        \n        # A safer upper bound for k for any d:\n        # If k >= 2, (k^d - 1)/(k-1) = 1 + k + ... + k^(d-1)\n        # If d >= 3, k^(d-1) < n. So k < n^(1/(d-1)).\n        # For d=3, k < n^(1/2). For n=10^18, k < 10^9.\n        # For d=60, k < n^(1/59). For n=10^18, k < (10^18)^(1/59) approx 2.09.\n        # So high can be at most 10^9.\n        high = min(high, 10**9 + 7) # A sufficiently large bound for k.\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if mid < 2: # k must be > 1\n                low = 2\n                continue\n\n            # Calculate sum = 1 + mid + mid^2 + ... + mid^(d-1)\n            # This sum can overflow standard integer types if calculated naively.\n            # mid^d can be (10^9)^60 which is too large.\n            # But we are looking for n. So mid^d should be around n*mid.\n            # k^d - 1 = n*(k-1)\n            # k^d approx n*k.\n            # If k is large, k^(d-1) approx n.\n            \n            # Use a safe way to calculate sum or compare.\n            # sum = (mid^d - 1) // (mid - 1)\n            # Check for overflow when calculating mid^d\n            \n            current_sum = 0\n            term = 1\n            overflow = False\n            for _ in range(d):\n                current_sum += term\n                if _ < d - 1: # Avoid multiplying term in the last iteration\n                    if n // mid < term: # Check for overflow before multiplication: term * mid > n\n                        overflow = True\n                        break\n                    term *= mid\n            \n            if overflow or current_sum > n:\n                high = mid - 1\n            elif current_sum < n:\n                low = mid + 1\n            else: # current_sum == n\n                print(\"YES\")\n                return\n\n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()"}
{"task_id": "E2H_CF270E", "completion": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges_input = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, c))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n\n    ans = [-1] * m\n    balance = [0] * (n + 1)\n    visited_edges = [False] * m\n\n    q = [n]\n    visited = [False] * (n + 1)\n    visited[n] = True\n\n    head = 0\n    while head < len(q):\n        u = q[head]\n        head += 1\n\n        for v, c, edge_idx in adj[u]:\n            if not visited_edges[edge_idx]:\n                visited_edges[edge_idx] = True\n                \n                if u == n:\n                    # For edges connected to the sink (n),\n                    # flow must be incoming to n, or outgoing from n if it's the source.\n                    # Since n is the sink, flow must be incoming.\n                    # This means if edge is (u, v), flow is v -> u.\n                    # If edge is (v, u), flow is v -> u.\n                    # So, if original edge was (a_i, b_i), and u is a_i, then a_i -> b_i is 0.\n                    # If original edge was (a_i, b_i), and u is b_i, then b_i -> a_i is 1.\n                    \n                    # We are processing edges from u.\n                    # The flow must be towards u. So v -> u.\n                    # If original edge was (a_i, b_i) and u = a_i, then b_i -> a_i means ans[edge_idx] = 1.\n                    # If original edge was (a_i, b_i) and u = b_i, then a_i -> b_i means ans[edge_idx] = 0.\n                    \n                    orig_u, orig_v, _ = edges_input[edge_idx]\n                    if orig_u == u: # original edge was (u, v), flow v -> u\n                        ans[edge_idx] = 1\n                    else: # original edge was (v, u), flow v -> u\n                        ans[edge_idx] = 0\n                    \n                    balance[v] += c\n                else:\n                    # For other nodes (1 < v < n), we want to satisfy balance.\n                    # If current node u has a positive balance, it means it has more incoming flow than outgoing.\n                    # We want to direct flow from u to v to reduce u's balance.\n                    # If current node u has a negative balance, it means it has more outgoing flow than incoming.\n                    # We want to direct flow from v to u to increase u's balance.\n                    \n                    # The condition for source (1) is no incoming edges.\n                    # The condition for sink (n) is no outgoing edges.\n                    \n                    # We are doing a traversal from n.\n                    # For any node u (1 < u < n), we want to make its balance 0.\n                    # If we direct flow v -> u, balance[u] increases, balance[v] decreases.\n                    # If we direct flow u -> v, balance[u] decreases, balance[v] increases.\n                    \n                    # The strategy is to process nodes in reverse topological order from n.\n                    # When we process an edge (u, v) from u, we want to direct flow to satisfy balance for u.\n                    # However, we don't know the full balance of u yet.\n                    # A common technique for this type of problem is to use a DFS/BFS from a \"special\" node (like n)\n                    # and determine directions greedily, pushing the \"unbalanced\" flow towards the source.\n\n                    # Let's re-evaluate the strategy.\n                    # We need to satisfy flow conservation for 1 < v < n.\n                    # Vertex 1 has no incoming edges.\n                    # The graph should be a DAG.\n\n                    # The problem statement guarantees a solution exists.\n                    # The \"no cycles\" condition is strong. It implies a topological ordering.\n                    # The source (1) has no incoming, sink (n) has no outgoing.\n                    # This means all paths go from 1 to n.\n\n                    # Consider a DFS from the source (1).\n                    # When we visit an edge (u, v), if v is not visited, we direct u -> v.\n                    # This builds a DFS tree. Any back edges (v -> u where u is ancestor of v) would form a cycle.\n                    # So, if v is already visited, and it's not the parent, it must be a cross edge or forward edge.\n                    # This is tricky because flow conservation depends on all edges.\n\n                    # Let's use the given property: vertex 1 has no incoming edges.\n                    # This means all flow from 1 must be outgoing.\n                    # Let's use the given property: vertex n has no outgoing edges.\n                    # This means all flow to n must be incoming.\n\n                    # What if we sum up the flow for each vertex?\n                    # For v (1 < v < n), sum(incoming) = sum(outgoing).\n                    # For v = 1, sum(incoming) = 0.\n                    # For v = n, sum(outgoing) = 0.\n\n                    # Let's consider the balance array.\n                    # `balance[v]` will store `sum(flow into v) - sum(flow out of v)`.\n                    # We want `balance[v] = 0` for `1 < v < n`.\n                    # We want `balance[1] <= 0` (all outgoing).\n                    # We want `balance[n] >= 0` (all incoming).\n\n                    # A common approach for such problems (where you need to orient edges to satisfy flow conservation)\n                    # is to process nodes in a specific order.\n                    # If we process nodes from n backwards (e.g., using a BFS/DFS from n),\n                    # we can determine directions such that flow is pushed towards the source.\n\n                    # Let's use a BFS from the sink (n) to determine edge directions.\n                    # When we traverse an edge (u, v) from u, we consider it.\n                    # If we decide flow goes v -> u, then balance[u] increases by c, balance[v] decreases by c.\n                    # If we decide flow goes u -> v, then balance[u] decreases by c, balance[v] increases by c.\n\n                    # We want to ensure that for any node `v` (1 < v < n), its net flow is zero.\n                    # `balance[v]` will accumulate the net flow *into* `v`.\n                    # So we want `balance[v] = 0` for `1 < v < n`.\n\n                    # Initialize `balance[v]` to 0 for all v.\n                    # We will process edges using a BFS/DFS starting from `n`.\n                    # When we visit a node `u` and an unvisited edge `(u, v)` with capacity `c`:\n                    # We want to direct the flow on this edge.\n                    # The \"no cycles\" condition is key. This implies a topological sort.\n                    # Since 1 has no incoming and n has no outgoing, we can think of it as a DAG from 1 to n.\n\n                    # Let's try to do a BFS from `n`.\n                    # When we process an edge `(u, v)` from `u` to `v`:\n                    # If `v` is `1`, we *must* direct flow `u -> 1` to satisfy \"1 has no incoming edges\".\n                    # Oh, wait. \"1 has no incoming edges\" means `balance[1]` must be non-positive.\n                    # \"n has no outgoing edges\" means `balance[n]` must be non-negative.\n\n                    # Let's use the `balance` array to track the *net outgoing flow* from each vertex.\n                    # Initially, `balance[v] = 0` for all `v`.\n                    # If we direct `u -> v` with flow `c`, then `balance[u] += c` and `balance[v] -= c`.\n                    # We want `balance[v] = 0` for `1 < v < n`.\n                    # We want `balance[1] >= 0` (all outgoing).\n                    # We want `balance[n] <= 0` (all incoming).\n\n                    # The problem can be rephrased: orient edges such that for 1 < v < n, sum(flow_in) = sum(flow_out).\n                    # This is equivalent to saying `balance[v] = 0` (where balance is sum_in - sum_out).\n                    # For v=1, sum_in = 0. For v=n, sum_out = 0.\n                    # Let's use `balance[v]` to mean `sum(flow_in) - sum(flow_out)`.\n                    # We want `balance[v] = 0` for `1 < v < n`.\n                    # `balance[1]` should be 0 (no incoming).\n                    # `balance[n]` should be 0 (no outgoing).\n                    # This is not quite right. `balance[1]` should be 0 if we define it as sum_in - sum_out.\n                    # But the problem states \"vertex with number 1 has no incoming edges\".\n                    # This means for vertex 1, all incident edges must be directed away from it.\n                    # Similarly, for vertex n, all incident edges must be directed towards it.\n\n                    # This simplifies things greatly.\n                    # For edges (1, x), direction must be 1 -> x.\n                    # For edges (x, n), direction must be x -> n.\n\n                    # The issue is that the problem statement \"vertex with number 1 has no incoming edges\"\n                    # and \"the obtained directed graph does not have cycles\" are crucial.\n                    # If 1 has no incoming, and n has no outgoing, then all paths go from 1 to n.\n                    # This implies a topological sort.\n\n                    # Let's use the BFS from `n` strategy.\n                    # `balance[v]` will represent the `sum(incoming flow) - sum(outgoing flow)` for `v`.\n                    # We want `balance[v] = 0` for `1 < v < n`.\n                    # For `v=1`, `balance[1]` should be `sum(outgoing flow from 1)`.\n                    # For `v=n`, `balance[n]` should be `sum(incoming flow to n)`.\n\n                    # Initialize `balance` to 0.\n                    # Perform a BFS from `n`.\n                    # When we extract `u` from queue:\n                    # For each neighbor `v` of `u` via edge `(u, v)` with flow `c` and index `edge_idx`:\n                    # If `edge_idx` is not yet visited:\n                    #   Mark `edge_idx` as visited.\n                    #   If `v == 1`:\n                    #     We *must* direct flow `u -> 1` (because 1 has no incoming).\n                    #     So, `balance[u] -= c`. `balance[1] += c`.\n                    #     If original edge was `(u, v)`, `ans[edge_idx] = 0`.\n                    #     If original edge was `(v, u)`, `ans[edge_idx] = 1`.\n                    #   Else (`v` is `1 < v <= n`):\n                    #     We want to \"balance\" `u`.\n                    #     If `balance[u] >= 0` (net incoming flow to `u` or balanced), we want to send flow `u -> v`.\n                    #     This means `balance[u]` decreases, `balance[v]` increases.\n                    #     If `balance[u] < 0` (net outgoing flow from `u`), we want to send flow `v -> u`.\n                    #     This means `balance[u]` increases, `balance[v]` decreases.\n                    # This logic is problematic because `balance[u]` is not fully known yet.\n\n                    # The standard way to solve this type of problem (where you need to orient edges to satisfy flow conservation\n                    # for intermediate nodes, and source/sink constraints, without cycles) is often to use a topological sort\n                    # or a specific traversal.\n                    # Since \"no cycles\" is guaranteed for the output, we can think of it as a DAG.\n                    # The source (1) has out-degree > 0, in-degree = 0.\n                    # The sink (n) has in-degree > 0, out-degree = 0.\n                    # All other nodes (1 < v < n) have in-degree_flow = out-degree_flow.\n\n                    # Let's use a queue for nodes whose balance needs to be determined.\n                    # For each node `v`, `deg[v]` is the number of unoriented edges connected to `v`.\n                    # `current_flow[v]` is the sum of flows of oriented edges coming *into* `v` minus sum of flows of oriented edges coming *out of* `v`.\n                    # Initially, `current_flow[v] = 0`.\n                    # When `deg[v]` becomes 1 for any `v` (1 < v < n), we can determine the direction of that last edge.\n                    # If `current_flow[v] > 0`, the last edge must be outgoing from `v`.\n                    # If `current_flow[v] < 0`, the last edge must be incoming to `v`.\n\n                    # This is a common \"2-SAT like\" or \"degree-based\" approach.\n                    # `balance[v]` = `sum(flow_into_v) - sum(flow_out_of_v)`.\n                    # We want `balance[v] = 0` for `1 < v < n`.\n                    # For `v=1`, `balance[1]` can be negative (more outgoing).\n                    # For `v=n`, `balance[n]` can be positive (more incoming).\n\n                    # Initialize `balance[v] = 0` for all `v`.\n                    # `deg[v]` = total flow incident to `v`.\n                    # `total_incident_flow[v]` = sum of `c` for all edges `(v, x)`.\n                    # We need to satisfy `sum(flow_in) = sum(flow_out)` for `1 < v < n`.\n                    # This means for `1 < v < n`, `balance[v]` must be 0.\n                    # For `v=1`, `balance[1]` must be `sum(flow_out_from_1)`.\n                    # For `v=n`, `balance[n]` must be `sum(flow_in_to_n)`.\n\n                    # Let's try the BFS from `n` approach with `balance[v]` representing `sum(flow_into_v) - sum(flow_out_of_v)`.\n                    # When we process `u` from the queue, we iterate its neighbors `v` via `(u, v)` with flow `c`.\n                    # If `v` is `1`:\n                    #   Flow must be `u -> 1`.\n                    #   `balance[u] -= c`, `balance[1] += c`.\n                    #   Set `ans[edge_idx]`.\n                    # Else if `v` is `n`:\n                    #   Flow must be `v -> n`.\n                    #   `balance[v] -= c`, `balance[n] += c`.\n                    #   Set `ans[edge_idx]`.\n                    # Else (`1 < v < n`):\n                    #   If `balance[v]` is already determined (e.g., if `v` was processed and its balance became 0):\n                    #     This implies we are processing an edge to an already balanced node. This might not be right.\n                    #   A better approach:\n                    #   When we process `u` (from `n`'s BFS):\n                    #   We want to make `balance[u]` zero eventually.\n                    #   Consider an edge `(u, v)` with flow `c`.\n                    #   If we direct `v -> u`, then `balance[u]` increases by `c`.\n                    #   If we direct `u -> v`, then `balance[u]` decreases by `c`.\n                    #   We want to push the \"excess\" flow towards `1`.\n\n                    # Let `current_balance[v]` be the net flow *out* of `v` from edges whose directions have been determined.\n                    # Initially, `current_balance[v] = 0` for all `v`.\n                    # When we decide `u -> v` with flow `c`: `current_balance[u] += c`, `current_balance[v] -= c`.\n                    # We want `current_balance[v] = 0` for `1 < v < n`.\n\n                    # Let's use a modified BFS/DFS.\n                    # The key conditions are:\n                    # 1. Flow conservation for 1 < v < n.\n                    # 2. Vertex 1 has no incoming edges.\n                    # 3. No cycles.\n\n                    # The \"no cycles\" condition is the strongest hint. It implies a DAG.\n                    # If 1 has no incoming, and n has no outgoing, then 1 is the source, n is the sink.\n                    # All edges must be directed such that they follow a topological order from 1 to n.\n\n                    # Let's try a DFS from 1.\n                    # `visited[v]` = 0 (unvisited), 1 (visiting), 2 (visited).\n                    # `parent[v]` = parent in DFS tree.\n                    # `path_flow[v]` = flow coming into `v` from parent.\n\n                    # This is a simpler approach that often works for flow orientation:\n                    # For each node `v` (1 < v < n), we need its `net_flow = 0`.\n                    # Let `current_net_flow[v]` be the sum of flow *into* `v` minus flow *out of* `v` for edges already oriented.\n                    # We can use a queue of nodes `q` that have `current_net_flow[v] != 0` and `v != 1` and `v != n`.\n                    # This is tricky because the order matters.\n\n                    # Let's use the BFS from `n` and `balance[v]` meaning `sum(flow_into_v) - sum(flow_out_of_v)`.\n                    # We process nodes from `n` backwards.\n                    # `balance[v]` will be the accumulated flow difference for `v` from edges *already oriented*.\n                    # When we process `u` from the queue:\n                    # For each neighbor `v` of `u` via edge `(u, v)` with flow `c` and index `edge_idx`:\n                    #   If `edge_idx` is not yet oriented:\n                    #     Mark `edge_idx` as oriented.\n                    #     If `v == 1`:\n                    #       Flow must be `u -> 1` (because 1 has no incoming).\n                    #       `balance[u] -= c` (u sends flow out).\n                    #       `balance[1] += c` (1 receives flow in).\n                    #       `ans[edge_idx]` set based on `u -> 1`.\n                    #     Else (`1 < v <= n`):\n                    #       We want to make `balance[u]` zero.\n                    #       If `balance[u]` is currently positive (net incoming to `u`), we must direct `u -> v` to decrease `balance[u]`.\n                    #       If `balance[u]` is currently negative (net outgoing from `u`), we must direct `v -> u` to increase `balance[u]`.\n                    #       This is still problematic because `balance[u]` depends on future edges.\n\n                    # Let's try to determine flow directions for all edges incident to `n` first.\n                    # All edges incident to `n` must be directed towards `n`.\n                    # So for an edge `(u, n)` with flow `c`:\n                    #   Direction is `u -> n`.\n                    #   `balance[u] -= c`.\n                    #   `balance[n] += c`.\n                    #   Set `ans[edge_idx]`.\n                    # After this, `balance[n]` will be the total max flow.\n                    # `balance[1]` should be `-total_max_flow`.\n                    # All other `balance[v]` should be `0`.\n\n                    # This is the correct approach:\n                    # `balance[v]` = `sum(flow_into_v) - sum(flow_out_of_v)`.\n                    # Initially, all `balance[v] = 0`.\n                    # We will process nodes in a BFS order starting from `n`.\n                    # When we process `u` (popped from queue):\n                    #   For each edge `(u, v)` with flow `c` and index `edge_idx`:\n                    #     If this edge is not yet directed:\n                    #       We want to direct flow such that `balance[u]` eventually becomes 0 (if `u != 1, n`).\n                    #       Since we are traversing from `n` backwards, we want to push \"excess\" flow towards `1`.\n                    #       So, if `balance[u]` is positive, it means `u` has accumulated incoming flow.\n                    #       We must direct flow `u -> v` to reduce `balance[u]`.\n                    #       If `balance[u]` is negative, it means `u` has accumulated outgoing flow.\n                    #       We must direct flow `v -> u` to increase `balance[u]`.\n                    #       This implies we need to know the *final* balance of `u`.\n\n                    # The crucial insight is often that for a node `u` (1 < u < n), its net flow must be zero.\n                    # When we process an edge `(u, v)` from `u`, we want to make `u`'s balance zero.\n                    # The total flow on edges incident to `u` is `sum_c_u`.\n                    # `balance[u]` is `sum_in - sum_out`.\n                    # If we decide `u -> v`, then `balance[u]` decreases by `c`.\n                    # If we decide `v -> u`, then `balance[u]` increases by `c`.\n\n                    # Let's use a `balance` array that tracks the *current net incoming flow* for each node `v`.\n                    # `balance[v] = sum(flow_in_to_v) - sum(flow_out_of_v)`.\n                    # Initially, `balance[v] = 0` for all `v`.\n                    # We use a queue for a BFS.\n                    # Start BFS from `n`.\n                    # When we process `u` (popped from queue):\n                    #   For each neighbor `v` of `u` via edge `(u, v)` with flow `c` and index `edge_idx`:\n                    #     If `edge_idx` is not yet directed:\n                    #       Mark `edge_idx` as directed.\n                    #       `orig_u, orig_v, _ = edges_input[edge_idx]`\n                    #       If `u == n`:\n                    #         Flow must be `v -> n`.\n                    #         If `orig_u == v`: `ans[edge_idx] = 0` (v -> n)\n                    #         Else: `ans[edge_idx] = 1` (v -> n)\n                    #         `balance[v] -= c` (v sends flow out).\n                    #         `balance[n] += c` (n receives flow in).\n                    #         If `v != 1` and `v != n` and `v` not visited, add `v` to queue.\n                    #       Else if `v == n`: (this case is covered by `u == n` if `u` is the one popped)\n                    #         No, this is if `v` is the neighbor `n`.\n                    #         Flow must be `u -> n`.\n                    #         If `orig_u == u`: `ans[edge_idx] = 0` (u -> n)\n                    #         Else: `ans[edge_idx] = 1` (u -> n)\n                    #         `balance[u] -= c` (u sends flow out).\n                    #         `balance[n] += c` (n receives flow in).\n                    #         If `u != 1` and `u != n` and `u` not visited, add `u` to queue.\n                    #       Else (`1 < u < n` and `1 < v < n`):\n                    #         We want `balance[u]` to be 0.\n                    #         If `balance[u]` is currently `0`:\n                    #           This means all previously oriented edges incident to `u` have balanced out.\n                    #           This edge `(u, v)` must be directed.\n                    #           If `balance[v]` is positive, maybe `v -> u`. If negative, `u -> v`.\n                    #           This is still not robust.\n\n                    # Let's reconsider the problem constraints.\n                    # \"vertex with number 1 has no incoming edges\"\n                    # \"the obtained directed graph does not have cycles\"\n                    # These imply a topological sort from 1 to n.\n                    # The core idea is that for any node `v` (1 < v < n), `sum(in_flow) = sum(out_flow)`.\n                    # This means the net flow for `v` is 0.\n                    # For node 1, `sum(in_flow) = 0`.\n                    # For node n, `sum(out_flow) = 0`.\n\n                    # Let `current_flow_sum[v]` be the sum of flow *into* `v` from all edges whose directions have been decided.\n                    # Initialize `current_flow_sum[v] = 0` for all `v`.\n                    # `degree[v]` = number of *undirected* edges incident to `v`.\n                    # `q` = queue of nodes `v` where `degree[v] == 1` and `v != 1, n`.\n                    # Add all such `v` to `q`.\n\n                    # This is a standard \"two-pointer\" or \"degree-based\" approach for flow conservation.\n                    # `net_flow[v]` = `sum(flow_into_v) - sum(flow_out_of_v)`.\n                    # Initially, `net_flow[v] = 0` for all `v`.\n                    # `undirected_edges_count[v]` = number of undirected edges incident to `v`.\n                    # `q = deque()`\n                    # For `v` from 1 to `n`:\n                    #   If `v == 1`:\n                    #     All edges incident to `1` must be `1 -> x`.\n                    #     For each edge `(1, x)` with flow `c` and index `idx`:\n                    #       If `ans[idx] == -1`:\n                    #         `ans[idx]` = 0 if `edges_input[idx]` is `(1, x)`, else 1.\n                    #         `net_flow[1] -= c`\n                    #         `net_flow[x] += c`\n                    #         `undirected_edges_count[1] -= 1`\n                    #         `undirected_edges_count[x] -= 1`\n                    #         If `x != 1` and `x != n` and `undirected_edges_count[x] == 1`, `q.append(x)`.\n                    #   Else if `v == n`:\n                    #     All edges incident to `n` must be `x -> n`.\n                    #     For each edge `(x, n)` with flow `c` and index `idx`:\n                    #       If `ans[idx] == -1`:\n                    #         `ans[idx]` = 0 if `edges_input[idx]` is `(x, n)`, else 1.\n                    #         `net_flow[x] -= c`\n                    #         `net_flow[n] += c`\n                    #         `undirected_edges_count[x] -= 1`\n                    #         `undirected_edges_count[n] -= 1`\n                    #         If `x != 1` and `x != n` and `undirected_edges_count[x] == 1`, `q.append(x)`.\n                    #   Else (`1 < v < n`):\n                    #     If `undirected_edges_count[v] == 1`, `q.append(v)`.\n\n                    # The problem is that vertex 1 has no incoming edges, but it can have outgoing.\n                    # Vertex n has no outgoing edges, but it can have incoming.\n                    # For 1 < v < n, sum(in) = sum(out).\n\n                    # Let's use `balance[v]` to store the required *outgoing* flow from `v`.\n                    # So, `balance[v] = sum(flow_out) - sum(flow_in)`.\n                    # We want `balance[v] = 0` for `1 < v < n`.\n                    # We want `balance[1] >= 0` (all outgoing).\n                    # We want `balance[n] <= 0` (all incoming, so net outgoing is negative).\n\n                    # Initialize `balance[v] = 0` for all `v`.\n                    # `visited_edges` array to mark if an edge has been directed.\n                    # `q = deque()`\n\n                    # Start by processing node `n`. All edges connected to `n` must be directed towards `n`.\n                    # For each edge `(u, n)` with flow `c` and index `edge_idx`:\n                    #   `ans[edge_idx]` is set such that flow is `u -> n`.\n                    #   `balance[u] += c` (u sends c flow out).\n                    #   `balance[n] -= c` (n receives c flow in, so net outgoing is negative).\n                    #   If `u != 1` and `u != n` and `u` is not yet in `q` and all other edges of `u` are processed, add `u` to `q`.\n\n                    # This is still complicated.\n                    # The example output shows flow 3->2 (10), 1->2 (10), 3->1 (5).\n                    # Node 1: edges (1,2) flow 10, (1,3) flow 5.\n                    # Output: 1 (3->2), 0 (1->2), 1 (3->1).\n                    #\n                    # Edge 1: (3,2) flow 10. Output 1 means 2->3.\n                    # Edge 2: (1,2) flow 10. Output 0 means 1->2.\n                    # Edge 3: (3,1) flow 5. Output 1 means 1->3.\n                    #\n                    # Let's check conditions for example 1:\n                    # Directed edges: 2->3 (10), 1->2 (10), 1->3 (5).\n                    # Node 1: incoming = 0. Outgoing = (1->2: 10) + (1->3: 5) = 15. OK.\n                    # Node 2: incoming = (1->2: 10). Outgoing = (2->3: 10). Sum in = Sum out = 10. OK.\n                    # Node 3: incoming = (2->3: 10) + (1->3: 5) = 15. Outgoing = 0. OK. (This means 3 is sink, not n=3).\n                    # This implies the problem statement \"vertex with number 1 has no incoming edges; vertex with number n has no outgoing edges\"\n                    # is the actual interpretation.\n                    # So, for node 1: all incident edges must be 1 -> X.\n                    # For node n: all incident edges must be X -> n.\n                    # For 1 < v < n: sum(flow_in) = sum(flow_out).\n\n                    # Let `current_flow_balance[v]` be `sum(flow_in_to_v) - sum(flow_out_of_v)` for already directed edges.\n                    # `undirected_degree[v]` = count of undirected edges incident to `v`.\n                    # `q = deque()`\n\n                    # Initialize `current_flow_balance` to all zeros.\n                    # Initialize `undirected_degree` for all nodes.\n                    # For `v` from 1 to `n`:\n                    #   If `v == 1`:\n                    #     For each edge `(1, x)` with flow `c` and index `idx`:\n                    #       If `ans[idx] == -1`: # If not yet directed\n                    #         `ans[idx]` = 0 if `edges_input[idx]` is `(1, x)` else 1 (meaning 1 -> x).\n                    #         `current_flow_balance[1] -= c`\n                    #         `current_flow_balance[x] += c`\n                    #         `undirected_degree[1] -= 1`\n                    #         `undirected_degree[x] -= 1`\n                    #         If `x != 1` and `x != n` and `undirected_degree[x] == 1`: `q.append(x)`.\n                    #   Else if `v == n`:\n                    #     For each edge `(x, n)` with flow `c` and index `idx`:\n                    #       If `ans[idx] == -1`: # If not yet directed\n                    #         `ans[idx]` = 0 if `edges_input[idx]` is `(x, n)` else 1 (meaning x -> n).\n                    #         `current_flow_balance[x] -= c`\n                    #         `current_flow_balance[n] += c`\n                    #         `undirected_degree[x] -= 1`\n                    #         `undirected_degree[n] -= 1`\n                    #         If `x != 1` and `x != n` and `undirected_degree[x] == 1`: `q.append(x)`.\n                    #   Else (`1 < v < n`):\n                    #     If `undirected_degree[v] == 1`: `q.append(v)`.\n\n                    # This is still not quite right because we need to process edges connected to 1 and n.\n                    # A better way to initialize `undirected_degree` and `q`:\n                    undirected_degree = [0] * (n + 1)\n                    for u, v, _ in edges_input:\n                        undirected_degree[u] += 1\n                        undirected_degree[v] += 1\n\n                    current_flow_balance = [0] * (n + 1)\n                    from collections import deque\n                    q = deque()\n\n                    # First pass: identify initial nodes for the queue (1 < v < n with undirected_degree = 1)\n                    # and process edges connected to 1 and n.\n                    \n                    # Edges connected to 1: must be 1 -> X\n                    for u_node, v_node, c_flow, edge_idx in adj[1]:\n                        if ans[edge_idx] == -1:\n                            orig_u, orig_v, _ = edges_input[edge_idx]\n                            if orig_u == 1: # 1 -> v_node\n                                ans[edge_idx] = 0\n                            else: # v_node -> 1, but must be 1 -> v_node\n                                ans[edge_idx] = 1\n                            \n                            current_flow_balance[1] -= c_flow # 1 sends flow out\n                            current_flow_balance[v_node] += c_flow # v_node receives flow in\n\n                    # Edges connected to n: must be X -> n\n                    for u_node, v_node, c_flow, edge_idx in adj[n]:\n                        if ans[edge_idx] == -1:\n                            orig_u, orig_v, _ = edges_input[edge_idx]\n                            if orig_u == n: # n -> v_node, but must be v_node -> n\n                                ans[edge_idx] = 1\n                            else: # v_node -> n\n                                ans[edge_idx] = 0\n                            \n                            current_flow_balance[v_node] -= c_flow # v_node sends flow out\n                            current_flow_balance[n] += c_flow # n receives flow in\n                    \n                    # Now, update undirected_degree for all edges.\n                    # This is actually tricky because adj list contains all edges.\n                    # A better approach is to use `visited_edges` and iterate through `edges_input`.\n                    \n                    # Re-initialize for the \"correct\" approach:\n                    current_flow_balance = [0] * (n + 1)\n                    undirected_edge_count_for_node = [0] * (n + 1)\n                    \n                    # For each edge, record which nodes it connects to.\n                    # We need to know the 'other' node for each edge from a node's perspective.\n                    # adj_with_idx[u] = [(v, c, edge_idx)]\n                    \n                    for i in range(m):\n                        u, v, c = edges_input[i]\n                        undirected_edge_count_for_node[u] += 1\n                        undirected_edge_count_for_node[v] += 1\n                        \n                        # Process edges for node 1 and node n directly\n                        if u == 1: # Must be 1 -> v\n                            ans[i] = 0\n                            current_flow_balance[1] -= c\n                            current_flow_balance[v] += c\n                        elif v == 1: # Must be 1 -> u\n                            ans[i] = 1\n                            current_flow_balance[1] -= c\n                            current_flow_balance[u] += c\n                        elif u == n: # Must be v -> n\n                            ans[i] = 1\n                            current_flow_balance[u] -= c # n sends out, but it's a sink\n                            current_flow_balance[v] -= c # v sends out\n                            current_flow_balance[n] += c # n receives in\n                        elif v == n: # Must be u -> n\n                            ans[i] = 0\n                            current_flow_balance[u] -= c # u sends out\n                            current_flow_balance[n] += c # n receives in\n                    \n                    # Now update undirected_edge_count_for_node for directed edges.\n                    # This is better done by simply checking ans[i] == -1\n                    \n                    # Initialize queue for nodes 1 < v < n with 1 undirected edge\n                    for v_node in range(2, n):\n                        count_undirected = 0\n                        for neighbor, flow, edge_idx in adj[v_node]:\n                            if ans[edge_idx] == -1:\n                                count_undirected += 1\n                        if count_undirected == 1:\n                            q.append(v_node)\n\n                    # BFS loop\n                    while q:\n                        u = q.popleft()\n\n                        # Find the single undirected edge incident to u\n                        # If u is 1 or n, we shouldn't be here (they are handled initially)\n                        if u == 1 or u == n:\n                            continue\n\n                        # Find the last undirected edge\n                        last_edge_info = None\n                        for v, c, edge_idx in adj[u]:\n                            if ans[edge_idx] == -1:\n                                last_edge_info = (v, c, edge_idx)\n                                break\n                        \n                        if last_edge_info is None: # All edges incident to u are already directed\n                            continue\n\n                        v, c, edge_idx = last_edge_info\n                        \n                        # Direct this edge to make current_flow_balance[u] zero\n                        orig_u, orig_v, _ = edges_input[edge_idx]\n\n                        if current_flow_balance[u] > 0: # u has net incoming flow, must send out\n                            # Direction u -> v\n                            if orig_u == u: # (u, v) -> u -> v\n                                ans[edge_idx] = 0\n                            else: # (v, u) -> u -> v\n                                ans[edge_idx] = 1\n                            current_flow_balance[u] -= c\n                            current_flow_balance[v] += c\n                        elif current_flow_balance[u] < 0: # u has net outgoing flow, must receive in\n                            # Direction v -> u\n                            if orig_u == v: # (v, u) -> v -> u\n                                ans[edge_idx] = 0\n                            else: # (u, v) -> v -> u\n                                ans[edge_idx] = 1\n                            current_flow_balance[u] += c\n                            current_flow_balance[v] -= c\n                        else: # current_flow_balance[u] is 0. This implies it must send flow out.\n                              # If it's 0, it can't be balanced by this last edge.\n                              # This means that the total flow into u must equal total flow out of u\n                              # from the other edges.\n                              # This shouldn't happen if the problem guarantees a solution.\n                              # If current_flow_balance[u] is 0, it means all other edges have balanced out.\n                              # Then this last edge (u, v) must also carry 0 flow, which is not allowed (c >= 1).\n                              # So current_flow_balance[u] must be non-zero at this point.\n                              # Or, if it's 0, it means we can pick any direction?\n                              # The \"no cycles\" condition is important.\n                              # A common way to handle this is to always push flow towards the \"source\" (1)\n                              # or away from the \"sink\" (n) when in doubt.\n                              # Since we are processing nodes with one remaining edge, this edge must be directed\n                              # to make current_flow_balance[u] zero. If it's already zero, it means there's an issue.\n                              # This implies that current_flow_balance[u] will always be non-zero for 1 < u < n.\n                              # The total flow incident to u is sum(c_i). If current_flow_balance[u] is 0,\n                              # it means sum(in) = sum(out) for *already directed* edges.\n                              # But there's still one undirected edge. This means the sum of flows of already\n                              # directed edges must be equal to the total flow of the last edge.\n                              # For example, if current_flow_balance[u] = 10 and last edge is (u,v) with flow 10.\n                              # Then it must be u -> v.\n                              # If current_flow_balance[u] = -10 and last edge is (u,v) with flow 10.\n                              # Then it must be v -> u.\n                              # If current_flow_balance[u] = 0 and last edge is (u,v) with flow 10.\n                              # This implies that total flow for u is 0. So 10 must be balanced.\n                              # This case (current_flow_balance[u] == 0) means the sum of flows of already\n                              # directed edges is 0. If the last edge has flow C, then C != 0, so it cannot be balanced.\n                              # This implies that current_flow_balance[u] will never be 0 when `undirected_degree[u] == 1`.\n                            pass # Should not happen based on problem constraints.\n\n                        # After directing the edge, update the neighbor v\n                        if v != 1 and v != n:\n                            # Check if v now has only one undirected edge left\n                            count_undirected_v = 0\n                            for neighbor_v, flow_v, edge_idx_v in adj[v]:\n                                if ans[edge_idx_v] == -1:\n                                    count_undirected_v += 1\n                            if count_undirected_v == 1:\n                                q.append(v)\n                                \n    # Print results\n    for res in ans:\n        sys.stdout.write(str(res) + '\\n')\n\nsolve()"}
{"task_id": "E2H_CF808E", "completion": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    items_w1 = []\n    items_w2 = []\n    items_w3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            items_w1.append(c)\n        elif w == 2:\n            items_w2.append(c)\n        else:\n            items_w3.append(c)\n\n    items_w1.sort(reverse=True)\n    items_w2.sort(reverse=True)\n    items_w3.sort(reverse=True)\n\n    prefix_sum_w1 = [0] * (len(items_w1) + 1)\n    for i in range(len(items_w1)):\n        prefix_sum_w1[i+1] = prefix_sum_w1[i] + items_w1[i]\n\n    prefix_sum_w2 = [0] * (len(items_w2) + 1)\n    for i in range(len(items_w2)):\n        prefix_sum_w2[i+1] = prefix_sum_w2[i] + items_w2[i]\n\n    prefix_sum_w3 = [0] * (len(items_w3) + 1)\n    for i in range(len(items_w3)):\n        prefix_sum_w3[i+1] = prefix_sum_w3[i] + items_w3[i]\n\n    max_cost = 0\n\n    # Iterate over the number of items with weight 3\n    for k3 in range(len(items_w3) + 1):\n        current_weight_k3 = k3 * 3\n        current_cost_k3 = prefix_sum_w3[k3]\n\n        if current_weight_k3 > m:\n            break\n\n        remaining_weight = m - current_weight_k3\n        \n        # Iterate over the number of items with weight 2\n        for k2 in range(len(items_w2) + 1):\n            current_weight_k2 = k2 * 2\n            current_cost_k2 = prefix_sum_w2[k2]\n\n            if current_weight_k2 > remaining_weight:\n                break\n\n            remaining_weight_for_w1 = remaining_weight - current_weight_k2\n            \n            # All remaining weight must be filled by items of weight 1\n            k1 = min(remaining_weight_for_w1, len(items_w1))\n            current_cost_k1 = prefix_sum_w1[k1]\n\n            total_cost = current_cost_k3 + current_cost_k2 + current_cost_k1\n            max_cost = max(max_cost, total_cost)\n\n    sys.stdout.write(str(max_cost) + '\\n')\n\nsolve()"}
{"task_id": "E2H_CF409I", "completion": "import sys\n\ndef solve():\n    name = sys.stdin.readline().strip()\n\n    def parse_expression(expr_str):\n        # Parses an expression like '_-_/___*__'\n        # Returns a tuple (num_vars, operations)\n        # num_vars: total number of '_'\n        # operations: list of (operator, num_vars_for_operand)\n        \n        num_vars = 0\n        operations = []\n        current_op = None\n        current_operand_vars = 0\n\n        for char in expr_str:\n            if char == '_':\n                num_vars += 1\n                if current_op is not None:\n                    current_operand_vars += 1\n            else:\n                if current_op is not None:\n                    operations.append((current_op, current_operand_vars))\n                current_op = char\n                current_operand_vars = 0\n        \n        if current_op is not None:\n            operations.append((current_op, current_operand_vars))\n        \n        return num_vars, operations\n\n    def parse_condition(cond_str):\n        # Parses a condition like '___>__'\n        # Returns (left_num_vars, operator, right_num_vars)\n        \n        parts = []\n        current_part_vars = 0\n        operator = None\n\n        for char in cond_str:\n            if char == '_':\n                current_part_vars += 1\n            else:\n                parts.append(current_part_vars)\n                operator = char\n                current_part_vars = 0\n        parts.append(current_part_vars)\n\n        return parts[0], operator, parts[1]\n\n    parts = name.split('):-')\n    expression_part = parts[0][2:] # Remove '?('\n    conditions_part = parts[1][:-1] # Remove '.'\n\n    total_expression_vars, expression_ops = parse_expression(expression_part)\n    \n    conditions_list = conditions_part.split(',')\n    parsed_conditions = []\n    for cond_str in conditions_list:\n        parsed_conditions.append(parse_condition(cond_str))\n\n    best_solution = None\n\n    # Iterate through all possible variable assignments\n    # The total number of variables is total_expression_vars\n    # Each variable can take values from 0 to 9\n    \n    # We need to find the lexicographically smallest sequence\n    # This means we should try values for the first variable from 0 to 9,\n    # then for the second, and so on.\n    \n    # Use a recursive backtracking approach\n    \n    def evaluate_expression(values):\n        # values is a list of integers representing the assigned variable values\n        \n        # The first operand is always the first variable\n        if not values:\n            return None # Should not happen with valid input\n        \n        result = values[0]\n        val_idx = 1\n        \n        for op, num_operand_vars in expression_ops:\n            operand_val = 0\n            if num_operand_vars > 0:\n                # The first variable of an operand is multiplied by 10^(num_operand_vars-1)\n                # Subsequent variables are added\n                \n                # For example, if operand is '___' and values are [v1, v2, v3]\n                # operand_val = v1 * 100 + v2 * 10 + v3\n                \n                if val_idx + num_operand_vars > len(values):\n                    return None # Not enough variables for this operand, should not happen if values list is correctly sized\n                \n                for i in range(num_operand_vars):\n                    operand_val = operand_val * 10 + values[val_idx + i]\n                val_idx += num_operand_vars\n            \n            if op == '+':\n                result += operand_val\n            elif op == '-':\n                result -= operand_val\n            elif op == '*':\n                result *= operand_val\n            elif op == '/':\n                if operand_val == 0:\n                    return None # Division by zero\n                result //= operand_val\n            else:\n                return None # Unknown operator, should not happen\n        \n        return result\n\n    def check_conditions(values):\n        # values is a list of integers representing the assigned variable values\n        \n        for left_vars, op, right_vars in parsed_conditions:\n            \n            left_val = 0\n            for i in range(left_vars):\n                left_val = left_val * 10 + values[i]\n            \n            right_val = 0\n            for i in range(right_vars):\n                right_val = right_val * 10 + values[i]\n            \n            if op == '>':\n                if not (left_val > right_val):\n                    return False\n            elif op == '<':\n                if not (left_val < right_val):\n                    return False\n            elif op == '=':\n                if not (left_val == right_val):\n                    return False\n            else:\n                return False # Unknown operator\n        return True\n\n    current_values = [0] * total_expression_vars\n\n    def find_solution(k):\n        nonlocal best_solution\n\n        if k == total_expression_vars:\n            # All variables assigned, evaluate expression and check conditions\n            \n            # The problem statement implies the \"result\" of the expression is what's fed.\n            # However, the example outputs suggest we just need to find the variable values.\n            # \"Output lexicographically smallest sequence of variable values fit for feeding this golorp.\"\n            # This means we don't actually need to evaluate the expression's final value,\n            # only that the variable assignments satisfy the conditions.\n            \n            if check_conditions(current_values):\n                best_solution = \"\".join(map(str, current_values))\n                return True # Found the lexicographically smallest solution\n            return False\n\n        for digit in range(10):\n            current_values[k] = digit\n            if find_solution(k + 1):\n                return True # Propagate success\n        return False\n\n    find_solution(0)\n\n    if best_solution:\n        sys.stdout.write(best_solution + '\\n')\n    else:\n        sys.stdout.write(\"false\\n\")\n\nsolve()"}
{"task_id": "E2H_CF151A", "completion": "def solve():\n    n, k, l, c, d, p, nl, np = map(int, input().split())\n\n    # Calculate total milliliters of drink available\n    total_drink_ml = k * l\n    # Calculate how many toasts can be made based on drink\n    toasts_from_drink = total_drink_ml // (n * nl)\n\n    # Calculate total slices of lime available\n    total_lime_slices = c * d\n    # Calculate how many toasts can be made based on lime\n    toasts_from_lime = total_lime_slices // n\n\n    # Calculate total grams of salt available\n    total_salt_grams = p\n    # Calculate how many toasts can be made based on salt\n    toasts_from_salt = total_salt_grams // (n * np)\n\n    # The number of toasts each friend can make is limited by the minimum of these\n    # divided by the number of friends, but since we already divided by n in each calculation,\n    # we just need the minimum of the individual limits.\n    # No, the problem states \"each friend needs nl milliliters of the drink, a slice of lime and np grams of salt.\"\n    # And \"The friends want to make as many toasts as they can, provided they all drink the same amount.\"\n    # This means if they make X toasts, each friend consumes X * nl drink, X * 1 lime slice, X * np salt.\n    # Total consumption for X toasts for all N friends:\n    # Drink: N * X * nl\n    # Lime: N * X * 1\n    # Salt: N * X * np\n\n    # Let's recalculate based on total available resources and total needed per toast for the group.\n\n    # Total toasts possible based on drink for the entire group:\n    # Each toast requires nl ml of drink for ONE person.\n    # For N people to make ONE toast, they need N * nl ml of drink.\n    # So, total_drink_ml / (N * nl) is the number of toasts the GROUP can make.\n    toasts_from_drink_group = total_drink_ml // (nl * n)\n\n    # Total toasts possible based on lime for the entire group:\n    # Each toast requires 1 slice of lime for ONE person.\n    # For N people to make ONE toast, they need N * 1 slices of lime.\n    # So, total_lime_slices / (1 * N) is the number of toasts the GROUP can make.\n    toasts_from_lime_group = total_lime_slices // n\n\n    # Total toasts possible based on salt for the entire group:\n    # Each toast requires np grams of salt for ONE person.\n    # For N people to make ONE toast, they need N * np grams of salt.\n    # So, total_salt_grams / (N * np) is the number of toasts the GROUP can make.\n    toasts_from_salt_group = total_salt_grams // (np * n)\n\n    # The number of toasts the group can make is limited by the minimum of these three.\n    # And since all friends drink the same amount, this minimum is the number of toasts each friend can make.\n    result = min(toasts_from_drink_group, toasts_from_lime_group, toasts_from_salt_group)\n\n    print(result)\n\nif __name__ == '__main__':\n    solve()"}
{"task_id": "E2H_CF339B", "completion": "def solve():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    current_house = 1\n    total_time = 0\n\n    for task_house in a:\n        if task_house >= current_house:\n            total_time += (task_house - current_house)\n        else:\n            total_time += (n - current_house + task_house)\n        current_house = task_house\n    \n    print(total_time)\n\nsolve()"}
{"task_id": "E2H_CF88A", "completion": "def solve():\n    notes_str = input().split()\n\n    note_to_semitones = {\n        \"C\": 0, \"C#\": 1, \"D\": 2, \"D#\": 3, \"E\": 4, \"F\": 5,\n        \"F#\": 6, \"G\": 7, \"G#\": 8, \"A\": 9, \"B\": 10, \"H\": 11\n    }\n\n    semitones_to_note = {v: k for k, v in note_to_semitones.items()}\n\n    note_values = sorted([note_to_semitones[n] for n in notes_str])\n\n    def get_distance(n1, n2):\n        return (n2 - n1 + 12) % 12\n\n    def check_major(n1, n2, n3):\n        return get_distance(n1, n2) == 4 and get_distance(n2, n3) == 3\n\n    def check_minor(n1, n2, n3):\n        return get_distance(n1, n2) == 3 and get_distance(n2, n3) == 4\n\n    # Try all permutations (rotations) of the sorted notes\n    for i in range(3):\n        n1 = note_values[i]\n        n2 = note_values[(i + 1) % 3]\n        n3 = note_values[(i + 2) % 3]\n\n        if check_major(n1, n2, n3):\n            print(\"major\")\n            return\n        if check_minor(n1, n2, n3):\n            print(\"minor\")\n            return\n\n    print(\"strange\")\n\nsolve()"}
{"task_id": "E2H_CF633B", "completion": "def count_trailing_zeros(n):\n    count = 0\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n    return count\n\nm = int(input())\n\nresults = []\nlow = 1\nhigh = 5 * m # An upper bound, since n! has at least n/5 zeros.\n             # For m = 100,000, max n is around 400,000.\n             # 5 * m is a safe upper bound.\n\n# Binary search for the smallest n such that count_trailing_zeros(n) >= m\nans_start = -1\nwhile low <= high:\n    mid = (low + high) // 2\n    zeros = count_trailing_zeros(mid)\n    if zeros >= m:\n        ans_start = mid\n        high = mid - 1\n    else:\n        low = mid + 1\n\nif ans_start == -1:\n    print(0)\nelse:\n    # Check if count_trailing_zeros(ans_start) is exactly m\n    if count_trailing_zeros(ans_start) == m:\n        # If it is, then ans_start, ans_start+1, ans_start+2, ans_start+3, ans_start+4\n        # will all have exactly m zeros, because the number of zeros only changes\n        # when n is a multiple of 5.\n        print(5)\n        print(ans_start, ans_start + 1, ans_start + 2, ans_start + 3, ans_start + 4)\n    else:\n        print(0)"}
{"task_id": "E2H_CF1767D", "completion": "def solve():\n    n = int(input())\n    s = input()\n\n    count_zeros = s.count('0')\n    count_ones = s.count('1')\n\n    min_winning_skill = (1 << count_zeros)\n    max_winning_skill = (1 << n) - (1 << count_ones) + 1\n\n    winning_skills = []\n    for i in range(min_winning_skill, max_winning_skill + 1):\n        winning_skills.append(i)\n\n    print(*(sorted(winning_skills)))\n\nif __name__ == '__main__':\n    solve()"}
{"task_id": "E2H_CF498A", "completion": "def solve():\n    x1, y1 = map(int, input().split())\n    x2, y2 = map(int, input().split())\n    n = int(input())\n\n    roads = []\n    for _ in range(n):\n        a, b, c = map(int, input().split())\n        roads.append((a, b, c))\n\n    crossings = 0\n    for a, b, c in roads:\n        val1 = a * x1 + b * y1 + c\n        val2 = a * x2 + b * y2 + c\n\n        if (val1 > 0 and val2 < 0) or (val1 < 0 and val2 > 0):\n            crossings += 1\n    \n    print(crossings)\n\nif __name__ == '__main__':\n    solve()"}
{"task_id": "E2H_CF1092C", "completion": "def solve():\n    n = int(input())\n    input_strings = [input() for _ in range(2 * n - 2)]\n\n    strings_by_length = [[] for _ in range(n)]\n    for s in input_strings:\n        strings_by_length[len(s)].append(s)\n\n    # Find the two strings of length n-1\n    s1_n_minus_1 = strings_by_length[n - 1][0]\n    s2_n_minus_1 = strings_by_length[n - 1][1]\n\n    # Candidate original strings\n    # Candidate 1: s1_n_minus_1 is prefix, s2_n_minus_1 is suffix\n    # s = s1_n_minus_1 + s2_n_minus_1[-1]\n    # This is wrong. If s1 is P and s2 is S, then s = s1 + char.\n    # The suffix s2 must be of length n-1. So s2 = char + s1[1:]\n    # No, this is also wrong.\n    # If P = s1_n_minus_1 and S = s2_n_minus_1\n    # Then the original string s must be P + some_char.\n    # And S must be some_char + P[1:].\n    # So the last char of s is s1_n_minus_1[n-2]\n    # No, the last char of s is s2_n_minus_1[0]\n    # And the first char of s is s1_n_minus_1[0]\n    # If s1_n_minus_1 is prefix, s = s1_n_minus_1 + X\n    # If s2_n_minus_1 is suffix, s = Y + s2_n_minus_1\n    # So s must be s1_n_minus_1[0]...s1_n_minus_1[n-2] + X\n    # And s must be Y + s2_n_minus_1[0]...s2_n_minus_1[n-2]\n    # The only way to reconstruct s is:\n    # s = s1_n_minus_1 + s2_n_minus_1[-1]  (if s1_n_minus_1 is prefix, s2_n_minus_1 is suffix)\n    # or\n    # s = s2_n_minus_1 + s1_n_minus_1[-1]  (if s2_n_minus_1 is prefix, s1_n_minus_1 is suffix)\n\n    candidate_s1 = s1_n_minus_1 + s2_n_minus_1[-1]\n    candidate_s2 = s2_n_minus_1 + s1_n_minus_1[-1]\n\n    def check_consistency(original_s, all_given_strings):\n        expected_prefixes = set()\n        expected_suffixes = set()\n        for length in range(1, n):\n            expected_prefixes.add(original_s[:length])\n            expected_suffixes.add(original_s[n - length:])\n\n        temp_prefixes = list(expected_prefixes)\n        temp_suffixes = list(expected_suffixes)\n\n        found_prefixes = [0] * n\n        found_suffixes = [0] * n\n\n        # Check if all given strings can be matched to expected prefixes/suffixes\n        # and if each length has exactly one prefix and one suffix\n        for s_len in range(1, n):\n            p = original_s[:s_len]\n            s = original_s[n - s_len:]\n            \n            if p not in all_given_strings or s not in all_given_strings:\n                return False, None\n\n            # Count occurrences of p and s in the input strings\n            count_p = all_given_strings.count(p)\n            count_s = all_given_strings.count(s)\n\n            if p == s:\n                if count_p != 2:\n                    return False, None\n            else:\n                if count_p != 1 or count_s != 1:\n                    return False, None\n        \n        # Now construct the P/S string\n        result_ps = [''] * len(all_given_strings)\n        \n        # Use a copy of input_strings to mark as used\n        temp_input_strings = list(all_given_strings)\n        \n        # Try to assign P/S based on the derived original_s\n        # Prioritize P for the first match, S for the second, if they are the same string\n        \n        # Create a frequency map for input strings to handle duplicates\n        input_string_counts = {}\n        for s in all_given_strings:\n            input_string_counts[s] = input_string_counts.get(s, 0) + 1\n\n        # Create a list of (string, original_index) to preserve order\n        indexed_input_strings = []\n        for i, s in enumerate(all_given_strings):\n            indexed_input_strings.append((s, i))\n\n        # We need to assign 'P' or 'S' to each input string based on its original index.\n        # This requires a more careful approach than just a simple set check.\n        # We know there are exactly n-1 prefixes and n-1 suffixes.\n        # We need to find a permutation of P/S such that the conditions hold.\n\n        # Let's try to match prefixes first, then suffixes.\n        # This is tricky because a string can be both a prefix and a suffix.\n        # The problem statement says \"which strings are prefixes and which are suffixes\".\n        # This implies a unique assignment for each of the 2n-2 input strings.\n\n        # Let's try to build the result string for a specific original_s\n        \n        # Count expected prefixes and suffixes\n        expected_prefix_map = {}\n        expected_suffix_map = {}\n        for length in range(1, n):\n            p = original_s[:length]\n            s = original_s[n - length:]\n            expected_prefix_map[p] = expected_prefix_map.get(p, 0) + 1\n            expected_suffix_map[s] = expected_suffix_map.get(s, 0) + 1\n\n        # Check if the counts match\n        temp_input_string_counts = dict(input_string_counts)\n        \n        for p_str, count in expected_prefix_map.items():\n            if temp_input_string_counts.get(p_str, 0) < count:\n                return False, None\n            temp_input_string_counts[p_str] -= count\n        \n        for s_str, count in expected_suffix_map.items():\n            if temp_input_string_counts.get(s_str, 0) < count:\n                return False, None\n            temp_input_string_counts[s_str] -= count\n        \n        # After subtracting all expected counts, all counts in temp_input_string_counts must be 0\n        for val in temp_input_string_counts.values():\n            if val != 0:\n                return False, None\n\n        # Now, construct the P/S string. This is the hardest part.\n        # We need to assign 'P' or 'S' to each input string *at its original index*.\n        \n        # We have (n-1) prefixes and (n-1) suffixes.\n        # We need to pick (n-1) 'P's and (n-1) 'S's.\n        \n        # Strategy: Iterate through input strings. If it's a prefix, mark it 'P'.\n        # If it's a suffix, mark it 'S'. If it's both, we have a choice.\n        # If it's neither, it's an invalid original_s.\n\n        # To handle duplicates and preserve order:\n        # Create a list of tuples (string, original_index, assigned_type)\n        assignments = [None] * len(all_given_strings)\n        \n        # Keep track of which prefixes/suffixes are still \"needed\"\n        needed_prefixes = {}\n        needed_suffixes = {}\n        for length in range(1, n):\n            p = original_s[:length]\n            s = original_s[n - length:]\n            needed_prefixes[p] = needed_prefixes.get(p, 0) + 1\n            needed_suffixes[s] = needed_suffixes.get(s, 0) + 1\n\n        # First pass: assign 'P' to strings that can *only* be prefixes (i.e., not suffixes)\n        # and 'S' to strings that can *only* be suffixes (i.e., not prefixes).\n        # This is not correct. A string might be a prefix of one length and a suffix of another.\n        # Example: s = \"ababa\", n=5\n        # Prefixes: a, ab, aba, abab\n        # Suffixes: a, ba, aba, baba\n        # \"a\" is both. \"aba\" is both.\n        # The key is that for each length L, there is *one* prefix of length L and *one* suffix of length L.\n        # So, we have a total of n-1 distinct prefixes and n-1 distinct suffixes.\n        # The input strings are these 2n-2 strings, potentially with duplicates.\n\n        # Let's count how many times each string appears as a prefix and as a suffix\n        is_prefix_count = {}\n        is_suffix_count = {}\n        for length in range(1, n):\n            p = original_s[:length]\n            s = original_s[n - length:]\n            is_prefix_count[p] = is_prefix_count.get(p, 0) + 1\n            is_suffix_count[s] = is_suffix_count.get(s, 0) + 1\n\n        # We need to assign 'P' or 'S' to each input string based on its original index.\n        # This means we need to \"use up\" the available prefixes and suffixes.\n\n        # Create a copy of the original input strings to modify their \"used\" status\n        temp_input_strings_with_indices = [(s, i) for i, s in enumerate(all_given_strings)]\n        \n        # Initialize result string\n        result_ps_list = [''] * len(all_given_strings)\n\n        # Iterate and assign. Prioritize 'P' for the first available, 'S' for the second.\n        # This approach is valid because the problem says \"If there are several possible answers, you can print any.\"\n        \n        # We need to ensure we assign exactly n-1 'P's and n-1 'S's.\n        p_assigned_count = 0\n        s_assigned_count = 0\n\n        # Try to assign 'P' first for strings that can be prefixes\n        for i in range(len(all_given_strings)):\n            s = all_given_strings[i]\n            if is_prefix_count.get(s, 0) > 0 and p_assigned_count < n - 1:\n                result_ps_list[i] = 'P'\n                is_prefix_count[s] -= 1\n                p_assigned_count += 1\n        \n        # Then assign 'S' for remaining strings\n        for i in range(len(all_given_strings)):\n            if result_ps_list[i] == '': # If not yet assigned\n                s = all_given_strings[i]\n                if is_suffix_count.get(s, 0) > 0 and s_assigned_count < n - 1:\n                    result_ps_list[i] = 'S'\n                    is_suffix_count[s] -= 1\n                    s_assigned_count += 1\n        \n        # After this, all entries in result_ps_list should be 'P' or 'S'\n        # And p_assigned_count should be n-1, s_assigned_count should be n-1\n        if p_assigned_count == n - 1 and s_assigned_count == n - 1 and all(x != '' for x in result_ps_list):\n            return True, \"\".join(result_ps_list)\n        else:\n            return False, None\n\n\n    # Check candidate_s1\n    is_consistent_1, ps_string_1 = check_consistency(candidate_s1, input_strings)\n    if is_consistent_1:\n        print(ps_string_1)\n        return\n\n    # Check candidate_s2\n    is_consistent_2, ps_string_2 = check_consistency(candidate_s2, input_strings)\n    if is_consistent_2:\n        print(ps_string_2)\n        return\n\nsolve()"}
{"task_id": "E2H_CF1146D", "completion": "import sys\nimport collections\n\ndef solve():\n    m, a, b = map(int, sys.stdin.readline().split())\n\n    if a > m:\n        print(m + 1)\n        return\n\n    g = a + b\n\n    # dp[r] stores the minimum position x >= 0 such that x % g == r\n    # and x is reachable. Initialize with infinity.\n    dp = collections.defaultdict(lambda: float('inf'))\n    dp[0] = 0\n\n    q = collections.deque()\n    q.append(0)\n\n    # Use 0-1 BFS to find minimum reachable x for each remainder mod g\n    while q:\n        u = q.popleft()\n\n        # Jump +a\n        v_plus = u + a\n        r_plus = v_plus % g\n        if v_plus < dp[r_plus]:\n            dp[r_plus] = v_plus\n            q.appendleft(v_plus) # 0-cost edge, add to front\n\n        # Jump -b\n        v_minus = u - b\n        if v_minus >= 0: # Must stay non-negative\n            r_minus = v_minus % g\n            if v_minus < dp[r_minus]:\n                dp[r_minus] = v_minus\n                q.append(v_minus) # 1-cost edge (in terms of value), add to back\n\n    # Calculate f(x) for x up to a + b - 1\n    # For x < a, only 0 is reachable.\n    ans = 0\n    current_reachable = 0\n    max_reachable_val = 0 # Max value reachable within [0, current_x]\n\n    # f(i) for i from 0 to min(m, a+b-1)\n    for i in range(min(m + 1, a + b)):\n        if i < a:\n            ans += 1\n            continue\n        \n        # Check if i is reachable\n        if i >= dp[i % g]:\n            current_reachable += 1\n            max_reachable_val = i\n        ans += current_reachable\n\n    if m < a + b:\n        print(ans)\n        return\n\n    # For x >= a + b\n    # The set of reachable numbers is {k | k >= 0, k % g == r, k >= dp[r]}\n    # This means for any r, all numbers k = dp[r], dp[r]+g, dp[r]+2g, ... are reachable.\n    # The number of reachable integers up to X is sum_{r=0 to g-1} floor((X - dp[r])/g) + 1\n    # (if X >= dp[r])\n    \n    # Calculate f(x) for x from a+b to m\n    # f(x) = sum_{r=0 to g-1} ( (x - dp[r])/g + 1 ) for x >= dp[r]\n    # For x >= a+b, all dp[r] are <= a+b-1.\n    # So for x >= a+b, all dp[r] are <= x.\n    # Thus, for x >= a+b, f(x) = sum_{r=0 to g-1} ( (x - dp[r])/g + 1 )\n    # f(x) = sum_{r=0 to g-1} ( floor(x/g) - floor(dp[r]/g) + 1 )\n    # This is not quite right.\n    # f(x) = sum_{r=0 to g-1} ( (x - dp[r]) // g + 1 ) if x >= dp[r] else 0\n    # For x >= a+b, all dp[r] are reachable and dp[r] < a+b <= x.\n    # So f(x) = sum_{r=0 to g-1} ( (x - dp[r]) // g + 1 )\n    # f(x) = sum_{r=0 to g-1} ( (x - (dp[r] % g)) // g + 1 )\n    # No, this is wrong.\n    # f(x) = sum_{r=0 to g-1} ( (x - dp[r]) // g + 1 )\n    # f(x) = sum_{r=0 to g-1} ( x//g - (dp[r] - (dp[r]%g))//g + (dp[r]%g <= x%g) + 1 )\n    # This is also complicated.\n    \n    # Let's use the definition:\n    # f(x) = number of reachable integers k such that 0 <= k <= x.\n    # For x >= a+b-1, all residues r mod g have a reachable minimum dp[r].\n    # So the set of reachable numbers is { k | k >= 0, k % g == r, k >= dp[r] for some r }.\n    # For x >= a+b-1, we know that dp[r] < a+b <= x for all r.\n    # So for each r, the reachable numbers are dp[r], dp[r]+g, dp[r]+2g, ..., up to x.\n    # The count for a fixed r is (x - dp[r]) // g + 1.\n    # So f(x) = sum_{r=0}^{g-1} ((x - dp[r]) // g + 1)\n    \n    # We need to sum f(i) for i from a+b to m.\n    # Sum_{i=a+b}^{m} ( sum_{r=0}^{g-1} ((i - dp[r]) // g + 1) )\n    # = sum_{r=0}^{g-1} ( sum_{i=a+b}^{m} ((i - dp[r]) // g + 1) )\n    \n    # Let k = i - dp[r]. Then i = k + dp[r].\n    # Sum_{i=a+b}^{m} ((i - dp[r]) // g + 1)\n    # Let j = (i - dp[r]) // g.\n    # This sum is sum_{i=a+b}^{m} ( (i - dp[r]) // g + 1 )\n    # Let L = a+b, R = m.\n    # For a fixed r, we need to calculate S_r = sum_{i=L}^{R} ( (i - dp[r]) // g + 1 )\n    \n    # S_r = sum_{i=L}^{R} ( floor((i - dp[r])/g) + 1 )\n    # S_r = (R - L + 1) + sum_{i=L}^{R} floor((i - dp[r])/g)\n    \n    # Let j = i - dp[r].\n    # When i=L, j_min = L - dp[r].\n    # When i=R, j_max = R - dp[r].\n    # We need to sum floor(j/g) for j from L-dp[r] to R-dp[r].\n    \n    # Sum_{k=X}^{Y} floor(k/Z) can be calculated efficiently.\n    # sum_{k=X}^{Y} floor(k/Z) = sum_{k=0}^{Y} floor(k/Z) - sum_{k=0}^{X-1} floor(k/Z)\n    # sum_{k=0}^{N} floor(k/Z) = sum_{q=0}^{floor(N/Z)} q * Z + (N % Z + 1) * floor(N/Z)\n    # This is (N//Z) * (N//Z + 1) // 2 * Z + (N % Z + 1) * (N//Z)\n    # No, this is sum_{k=0}^{N} floor(k/Z) = sum_{j=0}^{N//Z - 1} j*Z + j*(Z-1) + (N % Z + 1)*(N//Z)\n    # This is sum_{k=0}^{N} floor(k/Z) = (N // Z) * (N // Z - 1) // 2 * Z + (N % Z + 1) * (N // Z)\n    # It's sum_{k=0}^{N} floor(k/Z) = sum_{q=0}^{N//Z - 1} q*Z + (N % Z + 1)*(N//Z)\n    # The sum is:\n    # sum_{k=0}^{N} floor(k/Z) = sum_{j=0}^{N//Z - 1} j * Z + (N % Z + 1) * (N//Z)\n    # This is wrong.\n    # The correct formula for sum_{k=0}^{N} floor(k/Z) is:\n    # Let Q = N // Z.\n    # sum_{k=0}^{N} floor(k/Z) = Z * sum_{q=0}^{Q-1} q + (N % Z + 1) * Q\n    # = Z * Q * (Q - 1) // 2 + (N % Z + 1) * Q\n    # = Q * (Z * (Q - 1) // 2 + (N % Z + 1))\n    \n    def sum_floor_div(N, Z):\n        if N < 0:\n            return 0\n        Q = N // Z\n        rem = N % Z\n        return Q * (Z * (Q - 1) // 2 + (rem + 1))\n    \n    L = a + b\n    R = m\n    \n    for r_val in dp.values():\n        if r_val == float('inf'):\n            continue\n        \n        # We need sum_{i=L}^{R} ((i - r_val) // g + 1)\n        # = (R - L + 1) + sum_{i=L}^{R} ((i - r_val) // g)\n        # = (R - L + 1) + (sum_{k=0}^{R - r_val} (k // g) - sum_{k=0}^{L - r_val - 1} (k // g))\n        \n        sum_floor_part = sum_floor_div(R - r_val, g) - sum_floor_div(L - r_val - 1, g)\n        ans += (R - L + 1) + sum_floor_part\n\n    print(ans)\n\nsolve()"}
{"task_id": "E2H_CF980E", "completion": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # We want to keep n - k districts.\n    # To maximize the sum of 2^i, we should keep districts with larger i.\n    # So, we should try to remove districts with smaller i.\n\n    # The remaining districts must form a connected component.\n    # This means we need to find a connected component of size n - k\n    # that maximizes the sum of 2^i.\n    # This is equivalent to finding a connected component of size n - k\n    # that minimizes the sum of i (since 2^i is strictly increasing,\n    # and we are selecting a fixed number of elements).\n    # Or, equivalently, selecting n-k elements such that the sum of 2^i is maximized.\n    # This implies we should prioritize keeping larger indices.\n\n    # Let's try to remove k nodes.\n    # The nodes we remove should be the \"cheapest\" nodes that allow us to keep\n    # a connected component of size n-k, prioritizing removing smaller indices.\n\n    # A greedy approach:\n    # Start with all nodes. We want to remove k nodes.\n    # To maximize the sum of 2^i, we should try to keep nodes with large i.\n    # So, we should try to remove nodes with small i.\n\n    # We need to ensure connectivity.\n    # If we remove a node, its neighbors might become disconnected from each other.\n\n    # Consider the nodes in decreasing order of their district number.\n    # The node n is always kept if possible, then n-1, etc.\n    # The smallest node that is kept will be the \"root\" of our final component.\n    # All other kept nodes must be reachable from it.\n\n    # Let's try to find the \"root\" of the final component.\n    # The root must be one of the n-k nodes that we keep.\n    # If we keep n-k nodes, the largest possible sum of 2^i is achieved by\n    # keeping the n-k largest indices that form a connected component.\n\n    # This problem can be rephrased as:\n    # Find a connected subgraph with n-k nodes such that the sum of 2^i is maximized.\n    # This is equivalent to finding a connected subgraph with n-k nodes such that\n    # the sum of (n-i+1) is minimized (if we want to keep small indices).\n    # Or simply, maximize the sum of i.\n\n    # The greedy strategy should be to keep the largest possible nodes.\n    # Start with the node `n`. It's definitely kept.\n    # Then consider `n-1`. If `n-1` is connected to the current component, keep it.\n    # This approach is tricky because removing a small node might disconnect large nodes.\n\n    # A better greedy approach:\n    # We want to remove k nodes. We should remove the smallest possible nodes.\n    # We need to maintain connectivity for the remaining n-k nodes.\n    # This means the final set of nodes must form a connected component.\n\n    # Consider processing nodes from n down to 1.\n    # We want to keep as many large nodes as possible.\n    # Let's keep a set of `kept_nodes`. Initially empty.\n    # And a count of `removed_count`. Initially 0.\n\n    # The key insight for this type of problem is often to consider the nodes\n    # in some specific order (e.g., smallest to largest, or largest to smallest).\n    # Since we want to maximize sum of 2^i, we want to keep large i's.\n    # So, we should try to remove small i's.\n\n    # Let's try to find the smallest node that we *must* keep.\n    # Suppose we decide to keep node `x` as the smallest node in our component.\n    # Then all other `n-k-1` nodes must be greater than `x` and reachable from `x`.\n    # This seems complicated.\n\n    # A simpler greedy approach for connected components when removing nodes:\n    # Start with all nodes. We need to remove `k` nodes.\n    # Iterate through nodes from 1 to `n`.\n    # If node `i` can be removed without disconnecting the remaining `n-removed_count` nodes\n    # (assuming we prioritize keeping larger nodes), then remove it.\n\n    # This is a classic \"remove k nodes to maximize sum of values\" problem on a tree.\n    # The values are 2^i.\n    # This is equivalent to removing k nodes to minimize sum of 2^i,\n    # where the remaining nodes must form a connected component.\n\n    # The nodes we remove should be those that are \"farthest\" from the \"center\" of the desired component,\n    # and have small indices.\n\n    # Let's try to remove nodes from 1 to n.\n    # We have a budget of `k` removals.\n    # We maintain a set of `kept_nodes`. Initially, all nodes are kept.\n    # We iterate `i` from 1 to `n`.\n    # If `i` is currently kept, and we still have removals `k_rem > 0`:\n    #   Try to remove `i`. If removing `i` keeps the remaining `n-1` nodes connected,\n    #   and we can still form a component of size `n-k` with the remaining nodes,\n    #   then remove `i`.\n\n    # This implies a check for connectivity. A BFS/DFS is needed.\n    # A more efficient way to check connectivity:\n    # If we remove node `i`, it must be a leaf in the current \"kept\" graph,\n    # or removing it must not disconnect any two other kept nodes.\n    # In a tree, removing a non-leaf node splits the tree into multiple components.\n    # So, if we remove a non-leaf node, we are essentially choosing one of its branches\n    # to keep, and discarding the others.\n\n    # Let's try to find the \"root\" of the final component.\n    # The largest node `n` is a strong candidate for being in the final component.\n    # What if we fix the smallest node `x` that is kept?\n    # Then we need to select `n-k-1` other nodes from `x+1, ..., n` that are reachable from `x`\n    # and maximize their sum of 2^i.\n    # This would involve running a BFS/DFS from `x` and picking `n-k-1` largest nodes.\n    # We can iterate `x` from `1` to `n-k`. This is `O(N * (N+M))`, too slow.\n\n    # The problem can be solved by iterating from node `n` downwards.\n    # We want to keep `n-k` nodes.\n    # Let `kept_nodes` be a set of nodes we decide to keep.\n    # Initialize `kept_nodes` with `n`.\n    # `num_kept = 1`\n    # `removed_count = 0`\n    # `removed_list = []`\n\n    # This is a classic problem that can be solved with a specific type of BFS/DFS.\n    # We want to select a connected component of size `N-K` such that the sum of `2^i` is maximized.\n    # This is equivalent to selecting a connected component of size `N-K` such that the sum of `i` is maximized.\n    # This means we should try to keep the largest possible `i` values.\n\n    # Let's maintain a set of nodes `S` that are currently kept.\n    # Initially, `S = {n}`.\n    # We have `n-1` nodes to potentially add to `S` or remove.\n    # We want to end up with `|S| = n-k`.\n    # We have `k` removals to make.\n\n    # Consider a \"root\" for the final component. This root will be the smallest index `r` among the `n-k` kept nodes.\n    # All other `n-k-1` nodes must be reachable from `r` and have index `> r`.\n    # This is still complicated.\n\n    # Let's use the fact that we want to remove k nodes.\n    # We want to remove nodes with small indices.\n    # The connectivity constraint is crucial.\n\n    # What if we start with all nodes kept, and try to remove `k` nodes greedily?\n    # Iterate `i` from 1 to `n-k`.\n    # If `i` is currently connected to the component formed by `n, n-1, ..., i+1`,\n    # and we have enough \"budget\" to keep `i` (meaning we don't need to remove it to make space for a larger node later),\n    # then keep `i`.\n\n    # This problem structure suggests a BFS/DFS from the \"largest\" nodes.\n    # Let's process nodes in decreasing order from `n` down to `1`.\n    # We want to keep `n-k` nodes.\n    # Let `kept_count = 0`.\n    # Let `removed_nodes = []`.\n    # `is_removed = [False] * (n + 1)`\n\n    # Iterate `i` from `n` down to `1`.\n    # If `kept_count < n - k`:\n    #   Node `i` is a candidate to be kept.\n    #   If `i` is connected to any node already in `kept_nodes`, or if `kept_nodes` is empty,\n    #   then we can keep `i`.\n    #   This check is still hard.\n\n    # The standard approach for this kind of problem is to find the \"root\" of the desired component.\n    # The \"root\" will be the smallest indexed node that is kept.\n    # Let this root be `R`.\n    # Then we need to select `n-k-1` other nodes from `R+1, ..., n` that are reachable from `R`.\n    # To maximize sum of `2^i`, we pick the `n-k-1` largest nodes from `R+1, ..., n` that are reachable from `R`.\n    # This means we run a BFS/DFS from `R`, collect all reachable nodes `> R`, sort them by index, and pick the top `n-k-1`.\n\n    # We can iterate `R` from `1` to `n-k`. For each `R`:\n    #   1. Perform a BFS/DFS starting from `R`.\n    #   2. Collect all reachable nodes `v` such that `v > R`.\n    #   3. Add `R` to a temporary list `current_kept`.\n    #   4. Sort the collected nodes `v` in descending order.\n    #   5. Add the top `min(len(collected_nodes), n-k-1)` nodes to `current_kept`.\n    #   6. If `len(current_kept) == n-k`, calculate sum of `2^i`. Keep track of the best sum and the corresponding `current_kept`.\n\n    # This is still `O(N * (N+M))`, which is too slow for `N=10^6`.\n\n    # The problem has a special structure: \"remove k contestants\".\n    # This is often solved by a greedy removal strategy.\n    # We want to remove nodes with small indices.\n    # We have `k` removals.\n    # We need to make sure the remaining `n-k` nodes form a connected component.\n\n    # Let's try this:\n    # We have `n-k` slots for nodes to keep.\n    # We want to fill these slots with the largest possible node indices.\n    # So, we iterate from `n` down to `1`.\n    # For each node `i`:\n    #   If we have already selected `n-k` nodes, we are done.\n    #   Otherwise, consider adding `i` to our `kept_set`.\n    #   If `i` is added, it must be connected to other nodes in `kept_set` (unless it's the first node).\n    #   This is the hard part.\n\n    # What if we maintain the `n-k` nodes we *intend* to keep?\n    # Let `kept = set()`.\n    # `removed = set()`.\n    # `num_kept = 0`.\n\n    # We want to remove `k` nodes.\n    # The nodes we remove should be the smallest `k` nodes that can be removed\n    # while maintaining connectivity of the remaining `n-k` nodes,\n    # and ensuring that the `n-k` nodes form a connected component.\n\n    # Consider the nodes in increasing order: `1, 2, ..., n`.\n    # We want to remove `k` nodes.\n    # We can try to remove node `i` if `i` is a \"leaf\" of the current graph (formed by unremoved nodes).\n    # Or, more generally, if removing `i` does not split the graph into more than one component\n    # that we care about.\n\n    # Let's use a degree-based approach, which is common for tree problems.\n    # Initially, all nodes are \"active\".\n    # We want to remove `k` nodes.\n    # We can remove any active node `u` if its degree in the subgraph of active nodes is 1 (it's a leaf),\n    # and we still have removals left.\n    # If we remove `u`, its neighbor's degree decreases. This might make the neighbor a leaf.\n\n    # Algorithm:\n    # 1. Initialize `current_degree[u]` for all `u` as `len(adj[u])`.\n    # 2. Initialize `is_removed[u] = False` for all `u`.\n    # 3. Create a queue `q`. Add all nodes `u` with `current_degree[u] == 1` to `q`.\n    # 4. `removed_count = 0`.\n    # 5. While `q` is not empty and `removed_count < k`:\n    #    a. Dequeue node `u`.\n    #    b. If `u` is not already removed and `n - removed_count > n - k`: (i.e., we can still remove `u` and have `n-k` nodes left)\n    #       i. Mark `u` as removed: `is_removed[u] = True`.\n    #       ii. Add `u` to `removed_nodes` list.\n    #       iii. `removed_count += 1`.\n    #       iv. For each neighbor `v` of `u`:\n    #           1. Decrement `current_degree[v]`.\n    #           2. If `current_degree[v] == 1` and `v` is not removed, enqueue `v`.\n\n    # This greedy approach removes leaves. This ensures connectivity.\n    # However, it removes the smallest leaves first. This is exactly what we want!\n    # By removing leaves, we guarantee that the remaining graph is connected.\n    # And by processing nodes in increasing order (implicitly, by adding leaves to queue),\n    # we prioritize removing smaller indexed nodes.\n\n    # Example: 1-2-3-4-5, n=5, k=2\n    # Initial degrees: deg[1]=1, deg[2]=2, deg[3]=2, deg[4]=2, deg[5]=1\n    # Queue: [1, 5] (or [5, 1] depending on implementation)\n    # removed_count = 0\n\n    # Pop 1:\n    #   is_removed[1] = True, removed_count = 1, removed_nodes = [1]\n    #   Neighbor 2: current_degree[2] = 1. Add 2 to queue.\n    # Queue: [5, 2]\n\n    # Pop 5:\n    #   is_removed[5] = True, removed_count = 2, removed_nodes = [1, 5]\n    #   Neighbor 4: current_degree[4] = 1. Add 4 to queue.\n    # Queue: [2, 4]\n\n    # removed_count is 2, which is k. Stop.\n    # Removed nodes: [1, 5]. Remaining: [2, 3, 4]. Sum 2^2+2^3+2^4. This is optimal.\n\n    # What if a node `u` has degree 1, but its neighbor `v` is already removed?\n    # `current_degree[v]` would have been decremented when `v`'s other neighbor was removed.\n    # The `current_degree` should reflect the degree in the *current* active graph.\n    # When `u` is processed, we iterate its `adj[u]`.\n    # For each `v` in `adj[u]`: if `v` is NOT removed, decrement `current_degree[v]`.\n    # This is correct.\n\n    # What if `n - removed_count > n - k` check?\n    # This means `removed_count < k`. So `while removed_count < k` is sufficient.\n    # The condition `n - removed_count > n - k` is `num_kept > n - k`.\n    # We want to remove `k` nodes. We stop when `removed_count == k`.\n    # The nodes we remove are those that are \"leaves\" in the current active graph.\n    # This strategy guarantees that the remaining `n-k` nodes form a connected component.\n    # And since we add nodes to the queue in arbitrary order (or by default, by their index if using a simple list),\n    # we should explicitly prioritize smaller indices for removal if multiple leaves exist.\n\n    # To prioritize smaller indices for removal, we should use a min-priority queue (min-heap)\n    # for `q`.\n\n    import heapq\n\n    current_degree = [0] * (n + 1)\n    for i in range(1, n + 1):\n        current_degree[i] = len(adj[i])\n\n    is_removed = [False] * (n + 1)\n    \n    # Min-heap to store leaves, prioritizing smaller indices\n    q = []\n    for i in range(1, n + 1):\n        if current_degree[i] == 1:\n            heapq.heappush(q, i)\n        # Handle isolated nodes (n=1, k=0, not possible by constraints)\n        # If n > 1, no node has degree 0 in a tree.\n        # If n=1, k=0, deg[1]=0. But k < n. So n >= 2.\n\n    removed_count = 0\n    removed_nodes_list = []\n\n    while q and removed_count < k:\n        u = heapq.heappop(q)\n\n        if is_removed[u]: # Already removed by another path (e.g. its neighbor was removed)\n            continue\n\n        # We can remove u\n        is_removed[u] = True\n        removed_nodes_list.append(u)\n        removed_count += 1\n\n        # Decrement degrees of neighbors\n        for v in adj[u]:\n            if not is_removed[v]:\n                current_degree[v] -= 1\n                if current_degree[v] == 1:\n                    heapq.heappush(q, v)\n    \n    removed_nodes_list.sort()\n    print(*(removed_nodes_list))\n\nsolve()"}
{"task_id": "E2H_CF1709F", "completion": "import sys\n\nMOD = 998244353\n\ndef solve():\n    n, k, f = map(int, sys.stdin.readline().split())\n\n    max_total_strings = (1 << n) * k\n\n    if f > max_total_strings:\n        print(0)\n        return\n\n    dp = [[0] * (f + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        new_dp = [[0] * (f + 1) for _ in range(n + 1)]\n        for j in range(i + 1):\n            for current_f in range(f + 1):\n                if dp[j][current_f] == 0:\n                    continue\n\n                # Case 1: c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_s for s of length i+1 are chosen such that\n                # sum(c_s) over s of length i+1 is equal to current_f\n                # and c_"}
