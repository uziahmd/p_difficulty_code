{"task_id": "E2H_CF1031A", "completion": "import sys\n\ndef solve():\n    line = sys.stdin.readline().split()\n    w = int(line[0])\n    h = int(line[1])\n    k = int(line[2])\n\n    total_gilded_cells = 0\n\n    for i in range(k):\n        current_w = w - 4 * i\n        current_h = h - 4 * i\n\n        if current_w <= 0 or current_h <= 0:\n            break\n\n        # Calculate cells for the current ring\n        # The perimeter of a rectangle of size current_w x current_h\n        # is 2 * (current_w + current_h) - 4\n        # This formula works for current_w, current_h >= 1\n        gilded_cells_current_ring = 2 * (current_w + current_h) - 4\n        total_gilded_cells += gilded_cells_current_ring\n\n    sys.stdout.write(str(total_gilded_cells) + '\\n')\n\nif __name__ == '__main__':\n    solve()"}
{"task_id": "E2H_CF404A", "completion": "def solve():\n    n = int(input())\n    grid = [input() for _ in range(n)]\n\n    if n == 0:\n        print(\"NO\")\n        return\n\n    diag_char = grid[0][0]\n    other_char = ''\n\n    # Check diagonals\n    for i in range(n):\n        # Main diagonal\n        if grid[i][i] != diag_char:\n            print(\"NO\")\n            return\n        # Anti-diagonal\n        if grid[i][n - 1 - i] != diag_char:\n            print(\"NO\")\n            return\n\n    # Check other squares and determine other_char\n    for r in range(n):\n        for c in range(n):\n            if r == c or r == n - 1 - c:  # On a diagonal\n                continue\n            else:  # Not on a diagonal\n                if other_char == '':\n                    other_char = grid[r][c]\n                elif grid[r][c] != other_char:\n                    print(\"NO\")\n                    return\n\n    # Check if other_char is different from diag_char\n    if other_char == diag_char:\n        print(\"NO\")\n        return\n\n    # All conditions met\n    print(\"YES\")\n\nsolve()"}
{"task_id": "E2H_CF492B", "completion": "def solve():\n    n, l = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n\n    max_gap = 0\n    for i in range(1, n):\n        max_gap = max(max_gap, a[i] - a[i-1])\n\n    d1 = a[0]\n    d2 = l - a[-1]\n    d3 = max_gap / 2.0\n\n    print(f\"{max(d1, d2, d3):.10f}\")\n\nif __name__ == '__main__':\n    solve()"}
{"task_id": "E2H_CF173A", "completion": "import math\n\ndef solve():\n    n = int(input())\n    a_str = input()\n    b_str = input()\n\n    m = len(a_str)\n    k = len(b_str)\n\n    def get_winner(nikephoros_choice, polycarpus_choice):\n        if nikephoros_choice == polycarpus_choice:\n            return 0  # Draw\n        if (nikephoros_choice == 'R' and polycarpus_choice == 'S') or \\\n           (nikephoros_choice == 'S' and polycarpus_choice == 'P') or \\\n           (nikephoros_choice == 'P' and polycarpus_choice == 'R'):\n            return 1  # Nikephoros wins\n        return -1 # Polycarpus wins\n\n    lcm_mk = (m * k) // math.gcd(m, k)\n\n    nikephoros_losses_cycle = 0\n    polycarpus_losses_cycle = 0\n\n    for i in range(lcm_mk):\n        nikephoros_choice = a_str[i % m]\n        polycarpus_choice = b_str[i % k]\n        \n        winner = get_winner(nikephoros_choice, polycarpus_choice)\n        if winner == -1:\n            nikephoros_losses_cycle += 1\n        elif winner == 1:\n            polycarpus_losses_cycle += 1\n\n    full_cycles = n // lcm_mk\n    remaining_rounds = n % lcm_mk\n\n    total_nikephoros_losses = full_cycles * nikephoros_losses_cycle\n    total_polycarpus_losses = full_cycles * polycarpus_losses_cycle\n\n    for i in range(remaining_rounds):\n        nikephoros_choice = a_str[i % m]\n        polycarpus_choice = b_str[i % k]\n        \n        winner = get_winner(nikephoros_choice, polycarpus_choice)\n        if winner == -1:\n            total_nikephoros_losses += 1\n        elif winner == 1:\n            total_polycarpus_losses += 1\n\n    print(total_nikephoros_losses, total_polycarpus_losses)\n\nsolve()"}
{"task_id": "E2H_CF1141D", "completion": "def solve():\n    n = int(input())\n    l_str = input()\n    r_str = input()\n\n    left_boots_by_color = {chr(ord('a') + i): [] for i in range(26)}\n    left_boots_by_color['?'] = []\n    for i in range(n):\n        left_boots_by_color[l_str[i]].append(i + 1)\n\n    right_boots_by_color = {chr(ord('a') + i): [] for i in range(26)}\n    right_boots_by_color['?'] = []\n    for i in range(n):\n        right_boots_by_color[r_str[i]].append(i + 1)\n\n    pairs = []\n\n    # 1. Exact matches (e.g., 'a' with 'a')\n    for char_code in range(26):\n        char = chr(ord('a') + char_code)\n        while left_boots_by_color[char] and right_boots_by_color[char]:\n            l_idx = left_boots_by_color[char].pop()\n            r_idx = right_boots_by_color[char].pop()\n            pairs.append((l_idx, r_idx))\n\n    # 2. Left '?' with specific right colors\n    for char_code in range(26):\n        char = chr(ord('a') + char_code)\n        while left_boots_by_color['?'] and right_boots_by_color[char]:\n            l_idx = left_boots_by_color['?'].pop()\n            r_idx = right_boots_by_color[char].pop()\n            pairs.append((l_idx, r_idx))\n\n    # 3. Right '?' with specific left colors\n    for char_code in range(26):\n        char = chr(ord('a') + char_code)\n        while left_boots_by_color[char] and right_boots_by_color['?']:\n            l_idx = left_boots_by_color[char].pop()\n            r_idx = right_boots_by_color['?'].pop()\n            pairs.append((l_idx, r_idx))\n\n    # 4. Left '?' with Right '?'\n    while left_boots_by_color['?'] and right_boots_by_color['?']:\n        l_idx = left_boots_by_color['?'].pop()\n        r_idx = right_boots_by_color['?'].pop()\n        pairs.append((l_idx, r_idx))\n\n    print(len(pairs))\n    for l_idx, r_idx in pairs:\n        print(l_idx, r_idx)\n\nif __name__ == '__main__':\n    solve()"}
{"task_id": "E2H_CF822C", "completion": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    min_cost = float('inf')\n\n    # Max coordinate for l or r is 2 * 10^5\n    MAX_COORD = 2 * 10**5\n\n    # Store minimum cost for a trip ending at day `r` with duration `d`\n    # min_cost_for_duration_ending[r][duration] = min_cost\n    # This approach is too memory intensive.\n    # Instead, let's use a dictionary of lists or a list of dictionaries.\n    # Or, process vouchers by their start day.\n\n    # We need to find two vouchers (l1, r1, cost1) and (l2, r2, cost2) such that:\n    # 1. r1 < l2 or r2 < l1 (disjoint)\n    # 2. (r1 - l1 + 1) + (r2 - l2 + 1) == x\n    # 3. cost1 + cost2 is minimized\n\n    # Let's group vouchers by their start day 'l'\n    vouchers_by_l = [[] for _ in range(MAX_COORD + 1)]\n    for l, r, cost in vouchers:\n        vouchers_by_l[l].append((r, cost))\n\n    # To efficiently find the minimum cost for a voucher with a specific duration\n    # that ends before a certain day, we can iterate through the vouchers.\n\n    # min_cost_for_duration_at_r[duration] = min_cost\n    # This array will store the minimum cost for a voucher of a specific duration\n    # that has ended by the current processing day `r_current`.\n    # Initialize with infinity.\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1) # index is duration\n\n    # Iterate through all possible end days 'r_current'\n    # This allows us to consider vouchers that have already ended.\n    # The maximum possible 'r' is MAX_COORD.\n    \n    # We need to consider events: voucher starts, voucher ends.\n    # Sort all vouchers by their start day.\n    # When we process a voucher (l, r, cost):\n    # 1. It can be the first voucher. We store its information.\n    # 2. It can be the second voucher. We look for a suitable first voucher.\n\n    # Let's process vouchers sorted by their end day 'r'.\n    # This is slightly tricky because the disjoint condition depends on 'l' and 'r'.\n    # A better approach might be to iterate through days.\n\n    # Iterate through each day from 1 to MAX_COORD\n    # `dp[day]` will store the minimum cost of a trip that *ends* on or before `day`\n    # for each possible duration.\n    # `dp[day][duration]` = min cost of a trip with duration `duration` ending on or before `day`.\n    \n    # This is also too memory intensive.\n    # Let's try iterating through `r` and maintaining minimum costs.\n\n    # `min_cost_for_duration_ending_before_or_at_r[duration]`\n    # This array will store the minimum cost for a voucher of a specific `duration`\n    # that ends at or before the current day `r_curr`.\n    # Initialize with infinity.\n    current_min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n\n    # Group vouchers by their start day `l`\n    # This allows us to process vouchers in increasing order of `l`.\n    vouchers_by_l_day = [[] for _ in range(MAX_COORD + 1)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        vouchers_by_l_day[l].append((r, duration, cost))\n\n    # Iterate through possible start days `l_curr` from 1 to MAX_COORD\n    # For each `l_curr`, we consider vouchers that start at `l_curr`.\n    # These vouchers can be the *second* voucher in a pair.\n    # We also need to update `current_min_cost_for_duration` for vouchers that *end* at `l_curr - 1`.\n\n    # `min_cost_for_duration_ending_at_or_before_prev_day[duration]`\n    # Stores min cost of a voucher with `duration` that ends at or before `l_curr - 1`.\n    # This is updated as we iterate through `l_curr`.\n    \n    # Let's use `min_cost_ending_at_r[duration]`\n    # This array will store the minimum cost for a voucher of a specific `duration`\n    # that *ends* at day `r`.\n    # When we iterate `l_curr` from 1 to MAX_COORD:\n    # 1. Update `min_cost_ending_at_r` with vouchers that start at `l_curr` and end at `r`.\n    # 2. For each voucher (l_curr, r_curr, cost_curr) starting at `l_curr`:\n    #    a. Calculate its duration `d_curr = r_curr - l_curr + 1`.\n    #    b. If `d_curr < x`:\n    #       i. The first voucher must have duration `d1 = x - d_curr`.\n    #       ii. The first voucher must end before `l_curr`.\n    #       iii. We need to find `min_cost_for_duration_ending_before_l_curr[d1]`.\n    #            This value can be stored in `min_cost_for_duration_ending_at_or_before_day[d1]`\n    #            where `day = l_curr - 1`.\n    #            So, we need to maintain `min_cost_for_duration_ending_at_or_before_day[d]`\n    #            which is `min(min_cost_ending_at_r[d] for r < l_curr)`.\n\n    # `min_cost_for_duration_ending_at_or_before_day[d]` will store the minimum cost\n    # of a voucher with duration `d` that ends at or before the current day being processed.\n    # This array will be updated iteratively.\n    \n    # Initialize `min_cost_for_duration_ending_at_or_before_day` with infinity\n    min_cost_for_duration_ending_at_or_before_day = [float('inf')] * (MAX_COORD + 1)\n\n    # Iterate through days from 1 to MAX_COORD\n    # `day` represents the current day we are considering.\n    # Vouchers that start at `day` are processed.\n    # Vouchers that end at `day - 1` have already been processed and their costs\n    # are reflected in `min_cost_for_duration_ending_at_or_before_day`.\n    for day in range(1, MAX_COORD + 1):\n        # `day` is the start day of potential second vouchers.\n        # So, we are looking for a first voucher that ends at or before `day - 1`.\n        \n        # For each voucher `(r_curr, duration_curr, cost_curr)` that starts at `day`:\n        for r_curr, duration_curr, cost_curr in vouchers_by_l_day[day]:\n            # This voucher is (day, r_curr, cost_curr).\n            # Its duration is `duration_curr`.\n            \n            # If this voucher is the second voucher:\n            # We need a first voucher with duration `x - duration_curr`.\n            # This first voucher must end at or before `day - 1`.\n            \n            remaining_duration = x - duration_curr\n            if remaining_duration > 0 and remaining_duration <= MAX_COORD:\n                # Check if there is a suitable first voucher\n                if min_cost_for_duration_ending_at_or_before_day[remaining_duration] != float('inf'):\n                    total_cost = cost_curr + min_cost_for_duration_ending_at_or_before_day[remaining_duration]\n                    min_cost = min(min_cost, total_cost)\n\n        # After processing all vouchers starting at `day` as potential second vouchers,\n        # we update `min_cost_for_duration_ending_at_or_before_day` with vouchers that *end* at `day`.\n        # These vouchers could be potential first vouchers for future `day' > day`.\n        # So, for each voucher (l, r, cost) where r == day:\n        # We need to update `min_cost_for_duration_ending_at_or_before_day[duration]`.\n        # This requires processing vouchers by their end day.\n\n        # This suggests grouping vouchers by their end day `r` is also useful.\n        # Let's re-structure:\n        # `vouchers_ending_at_r[r]` will contain `(l, cost)` for vouchers ending at `r`.\n        \n    # Let's create `vouchers_ending_at_r`\n    vouchers_ending_at_r = [[] for _ in range(MAX_COORD + 1)]\n    for l, r, cost in vouchers:\n        vouchers_ending_at_r[r].append((l, cost))\n\n    # `min_cost_for_duration_ending_at_or_before_day[d]`\n    # This array stores the minimum cost of a voucher with duration `d`\n    # that has ended by the current day `r_curr`.\n    # This array is updated as `r_curr` increases.\n    \n    min_cost_for_duration_ending_at_or_before_day = [float('inf')] * (MAX_COORD + 1)\n\n    # Iterate through each day `r_curr` from 1 to MAX_COORD\n    # `r_curr` represents the current day.\n    # Vouchers that end at `r_curr` are processed for updating `min_cost_for_duration_ending_at_or_before_day`.\n    # Vouchers that start at `r_curr + 1` (or later) can be the second voucher.\n    \n    # For each voucher (l, r, cost):\n    # If it's the first voucher: we store its cost based on its duration and end day `r`.\n    # If it's the second voucher: we look up a first voucher that ends before `l`.\n\n    # Let's iterate through the sorted `vouchers` list.\n    # The vouchers are already sorted by `l`.\n    # This means when we process `(l_curr, r_curr, cost_curr)`:\n    # All vouchers `(l_prev, r_prev, cost_prev)` with `l_prev <= l_curr` have been seen.\n    # We need to find a first voucher `(l1, r1, cost1)` such that `r1 < l_curr`.\n\n    # We need a data structure that can efficiently query `min_cost_for_duration[d]`\n    # for vouchers that end before `l_curr`.\n\n    # Let's use a `min_costs_for_durations` array.\n    # `min_costs_for_durations[d]` stores the minimum cost of a voucher with duration `d`\n    # that *has already ended*.\n    \n    # Iterate through days from 1 to MAX_COORD.\n    # `day` is the current day.\n    # `min_costs_for_durations_upto_prev_day[d]` stores min cost of a voucher with duration `d`\n    # that ends at or before `day - 1`.\n    \n    min_costs_for_durations_upto_prev_day = [float('inf')] * (MAX_COORD + 1)\n    \n    for day in range(1, MAX_COORD + 1):\n        # 1. Consider vouchers that *start* at `day`. These can be the second voucher.\n        #    For such a voucher `(day, r_curr, cost_curr)` with duration `d_curr = r_curr - day + 1`:\n        #    We need a first voucher with duration `x - d_curr` that ends at or before `day - 1`.\n        \n        for r_curr, duration_curr, cost_curr in vouchers_by_l_day[day]:\n            remaining_duration = x - duration_curr\n            if remaining_duration > 0 and remaining_duration <= MAX_COORD:\n                if min_costs_for_durations_upto_prev_day[remaining_duration] != float('inf'):\n                    total_cost = cost_curr + min_costs_for_durations_upto_prev_day[remaining_duration]\n                    min_cost = min(min_cost, total_cost)\n\n        # 2. Update `min_costs_for_durations_upto_prev_day` for the next iteration.\n        #    Vouchers that *end* at `day` can now be considered as first vouchers.\n        #    These will be available for `day + 1` onwards.\n        \n        # `min_costs_for_durations_upto_current_day`\n        # This will be `min_costs_for_durations_upto_prev_day` for the next iteration.\n        # We need to take the minimum of `min_costs_for_durations_upto_prev_day[d]`\n        # and costs of vouchers that end exactly at `day`.\n        \n        # We need to make a copy or update carefully.\n        # `min_costs_for_durations_upto_prev_day` should become\n        # `min_costs_for_durations_upto_current_day` for the next `day`.\n        \n        # For each voucher `(l_v, cost_v)` that ends at `day`:\n        for l_v, cost_v in vouchers_ending_at_r[day]:\n            duration_v = day - l_v + 1\n            min_costs_for_durations_upto_prev_day[duration_v] = \\\n                min(min_costs_for_durations_upto_prev_day[duration_v], cost_v)\n\n        # Important: The update for `min_costs_for_durations_upto_prev_day`\n        # should propagate minimums.\n        # If `min_costs_for_durations_upto_prev_day[d]` was updated by a voucher ending at `day`,\n        # then this new minimum is valid for `day` and all subsequent days.\n        # However, if `min_costs_for_durations_upto_prev_day[d]` already had a smaller value\n        # from a voucher ending *before* `day`, that value should be preserved.\n        # So, the update logic is correct: `min(existing, new_cost)`.\n        \n        # The crucial part is that `min_costs_for_durations_upto_prev_day[d]` must represent\n        # the minimum cost for a duration `d` that ends at or *before* the current `day`.\n        # So, after processing `vouchers_ending_at_r[day]`, we need to ensure that\n        # `min_costs_for_durations_upto_prev_day[d]` correctly holds the minimum up to `day`.\n        # This means `min_costs_for_durations_upto_prev_day[d]` for `day+1`\n        # should be `min(min_costs_for_durations_upto_prev_day[d]` from `day` and any new vouchers ending at `day`).\n        \n        # The current loop structure correctly maintains `min_costs_for_durations_upto_prev_day`\n        # as minimums for vouchers ending at or before `day - 1` when `day` starts.\n        # Then, after considering vouchers starting at `day`, we update it to include\n        # vouchers ending at `day`. So, for `day+1`, it will correctly represent\n        # minimums for vouchers ending at or before `day`.\n\n    if min_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_cost)\n\nsolve()"}
{"task_id": "E2H_CF1846E2", "completion": "def solve():\n    n = int(input())\n\n    if n < 7:\n        print(\"NO\")\n        return\n\n    # Case 1: m = 2 (1 + k + k^2 vertices)\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # Use quadratic formula: k = (-1 +/- sqrt(1 - 4(1)(1 - n))) / 2\n    # k = (-1 +/- sqrt(1 - 4 + 4n)) / 2\n    # k = (-1 +/- sqrt(4n - 3)) / 2\n    \n    # We need k > 1.\n    # For k = 2, n = 1 + 2 + 4 = 7\n    # For k = 3, n = 1 + 3 + 9 = 13\n    # For k = 4, n = 1 + 4 + 16 = 21\n    # ...\n    \n    # Check if 4n - 3 is a perfect square\n    discriminant = 4 * n - 3\n    if discriminant >= 0:\n        sqrt_discriminant = int(discriminant**0.5)\n        if sqrt_discriminant * sqrt_discriminant == discriminant:\n            # Check if k is an integer and k > 1\n            # k = (-1 + sqrt_discriminant) / 2\n            if (-1 + sqrt_discriminant) % 2 == 0:\n                k = (-1 + sqrt_discriminant) // 2\n                if k > 1:\n                    print(\"YES\")\n                    return\n\n    # Case 2: m >= 3\n    # n = 1 + k + k^2 + ... + k^(m-1) = (k^m - 1) / (k - 1)\n    # n(k - 1) = k^m - 1\n    # nk - n = k^m - 1\n    # nk - k^m = n - 1\n    # k(n - k^(m-1)) = n - 1\n\n    # Since k > 1, the smallest k is 2.\n    # The smallest m is 3 (because m must be at least 2, and we handled m=2 already).\n    # Smallest n for k=2, m=3: 1 + 2 + 4 = 7\n    # Smallest n for k=2, m=4: 1 + 2 + 4 + 8 = 15\n    # Smallest n for k=3, m=3: 1 + 3 + 9 = 13\n    \n    # Iterate over possible values of m (number of levels in the snowflake minus 1)\n    # Since n <= 10^18, k^m <= n.\n    # If k = 2, 2^m <= 10^18 => m <= log2(10^18) = 18 * log2(10) approx 18 * 3.32 = 59.79. So m up to 60.\n    # If k = 10^9, m = 2 (already handled)\n    # If k = 10^6, m = 3 (1 + 10^6 + 10^12)\n    # If k = 10^4, m = 4 (1 + 10^4 + 10^8 + 10^12)\n    # Max m is around 60.\n    \n    # Iterate m from 3 to 60 (or slightly more to be safe, e.g., 64)\n    for m in range(3, 65): # k^m <= n implies m <= log_k(n). Smallest k is 2. log_2(10^18) approx 59.79.\n        # We need to find k such that n = (k^m - 1) / (k - 1)\n        # This is equivalent to n(k-1) = k^m - 1\n        # We can use binary search for k.\n        \n        # Lower bound for k is 2.\n        # Upper bound for k: k^m < n => k < n^(1/m)\n        # For m=3, k < (10^18)^(1/3) = 10^6\n        # For m=60, k < (10^18)^(1/60) = (10^(18/60)) = 10^(0.3) approx 2.\n        \n        low = 2\n        high = int(n**(1/m)) + 2 # Add some buffer for floating point inaccuracies\n        \n        # A tighter upper bound for high: if k >= 2, then sum is at least 1 + k + k^2 + ... + k^(m-1) > k^(m-1).\n        # So k^(m-1) < n => k < n^(1/(m-1)).\n        # high = int(n**(1/(m-1))) + 2\n        # For m=3, high = int(n**(1/2)) + 2. Max 10^9 + 2.\n        # For m=60, high = int(n**(1/59)) + 2. Max 2 + 2 = 4.\n\n        # Let's use a conservative upper bound for high.\n        # Max k for m=3: n = 1+k+k^2, k approx sqrt(n). Max sqrt(10^18) = 10^9.\n        # Max k for m=60: n = 1+k+...+k^59. k approx n^(1/59). Max (10^18)^(1/59) approx 2.\n        # So high can be up to 10^9.\n        # Binary search for k in [2, 10^9 + 7] (a safe upper bound)\n        \n        # The sum is 1 + k + k^2 + ... + k^(m-1)\n        # Max k for m=3 is 10^6.\n        # For k=10^6, m=3, n = 1 + 10^6 + 10^12.\n        # For k=10^5, m=4, n = 1 + 10^5 + 10^10 + 10^15.\n        # For k=10^4, m=5, n = 1 + 10^4 + 10^8 + 10^12 + 10^16.\n        # For k=10^3, m=6, n = 1 + 10^3 + 10^6 + 10^9 + 10^12 + 10^15.\n        # For k=10^2, m=9, n = 1 + ... + 10^16.\n        # For k=10, m=18, n = 1 + ... + 10^17.\n        # For k=2, m=60, n = 1 + ... + 2^59.\n        \n        # The maximum value for k is sqrt(n) for m=3, which is 10^9.\n        # So, high should be around 10^9.\n        # Let's set a practical upper bound for binary search.\n        # If k >= 2, then (k^m - 1) / (k - 1) >= 1 + k + k^2.\n        # So n >= 1 + k + k^2. Approx n >= k^2. So k <= sqrt(n).\n        # high = int(n**0.5) + 2 is a safe upper bound for k for any m >= 3.\n        # Max value for high is 10^9 + 2.\n        high = int(n**0.5) + 2\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if mid <= 1: # k must be > 1\n                low = 2\n                continue\n            \n            current_sum = 0\n            term = 1\n            overflow = False\n            for _ in range(m):\n                current_sum += term\n                if _ < m - 1: # Check for overflow before multiplying for the next term\n                    if n // mid < term: # term * mid > n (potential overflow or exceeds n)\n                        overflow = True\n                        break\n                    term *= mid\n            \n            if overflow or current_sum > n:\n                high = mid - 1\n            elif current_sum < n:\n                low = mid + 1\n            else: # current_sum == n\n                print(\"YES\")\n                return\n\n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()"}
{"task_id": "E2H_CF270E", "completion": "import sys\n\nsys.setrecursionlimit(2 * 10**5 + 50)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_data = []\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_data.append((u, v, c))\n\n    ans = [0] * m\n    balance = [0] * (n + 1)\n    visited_edge = [False] * m\n\n    def dfs(u):\n        for v, c, edge_idx in adj[u]:\n            if not visited_edge[edge_idx]:\n                visited_edge[edge_idx] = True\n                dfs(v)\n\n                if u == 1:\n                    # Source vertex, all flow must go out\n                    # If balance[v] > 0, it means flow came from v to u, which is wrong for source\n                    # So we must direct u -> v\n                    if balance[v] > 0:\n                        ans[edge_idx] = 0 # u -> v\n                        balance[u] += c\n                        balance[v] -= c\n                    else:\n                        ans[edge_idx] = 1 # v -> u\n                        balance[u] -= c\n                        balance[v] += c\n                elif u == n:\n                    # Sink vertex, all flow must come in\n                    # If balance[v] < 0, it means flow went from u to v, which is wrong for sink\n                    # So we must direct v -> u\n                    if balance[v] < 0:\n                        ans[edge_idx] = 1 # v -> u\n                        balance[u] += c\n                        balance[v] -= c\n                    else:\n                        ans[edge_idx] = 0 # u -> v\n                        balance[u] -= c\n                        balance[v] += c\n                else:\n                    # Intermediate vertex, balance must be 0\n                    # If balance[v] > 0, it means flow came from v to u\n                    # To balance v, we need flow u -> v\n                    if balance[v] > 0:\n                        ans[edge_idx] = 0 # u -> v\n                        balance[u] += c\n                        balance[v] -= c\n                    else:\n                        ans[edge_idx] = 1 # v -> u\n                        balance[u] -= c\n                        balance[v] += c\n\n    dfs(1)\n\n    # The problem guarantees that vertex 1 has no incoming edges.\n    # Our DFS processes edges from leaves towards the root (1).\n    # For any edge (u, v) where v is a child of u in the DFS tree:\n    #   When processing u, after dfs(v) returns, balance[v] contains the net flow\n    #   that *needs to exit* the subtree rooted at v through the edge (u, v).\n    #   If balance[v] > 0, it means flow c came from v to u (v -> u).\n    #   To satisfy balance[v] > 0, we must direct flow from u to v.\n    #   So, if balance[v] > 0, we set ans[edge_idx] = 0 (u -> v).\n    #   This adds c to balance[u] and subtracts c from balance[v].\n    #   If balance[v] <= 0, it means flow c came from u to v (u -> v).\n    #   To satisfy balance[v] <= 0, we must direct flow from v to u.\n    #   So, if balance[v] <= 0, we set ans[edge_idx] = 1 (v -> u).\n    #   This subtracts c from balance[u] and adds c to balance[v].\n    # This logic applies to intermediate vertices (1 < u < n).\n\n    # The special conditions for source (1) and sink (n) are:\n    # 1. Vertex 1 has no incoming edges. This means all flow through edges connected to 1 must be outgoing from 1.\n    # 2. Vertex n has no outgoing edges. This means all flow through edges connected to n must be incoming to n.\n\n    # Let's re-think the DFS strategy.\n    # The problem states \"vertex with number 1 has no incoming edges\".\n    # And \"the obtained directed graph does not have cycles\".\n    # This implies a DAG. A natural way to get a DAG is to use a topological sort or a DFS-based approach.\n\n    # Let's use a standard DFS approach where we try to direct edges.\n    # We need to ensure balance at intermediate nodes and specific conditions for 1 and n.\n    # A common technique for flow problems on trees (or tree-like structures)\n    # is to compute the net flow for subtrees.\n\n    # Let's use a modified DFS.\n    # `flow_out_of_subtree[u]` will be the net flow that needs to exit the subtree rooted at `u`\n    # through the edge connecting `u` to its parent in the DFS tree.\n    # A positive value means flow `u -> parent`, a negative value means flow `parent -> u`.\n\n    visited = [False] * (n + 1)\n    ans = [0] * m # 0 for u -> v, 1 for v -> u\n\n    def dfs_flow(u, parent_edge_idx=-1):\n        visited[u] = True\n        current_node_balance = 0 # Net flow that needs to leave u to satisfy its subtree\n\n        for v, c, edge_idx in adj[u]:\n            if not visited[v]:\n                # This is a tree edge, v is a child of u\n                child_subtree_net_flow = dfs_flow(v, edge_idx)\n\n                # Now we decide the direction of edge (u, v) with flow c\n                # child_subtree_net_flow is the net flow that needs to exit the subtree of v\n                # through the edge (u, v).\n                # If child_subtree_net_flow > 0, it means flow needs to go from v to u (v -> u).\n                # To satisfy this, we must direct the edge u -> v.\n                # So, if child_subtree_net_flow > 0, we set ans[edge_idx] = 0 (u -> v).\n                # This contributes +c to current_node_balance (flow leaves u).\n                # If child_subtree_net_flow <= 0, it means flow needs to go from u to v (u -> v).\n                # To satisfy this, we must direct the edge v -> u.\n                # So, if child_subtree_net_flow <= 0, we set ans[edge_idx] = 1 (v -> u).\n                # This contributes -c to current_node_balance (flow enters u).\n                # Wait, this logic is inverted.\n                # If child_subtree_net_flow > 0, it means the subtree of v needs to send flow UPWARDS (towards u).\n                # So, the edge should be v -> u.\n                # If child_subtree_net_flow <= 0, it means the subtree of v needs to receive flow DOWNWARDS (from u).\n                # So, the edge should be u -> v.\n\n                # Let's define `child_subtree_net_flow` as the sum of `c` for edges directed `v -> ...` minus sum of `c` for edges directed `... -> v` within `v`'s subtree, plus the flow across `(u,v)`.\n                # More simply, `child_subtree_net_flow` is the net flow *out* of `v`'s subtree.\n                # If `child_subtree_net_flow` is positive, it means the subtree of `v` has an excess of flow that needs to exit via `(u,v)`. So, `v -> u`.\n                # If `child_subtree_net_flow` is negative, it means the subtree of `v` has a deficit of flow that needs to be supplied via `(u,v)`. So, `u -> v`.\n\n                if u == 1:\n                    # Source node: all flow must go out.\n                    # So for edge (1, v), it must be 1 -> v.\n                    ans[edge_idx] = 0 # 1 -> v\n                    current_node_balance += c\n                elif u == n:\n                    # Sink node: all flow must come in.\n                    # So for edge (n, v), it must be v -> n.\n                    ans[edge_idx] = 1 # v -> n\n                    current_node_balance -= c # flow comes into n, so it contributes negatively to what needs to leave n\n                else:\n                    # Intermediate node: flow balance must be 0.\n                    # If child_subtree_net_flow > 0, it means v's subtree wants to send flow v -> u.\n                    # So we direct v -> u. This reduces current_node_balance.\n                    if child_subtree_net_flow > 0:\n                        ans[edge_idx] = 1 # v -> u\n                        current_node_balance -= c\n                    else:\n                        # child_subtree_net_flow <= 0, v's subtree wants to receive flow u -> v.\n                        # So we direct u -> v. This increases current_node_balance.\n                        ans[edge_idx] = 0 # u -> v\n                        current_node_balance += c\n\n        return current_node_balance\n\n    # Start DFS from node 1.\n    # The return value of dfs_flow(1) will be the total net flow leaving node 1.\n    # For node 1, all edges must be outgoing.\n    # For node n, all edges must be incoming.\n    # For other nodes, incoming_flow = outgoing_flow.\n\n    # The previous logic for dfs_flow was almost correct, but the special handling for 1 and n needs to be consistent.\n    # Let's redefine `dfs_flow(u)` to return the sum of flows that *must* exit `u`'s subtree through its parent edge.\n    # If `u` is the source (1), it must have 0 incoming flow.\n    # If `u` is the sink (n), it must have 0 outgoing flow.\n\n    # Let's use `balance[u]` to track the net flow that has already been directed within the subtree of `u` (excluding the edge to its parent).\n    # When `dfs_flow(u)` returns, `balance[u]` should represent the total flow that needs to be pushed *out* of `u` towards its parent.\n\n    # Revised DFS:\n    # `dfs(u, p)`: processes node `u`, where `p` is its parent in the DFS tree.\n    # It returns the net flow that needs to leave the subtree of `u` through the edge `(u, p)`.\n    # A positive value means flow `u -> p`, negative means `p -> u`.\n    # For source (1), all edges are outgoing.\n    # For sink (n), all edges are incoming.\n    # For other nodes, balance is 0.\n\n    # We can use a DFS that starts from 1.\n    # For each node `u`, we calculate `current_flow_balance[u]`.\n    # This balance will track `sum(incoming_flow) - sum(outgoing_flow)` for edges within its subtree.\n    # When we are about to direct an edge `(u, v)` (where `v` is a child of `u` in DFS tree):\n    # We first recursively call `dfs(v)`. This will determine directions for edges within `v`'s subtree and return `current_flow_balance[v]`.\n    # This `current_flow_balance[v]` is the net flow that needs to be balanced by the edge `(u, v)`.\n    # If `current_flow_balance[v] > 0`, it means `v`'s subtree has an excess of flow that needs to go out through `(u, v)`. So `v -> u`.\n    # If `current_flow_balance[v] < 0`, it means `v`'s subtree has a deficit of flow that needs to come in through `(u, v)`. So `u -> v`.\n    # If `current_flow_balance[v] == 0`, we can pick either direction. Let's say `u -> v`.\n\n    # The special conditions for 1 and n are crucial.\n    # Node 1 has no incoming edges. Node n has no outgoing edges.\n    # This implies that the net flow from node 1's subtree must be exactly the total flow, and it must exit via node 1.\n    # The net flow into node n's subtree must be exactly the total flow, and it must enter via node n.\n\n    # Let's try the first DFS approach again, but with careful definition of `balance`.\n    # `balance[u]` = `sum(flow_in_to_u) - sum(flow_out_of_u)` for edges *already directed*.\n    # When `dfs(u)` returns, `balance[u]` should represent the net flow that *must* be balanced by the edge to its parent.\n\n    # `dfs(u)` returns `net_flow_from_subtree_to_parent_of_u`.\n    # This value is `sum(flow_out_of_subtree) - sum(flow_in_to_subtree)`.\n    # A positive value means flow is pushed *up* towards the parent.\n    # A negative value means flow is pulled *down* from the parent.\n\n    visited = [False] * (n + 1)\n    ans = [0] * m\n    node_balance = [0] * (n + 1) # This will store the net flow that needs to be balanced for each node.\n                                 # Positive means needs to send flow out. Negative means needs to receive flow.\n\n    def dfs_recursive(u):\n        visited[u] = True\n        \n        # Iterate over neighbors\n        for v, c, edge_idx in adj[u]:\n            if not visited[v]:\n                # v is a child in the DFS tree\n                dfs_recursive(v) # Recursively process child subtree\n\n                # After child v's subtree is processed, node_balance[v] holds the net flow\n                # that needs to be balanced by the edge (u, v).\n                # A positive node_balance[v] means v's subtree has an excess of flow\n                # that needs to go out through (u, v). So, the edge should be v -> u.\n                # A negative node_balance[v] means v's subtree has a deficit of flow\n                # that needs to be supplied through (u, v). So, the edge should be u -> v.\n                # If node_balance[v] is 0, we can choose arbitrarily, let's say u -> v.\n\n                if node_balance[v] > 0:\n                    # Flow needs to go from v to u.\n                    # So, direct v -> u. ans[edge_idx] = 1 if (u,v) is original (a,b),\n                    # or 0 if (v,u) is original (a,b).\n                    # edges_data[edge_idx] stores (a_i, b_i, c_i)\n                    original_u, original_v, _ = edges_data[edge_idx]\n                    if original_u == u: # Original edge was u-v\n                        ans[edge_idx] = 1 # v -> u\n                    else: # Original edge was v-u\n                        ans[edge_idx] = 0 # v -> u (from original perspective)\n                    \n                    node_balance[u] += node_balance[v] - c # The flow that came into u from v, but this is confusing.\n                                                            # It's easier to track current_balance for u.\n                                                            # Let's redefine `node_balance[u]` as the current\n                                                            # net flow leaving u for its parent.\n\n                else: # node_balance[v] <= 0\n                    # Flow needs to go from u to v.\n                    # So, direct u -> v.\n                    original_u, original_v, _ = edges_data[edge_idx]\n                    if original_u == u: # Original edge was u-v\n                        ans[edge_idx] = 0 # u -> v\n                    else: # Original edge was v-u\n                        ans[edge_idx] = 1 # u -> v (from original perspective)\n                    \n                    # No, this is not correct.\n                    # The value `node_balance[v]` is the sum of (flow_out - flow_in) for the subtree of v.\n                    # If `node_balance[v]` is positive, it means the subtree of v has an excess of flow that needs to exit via (u,v).\n                    # So the edge must be v -> u. This means flow `c` enters `u`.\n                    # If `node_balance[v]` is negative, it means the subtree of v has a deficit of flow that needs to enter via (u,v).\n                    # So the edge must be u -> v. This means flow `c` leaves `u`.\n                    # If `node_balance[v]` is zero, it means the subtree of v is perfectly balanced.\n                    # In this case, we can direct `u -> v` (arbitrary choice for 0 balance).\n                    # This means flow `c` leaves `u`.\n\n                    # Let's make `node_balance[u]` represent the sum of `c` for edges directed `u -> ...` minus `sum` of `c` for edges directed `... -> u` within `u`'s subtree (excluding the edge to parent).\n\n                    # Let's restart the DFS logic with a clear definition of `balance[u]`.\n                    # `balance[u]` will be the net flow *out* of `u`'s subtree (i.e., `sum(outgoing) - sum(incoming)`).\n                    # When `dfs(u)` returns, `balance[u]` should be the total flow that must pass through `u` to its parent.\n\n    # Final DFS attempt:\n    # `dfs(u)` returns the net flow that needs to be sent *from* `u` to its parent.\n    # A positive value means `u -> parent`, a negative value means `parent -> u`.\n    # This value is `sum(flow_out_of_u_to_children) - sum(flow_in_to_u_from_children)`.\n    # For source (1), all flow must be outgoing.\n    # For sink (n), all flow must be incoming.\n    # For intermediate nodes, net flow must be 0.\n\n    # Let's use `current_balance[u]` to track `sum(flow_out) - sum(flow_in)` for edges within the subtree rooted at `u`.\n    # When `dfs(u, p)` returns, `current_balance[u]` will be the net flow from `u`'s subtree that needs to go through the edge `(u, p)`.\n\n    visited = [False] * (n + 1)\n    ans = [0] * m\n    \n    # `dfs(u)` returns the net flow leaving `u`'s subtree through the edge to its parent.\n    # Positive means flow `u -> parent`, negative means flow `parent -> u`.\n    def dfs_final(u):\n        visited[u] = True\n        \n        # `net_flow_from_children` will accumulate the flow that needs to be balanced by `u`\n        # from its children's subtrees.\n        net_flow_from_children = 0 \n        \n        for v, c, edge_idx in adj[u]:\n            if not visited[v]:\n                # v is a child of u in the DFS tree\n                child_net_flow = dfs_final(v) # This is the net flow from v's subtree to u.\n                                             # Positive: v -> u. Negative: u -> v.\n                \n                # We need to decide direction for edge (u, v)\n                # If child_net_flow > 0, it means v's subtree wants to send flow v -> u.\n                # So we direct v -> u.\n                # If child_net_flow <= 0, it means v's subtree wants to receive flow u -> v.\n                # So we direct u -> v. (This handles the 0 case by making it u -> v).\n                \n                original_u, original_v, _ = edges_data[edge_idx]\n                \n                if child_net_flow > 0:\n                    # Flow v -> u.\n                    if original_u == u: # Original edge was u-v\n                        ans[edge_idx] = 1 # v -> u\n                    else: # Original edge was v-u\n                        ans[edge_idx] = 0 # v -> u\n                    net_flow_from_children += c # Flow c enters u\n                else:\n                    # Flow u -> v.\n                    if original_u == u: # Original edge was u-v\n                        ans[edge_idx] = 0 # u -> v\n                    else: # Original edge was v-u\n                        ans[edge_idx] = 1 # u -> v\n                    net_flow_from_children -= c # Flow c leaves u\n\n        # Now `net_flow_from_children` represents the sum of flows that entered `u` from its children\n        # minus the sum of flows that left `u` to its children.\n        # This is the flow that `u` needs to pass to its parent.\n        \n        # Special handling for source (1) and sink (n).\n        if u == 1:\n            # Source 1: All flow must be outgoing.\n            # `net_flow_from_children` must be the total flow leaving 1.\n            # It should be positive.\n            return net_flow_from_children\n        elif u == n:\n            # Sink n: All flow must be incoming.\n            # `net_flow_from_children` must be the total flow entering n.\n            # It should be negative.\n            return net_flow_from_children\n        else:\n            # Intermediate node: Net flow must be 0.\n            # So, `net_flow_from_children` must be 0 for this node to be balanced.\n            # This is guaranteed by the problem statement (a solution always exists).\n            return net_flow_from_children\n\n    # Start DFS from node 1.\n    # The return value of dfs_final(1) will be the total flow in the network.\n    dfs_final(1)\n\n    for res in ans:\n        sys.stdout.write(str(res) + '\\n')\n\nsolve()"}
{"task_id": "E2H_CF808E", "completion": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    items_w1 = []\n    items_w2 = []\n    items_w3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            items_w1.append(c)\n        elif w == 2:\n            items_w2.append(c)\n        else:\n            items_w3.append(c)\n\n    items_w1.sort(reverse=True)\n    items_w2.sort(reverse=True)\n    items_w3.sort(reverse=True)\n\n    prefix_sum_w1 = [0] * (len(items_w1) + 1)\n    for i in range(len(items_w1)):\n        prefix_sum_w1[i+1] = prefix_sum_w1[i] + items_w1[i]\n\n    prefix_sum_w2 = [0] * (len(items_w2) + 1)\n    for i in range(len(items_w2)):\n        prefix_sum_w2[i+1] = prefix_sum_w2[i] + items_w2[i]\n\n    prefix_sum_w3 = [0] * (len(items_w3) + 1)\n    for i in range(len(items_w3)):\n        prefix_sum_w3[i+1] = prefix_sum_w3[i] + items_w3[i]\n\n    max_cost = 0\n\n    # Iterate over the number of items with weight 3\n    for k3 in range(len(items_w3) + 1):\n        current_weight_w3 = k3 * 3\n        current_cost_w3 = prefix_sum_w3[k3]\n\n        if current_weight_w3 > m:\n            break\n\n        remaining_weight = m - current_weight_w3\n        \n        # Iterate over the number of items with weight 2\n        # We can optimize this by finding the best k2 for a given remaining_weight\n        # using a two-pointer approach or by iterating and finding the best k1.\n        # Since M is up to 300000, and N up to 100000, a direct iteration for k2 might be too slow if N_w2 is large.\n        # But M/2 is 150000, so iterating k2 up to M/2 is fine.\n        \n        # Let's try iterating k2 and finding the best k1\n        for k2 in range(len(items_w2) + 1):\n            current_weight_w2 = k2 * 2\n            current_cost_w2 = prefix_sum_w2[k2]\n\n            if current_weight_w2 > remaining_weight:\n                break\n\n            remaining_weight_for_w1 = remaining_weight - current_weight_w2\n            \n            # Find the maximum number of items with weight 1\n            k1 = min(len(items_w1), remaining_weight_for_w1)\n            current_cost_w1 = prefix_sum_w1[k1]\n\n            total_current_cost = current_cost_w3 + current_cost_w2 + current_cost_w1\n            max_cost = max(max_cost, total_current_cost)\n            \n    sys.stdout.write(str(max_cost) + '\\n')\n\nsolve()"}
{"task_id": "E2H_CF409I", "completion": "import sys\n\ndef solve():\n    name = sys.stdin.readline().strip()\n\n    def parse_expression(expr_str):\n        tokens = []\n        i = 0\n        while i < len(expr_str):\n            if expr_str[i] == '_':\n                count = 0\n                while i < len(expr_str) and expr_str[i] == '_':\n                    count += 1\n                    i += 1\n                tokens.append(('var', count))\n            elif expr_str[i] in '+-*/':\n                tokens.append(('op', expr_str[i]))\n                i += 1\n            else:\n                i += 1 # Should not happen with valid input\n        return tokens\n\n    def evaluate_expression(tokens, var_values, start_idx):\n        if not tokens:\n            return 0, start_idx\n\n        # Convert to RPN\n        output = []\n        operators = []\n        precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n\n        for token_type, token_val in tokens:\n            if token_type == 'var':\n                output.append(('val', var_values[start_idx]))\n                start_idx += 1\n            elif token_type == 'op':\n                while (operators and operators[-1][0] == 'op' and\n                       precedence.get(operators[-1][1], 0) >= precedence.get(token_val, 0)):\n                    output.append(operators.pop())\n                operators.append((token_type, token_val))\n        while operators:\n            output.append(operators.pop())\n\n        # Evaluate RPN\n        stack = []\n        for token_type, token_val in output:\n            if token_type == 'val':\n                stack.append(token_val)\n            elif token_type == 'op':\n                if len(stack) < 2:\n                    return None, None # Malformed expression\n                b = stack.pop()\n                a = stack.pop()\n                if token_val == '+':\n                    stack.append(a + b)\n                elif token_val == '-':\n                    stack.append(a - b)\n                elif token_val == '*':\n                    stack.append(a * b)\n                elif token_val == '/':\n                    if b == 0:\n                        return None, None # Division by zero\n                    stack.append(a // b)\n        if len(stack) != 1:\n            return None, None # Malformed expression\n        return stack[0], start_idx\n\n    parts = name.split(':-')\n    expression_part = parts[0][2:-1] # Remove '?(' and ')'\n    constraints_part = parts[1].strip()\n\n    expression_tokens = parse_expression(expression_part)\n\n    constraints = []\n    if constraints_part != '.':\n        for constraint_str in constraints_part[:-1].split(','):\n            constraint_str = constraint_str.strip()\n            if '>' in constraint_str:\n                op = '>'\n            elif '<' in constraint_str:\n                op = '<'\n            else:\n                continue # Should not happen with valid input\n\n            left_str, right_str = constraint_str.split(op)\n            left_tokens = parse_expression(left_str.strip())\n            right_tokens = parse_expression(right_str.strip())\n            constraints.append((left_tokens, op, right_tokens))\n\n    num_vars = 0\n    for token_type, token_val in expression_tokens:\n        if token_type == 'var':\n            num_vars += token_val\n    for left_tokens, _, right_tokens in constraints:\n        for token_type, token_val in left_tokens:\n            if token_type == 'var':\n                num_vars += token_val\n        for token_type, token_val in right_tokens:\n            if token_type == 'var':\n                num_vars += token_val\n\n    if num_vars == 0:\n        # Evaluate expression\n        val, _ = evaluate_expression(expression_tokens, [], 0)\n        if val is None:\n            sys.stdout.write(\"false\\n\")\n            return\n\n        # Check constraints\n        all_constraints_met = True\n        for left_tokens, op, right_tokens in constraints:\n            left_val, _ = evaluate_expression(left_tokens, [], 0)\n            right_val, _ = evaluate_expression(right_tokens, [], 0)\n            if left_val is None or right_val is None:\n                all_constraints_met = False\n                break\n            if op == '>' and not (left_val > right_val):\n                all_constraints_met = False\n                break\n            if op == '<' and not (left_val < right_val):\n                all_constraints_met = False\n                break\n        if all_constraints_met:\n            sys.stdout.write(\"\\n\") # Empty string of variables\n        else:\n            sys.stdout.write(\"false\\n\")\n        return\n\n    # Backtracking search for variable values\n    min_solution = None\n\n    def find_solution(k, current_values):\n        nonlocal min_solution\n\n        if min_solution is not None and tuple(current_values) >= min_solution:\n            return\n\n        if k == num_vars:\n            # All variables assigned, now evaluate and check constraints\n            var_idx = 0\n            # First evaluate the main expression\n            expr_val, new_var_idx = evaluate_expression(expression_tokens, current_values, var_idx)\n            if expr_val is None:\n                return\n\n            # Then evaluate and check all constraints\n            all_constraints_met = True\n            for left_tokens, op, right_tokens in constraints:\n                left_val, temp_idx = evaluate_expression(left_tokens, current_values, new_var_idx)\n                if left_val is None:\n                    all_constraints_met = False\n                    break\n                right_val, new_var_idx = evaluate_expression(right_tokens, current_values, temp_idx)\n                if right_val is None:\n                    all_constraints_met = False\n                    break\n\n                if op == '>' and not (left_val > right_val):\n                    all_constraints_met = False\n                    break\n                if op == '<' and not (left_val < right_val):\n                    all_constraints_met = False\n                    break\n\n            if all_constraints_met:\n                if min_solution is None or tuple(current_values) < min_solution:\n                    min_solution = tuple(current_values)\n            return\n\n        for digit in range(10):\n            current_values.append(digit)\n            find_solution(k + 1, current_values)\n            current_values.pop()\n\n    find_solution(0, [])\n\n    if min_solution is None:\n        sys.stdout.write(\"false\\n\")\n    else:\n        sys.stdout.write(\"\".join(map(str, min_solution)) + \"\\n\")\n\nsolve()"}
{"task_id": "E2H_CF151A", "completion": "import sys\n\ndef solve():\n    line = sys.stdin.readline().split()\n    n, k, l, c, d, p, nl, np = map(int, line)\n\n    # Calculate total milliliters of drink available\n    total_drink_ml = k * l\n\n    # Calculate total lime slices available\n    total_lime_slices = c * d\n\n    # Calculate how many toasts can be made based on drink\n    toasts_from_drink = total_drink_ml // (n * nl)\n\n    # Calculate how many toasts can be made based on lime slices\n    toasts_from_lime = total_lime_slices // n\n\n    # Calculate how many toasts can be made based on salt\n    toasts_from_salt = p // (n * np)\n\n    # The number of toasts each friend can make is limited by the minimum of these three\n    # and then divided by n (since the problem asks for toasts per friend,\n    # but the intermediate calculations are for the group as a whole,\n    # and the example implies we take the minimum overall toasts and then divide by n\n    # if the question is \"how many toasts can *each friend* make *such that they all drink the same amount*\"\n    # This interpretation is tricky. Let's re-read the example:\n    # \"Overall the friends have 4*5=20 milliliters of the drink, it is enough to make 20/3=6 toasts.\"\n    # Here, 20/3 is 6 toasts for the *entire group*, where each toast requires 3ml (nl).\n    # This implies that 6 toasts is the total number of toasts the *group* can make.\n    # \"The limes are enough for 10*8=80 toasts and the salt is enough for 100/1=100 toasts.\"\n    # These are also for the *entire group*.\n    # \"However, there are 3 friends in the group, so the answer is min(6, 80, 100) / 3 = 2.\"\n    # This confirms that we calculate the total number of toasts the *group* can make based on each resource,\n    # take the minimum of these, and then divide by the number of friends (n) to get how many toasts *each friend* can make.\n\n    # Re-calculating based on the example's logic:\n    # How many toasts can be made *in total* (for the entire group) based on drink:\n    # Each toast for the group requires n * nl ml of drink. This is incorrect based on example.\n    # Example says: 20ml / 3ml_per_friend = 6 toasts. This means 3ml is nl, the amount *one friend* needs.\n    # So, total_drink_ml / nl gives total individual portions.\n    # If there are N friends, and each needs 1 portion for 1 toast, then the total number of toasts\n    # that can be made by the *group* is min(total_drink_portions, total_lime_portions, total_salt_portions) / n.\n\n    # Let's use the example's logic explicitly:\n    # Total drink portions (how many individual \"nl\" amounts are there):\n    individual_drink_portions = total_drink_ml // nl\n\n    # Total lime slices available (how many individual \"1 slice\" amounts are there):\n    individual_lime_portions = total_lime_slices // 1 # each friend needs 1 slice\n\n    # Total salt portions (how many individual \"np\" amounts are there):\n    individual_salt_portions = p // np\n\n    # Now, find the minimum number of individual portions available across all resources.\n    # This minimum represents the total number of toasts that can be made if only one friend was drinking.\n    # Since there are 'n' friends and they all drink the same amount, this total must be divided among them.\n    min_individual_portions = min(individual_drink_portions, individual_lime_portions, individual_salt_portions)\n\n    # Each friend makes min_individual_portions / n toasts.\n    result = min_individual_portions // n\n    print(result)\n\nsolve()"}
{"task_id": "E2H_CF339B", "completion": "def solve():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    current_house = 1\n    total_time = 0\n\n    for task_house in a:\n        if task_house >= current_house:\n            total_time += (task_house - current_house)\n        else:\n            total_time += (n - current_house + task_house)\n        current_house = task_house\n\n    print(total_time)\n\nif __name__ == '__main__':\n    solve()"}
{"task_id": "E2H_CF88A", "completion": "def solve():\n    notes_str = input().split()\n\n    note_map = {\n        \"C\": 0, \"C#\": 1, \"D\": 2, \"D#\": 3, \"E\": 4, \"F\": 5,\n        \"F#\": 6, \"G\": 7, \"G#\": 8, \"A\": 9, \"B\": 10, \"H\": 11\n    }\n\n    notes_val = [note_map[n] for n in notes_str]\n\n    def get_distance(n1, n2):\n        return (n2 - n1 + 12) % 12\n\n    def check_major(n1, n2, n3):\n        return get_distance(n1, n2) == 4 and get_distance(n2, n3) == 3\n\n    def check_minor(n1, n2, n3):\n        return get_distance(n1, n2) == 3 and get_distance(n2, n3) == 4\n\n    import itertools\n\n    is_major = False\n    is_minor = False\n\n    for p in itertools.permutations(notes_val):\n        n1, n2, n3 = p[0], p[1], p[2]\n        if check_major(n1, n2, n3):\n            is_major = True\n            break\n        if check_minor(n1, n2, n3):\n            is_minor = True\n            break\n\n    if is_major:\n        print(\"major\")\n    elif is_minor:\n        print(\"minor\")\n    else:\n        print(\"strange\")\n\nsolve()"}
{"task_id": "E2H_CF633B", "completion": "m = int(input())\n\ndef count_trailing_zeros(n):\n    count = 0\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n    return count\n\nresults = []\nlow = 1\nhigh = 5 * m\nans = -1\n\nwhile low <= high:\n    mid = (low + high) // 2\n    zeros = count_trailing_zeros(mid)\n    if zeros >= m:\n        ans = mid\n        high = mid - 1\n    else:\n        low = mid + 1\n\nif ans == -1 or count_trailing_zeros(ans) != m:\n    print(0)\nelse:\n    start_n = ans\n    while start_n > 0 and count_trailing_zeros(start_n - 1) == m:\n        start_n -= 1\n    \n    end_n = ans\n    while count_trailing_zeros(end_n + 1) == m:\n        end_n += 1\n        \n    count = end_n - start_n + 1\n    print(count)\n    print(*(range(start_n, end_n + 1)))"}
{"task_id": "E2H_CF1767D", "completion": "n = int(input())\ns = input()\n\ncount_0 = s.count('0')\ncount_1 = s.count('1')\n\nmin_winning_skill = 2**count_0\nmax_winning_skill = 2**n - 2**count_1 + 1\n\nresult = []\nfor i in range(min_winning_skill, max_winning_skill + 1):\n    result.append(str(i))\n\nprint(' '.join(result))"}
{"task_id": "E2H_CF498A", "completion": "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nn = int(input())\n\ncount = 0\nfor _ in range(n):\n    a, b, c = map(int, input().split())\n    val1 = a * x1 + b * y1 + c\n    val2 = a * x2 + b * y2 + c\n    if (val1 > 0 and val2 < 0) or (val1 < 0 and val2 > 0):\n        count += 1\n\nprint(count)"}
{"task_id": "E2H_CF1092C", "completion": "def solve():\n    n = int(input())\n    lines = []\n    for _ in range(2 * n - 2):\n        lines.append(input())\n\n    # Group strings by length\n    strings_by_length = [[] for _ in range(n)]\n    for s in lines:\n        strings_by_length[len(s)].append(s)\n\n    # The two strings of length n-1 must be candidates for the full string\n    # One is the prefix of length n-1, the other is the suffix of length n-1\n    cand1_prefix_n_minus_1 = strings_by_length[n - 1][0]\n    cand1_suffix_n_minus_1 = strings_by_length[n - 1][1]\n\n    cand2_prefix_n_minus_1 = strings_by_length[n - 1][1]\n    cand2_suffix_n_minus_1 = strings_by_length[n - 1][0]\n\n    candidate_s1 = cand1_prefix_n_minus_1 + cand1_suffix_n_minus_1[-1]\n    candidate_s2 = cand2_prefix_n_minus_1 + cand2_suffix_n_minus_1[-1]\n\n    def check(s, original_lines):\n        # Generate all prefixes and suffixes of s\n        generated_prefixes = [s[:i] for i in range(1, n)]\n        generated_suffixes = [s[n - i:] for i in range(1, n)]\n\n        # Count occurrences of each generated string\n        counts_generated = {}\n        for p in generated_prefixes:\n            counts_generated[p] = counts_generated.get(p, 0) + 1\n        for suff in generated_suffixes:\n            counts_generated[suff] = counts_generated.get(suff, 0) + 1\n\n        # Count occurrences of each input string\n        counts_input = {}\n        for line in original_lines:\n            counts_input[line] = counts_input.get(line, 0) + 1\n\n        return counts_generated == counts_input\n\n    # Determine which candidate string is valid\n    valid_s = None\n    if check(candidate_s1, lines):\n        valid_s = candidate_s1\n    elif check(candidate_s2, lines):\n        valid_s = candidate_s2\n\n    # Now, construct the output string based on the valid_s\n    # We need to find a unique mapping for prefixes and suffixes\n    # A string is a prefix if it's s[:k] and it's not a suffix s[n-k:]\n    # Or if it's both, we need to make sure we assign P and S an equal number of times.\n\n    # Strategy: Greedily assign 'P' to the first occurrence of a prefix\n    # and 'S' to the first occurrence of a suffix, then handle conflicts.\n\n    # A better strategy:\n    # Find the unique prefix of length n-1 and unique suffix of length n-1\n    # These define the string 's'.\n    # For a string of length k:\n    # If it's s[:k] and NOT s[n-k:], it must be a prefix.\n    # If it's s[n-k:] and NOT s[:k], it must be a suffix.\n    # If it's BOTH s[:k] and s[n-k:]:\n    #   There will be two such strings in the input for this length.\n    #   One is s[:k] (prefix), one is s[n-k:] (suffix).\n    #   We need to assign one 'P' and one 'S'.\n\n    prefix_set = set()\n    suffix_set = set()\n    for i in range(1, n):\n        prefix_set.add(valid_s[:i])\n        suffix_set.add(valid_s[n - i:])\n\n    # Track which input strings have been assigned\n    assigned = [False] * (2 * n - 2)\n    result = [''] * (2 * n - 2)\n\n    # First pass: assign 'P' to unique prefixes and 'S' to unique suffixes\n    for i, line in enumerate(lines):\n        if assigned[i]:\n            continue\n\n        is_prefix = line in prefix_set\n        is_suffix = line in suffix_set\n\n        if is_prefix and not is_suffix:\n            result[i] = 'P'\n            assigned[i] = True\n        elif is_suffix and not is_prefix:\n            result[i] = 'S'\n            assigned[i] = True\n\n    # Second pass: handle strings that are both prefixes and suffixes\n    # For each length k, there are two strings in input.\n    # If s[:k] == s[n-k:], then both input strings of length k are identical.\n    # In this case, one must be 'P' and one 'S'.\n    # If s[:k] != s[n-k:], then the two input strings of length k are different.\n    # But this case should have been handled by the first pass if they are unique.\n    # The only remaining strings should be those where s[:k] == s[n-k:] for some k,\n    # or where s[:k] != s[n-k:] but both are present and we need to assign.\n\n    # A simpler approach for the second pass:\n    # For each length k from 1 to n-1, there are two input strings.\n    # One is s[:k], one is s[n-k:].\n    # We need to find which input string corresponds to which.\n    # Let's use a temporary list of (original_index, string_value) for unassigned items.\n    unassigned_indices = [i for i, val in enumerate(assigned) if not val]\n    \n    # Store original indices of prefixes and suffixes\n    original_prefix_indices = []\n    original_suffix_indices = []\n\n    for i in range(1, n):\n        p_str = valid_s[:i]\n        s_str = valid_s[n - i:]\n\n        found_p = False\n        found_s = False\n\n        for j in range(len(lines)):\n            if lines[j] == p_str and not assigned[j] and not found_p:\n                result[j] = 'P'\n                assigned[j] = True\n                found_p = True\n            elif lines[j] == s_str and not assigned[j] and not found_s:\n                result[j] = 'S'\n                assigned[j] = True\n                found_s = True\n            \n            if found_p and found_s:\n                break\n    \n    print(\"\".join(result))\n\nsolve()"}
{"task_id": "E2H_CF1146D", "completion": "import sys\nimport collections\n\ndef solve():\n    m, a, b = map(int, sys.stdin.readline().split())\n\n    if a > m:\n        print(m + 1)\n        return\n\n    ans = 0\n    \n    # Calculate f(i) for i up to a + b - 2\n    # This is the range where the DP approach is efficient\n    # The maximum value for a + b - 2 is around 2 * 10^5\n    \n    max_dp_range = min(m, a + b - 2)\n\n    if a == b:\n        # If a == b, the only reachable points are multiples of a.\n        # Within [0, x], the reachable points are {0, a, 2a, ..., ka} where ka <= x.\n        # Number of points is floor(x/a) + 1.\n        # However, the problem states \"never jumps on an integer outside the interval [0, x]\".\n        # This means if we jump k+a, k+a must be <= x. If we jump k-b, k-b must be >= 0.\n        # If a=b, and we can only jump k+a, k-a.\n        # If we jump k+a, k+a must be <= x. If we jump k-a, k-a must be >= 0.\n        # Starting at 0, we can only reach 0. To reach 'a', we must jump 0+a. This requires a <= x.\n        # To reach '2a', we must jump 'a'+a. This requires 2a <= x.\n        # So for a given x, the reachable points are {0, a, ..., k*a} where k*a <= x.\n        # The number of such points is floor(x/a) + 1.\n        # This is true if a=b, because any point k*a can be reached by k jumps of +a.\n        # Any jump k*a - a is (k-1)*a >= 0. Any jump k*a + a is (k+1)*a <= x.\n        # So f(i) = floor(i/a) + 1.\n        \n        # This is a special case. The general DP below will work, but this is faster.\n        # However, the problem statement \"never jumps on an integer outside the interval [0, x]\"\n        # is tricky. If a=b, and we are at 0, we can jump to 'a'. If a <= x, then we can reach 'a'.\n        # If we are at 'a', we can jump to '2a' (if 2a <= x) or '0' (if 0 >= 0).\n        # So all multiples of 'a' up to 'x' are reachable.\n        # The number of reachable points is floor(x/a) + 1.\n        \n        # This means f(i) = floor(i/a) + 1.\n        # Sum_{i=0 to m} (floor(i/a) + 1)\n        # This is sum_{i=0 to m} floor(i/a) + (m+1)\n        \n        # The sum floor(i/a) for i=0 to m can be calculated by grouping.\n        # For k = 0, ..., a-1, floor(i/a) = 0. (a terms)\n        # For k = a, ..., 2a-1, floor(i/a) = 1. (a terms)\n        # ...\n        # For k = q*a, ..., (q+1)*a-1, floor(i/a) = q. (a terms)\n        \n        # Number of full blocks of 'a' terms: q_max = m // a\n        # Sum for full blocks: a * (0 + 1 + ... + (q_max - 1)) = a * q_max * (q_max - 1) / 2\n        # Remaining terms: m % a + 1 terms, from q_max * a to m.\n        # Each of these terms has floor(i/a) = q_max.\n        # Sum for remaining terms: (m % a + 1) * q_max\n        \n        # Total sum = (m+1) + sum_{i=0 to m} floor(i/a)\n        \n        # Let's verify the f(i) definition.\n        # \"if it never jumps on an integer outside the interval [0, x]\"\n        # This means for a specific x, we can only reach points p such that 0 <= p <= x.\n        # If a=b, from 0, we can reach a (if a<=x). From a, we can reach 2a (if 2a<=x) or 0.\n        # So yes, all multiples of a up to x are reachable.\n        \n        # Sum_i=0^m (floor(i/a) + 1)\n        \n        # Calculate sum_i=0^m floor(i/a)\n        total_floor_sum = 0\n        q = m // a\n        \n        # Sum for full blocks: a * (0 + 1 + ... + (q-1))\n        if q > 0:\n            total_floor_sum += a * (q * (q - 1) // 2)\n        \n        # Sum for remaining terms: (m % a + 1) terms, each contributing q\n        total_floor_sum += (m % a + 1) * q\n        \n        ans = total_floor_sum + (m + 1)\n        print(ans)\n        return\n\n    # DP for f(i) for i in [0, max_dp_range]\n    # dp[j] stores the minimum number of +a jumps needed to reach j,\n    # starting from 0, only using +a and -b jumps, and staying within [0, current_x].\n    # We want to find the set of reachable points for a given x.\n    # The set of reachable points is { k*a - l*b | k, l >= 0, k*a - l*b >= 0 }.\n    # This is equivalent to points of the form gcd(a,b) * C.\n    # Specifically, it's { g*C | g*C >= 0, g*C is reachable from 0 }.\n    # All reachable points are multiples of gcd(a,b).\n    # Since we start at 0, all reachable points are of the form k*a - l*b.\n    # The smallest non-negative value of k*a - l*b is gcd(a,b).\n    # All multiples of gcd(a,b) are reachable.\n    # So the set of all possible points is {0, g, 2g, 3g, ...} where g = gcd(a,b).\n    # The constraint \"never jumps on an integer outside the interval [0, x]\" is crucial.\n    # This means for a given x, we can only reach points p such that 0 <= p <= x.\n    # And all intermediate points in any path to p must also be in [0, x].\n\n    # We use BFS to find reachable points for a given x.\n    # However, we need to find f(x) for all x up to m.\n    # The values f(x) are non-decreasing.\n    # f(x) = number of reachable points in [0, x].\n\n    # Let's define dp[rem] as the minimum value 'v' such that 'v' is reachable, and 'v' % gcd(a,b) == rem.\n    # No, this is not quite right.\n    # Let's use a standard BFS for shortest path in a graph where nodes are remainders mod gcd(a,b).\n    # Or, simpler, BFS on positions, but we need to track the maximum value visited.\n\n    # Let's consider the points modulo gcd(a,b).\n    # Any reachable point p must be a multiple of g = gcd(a,b).\n    # So we are interested in points 0, g, 2g, ...\n    # Let's normalize by dividing by g. Then we are looking for points 0, 1, 2, ...\n    # with jumps +a/g and -b/g.\n    # This doesn't change the problem, just makes numbers smaller.\n    # Let's just use original a, b.\n\n    # The maximum value reachable from 0 using only +a jumps is k*a.\n    # The maximum value reachable using +a and -b jumps:\n    # From 0, we can reach any multiple of gcd(a,b).\n    # If we are at position `pos`, we can jump to `pos+a` or `pos-b`.\n    # To stay within `[0, x]`:\n    # `pos+a <= x`\n    # `pos-b >= 0`\n\n    # Let `dist[rem]` be the minimum value `v` such that `v % (a+b) == rem` and `v` is reachable from 0.\n    # This is a common pattern for finding minimum value in a congruence class.\n    # We are interested in points modulo `a+b` because `k+a` and `k-b` are `k+a mod (a+b)` and `k-b mod (a+b)`.\n    # `k+a mod (a+b)` and `k-b mod (a+b)` are related.\n    # `k+a = k - b + (a+b)`. So `k+a` and `k-b` are in the same congruence class modulo `a+b`.\n    # This means all reachable points `p` will have the same `p % gcd(a,b)`.\n    # And since 0 is reachable, all reachable points must be multiples of `gcd(a,b)`.\n\n    # Let `min_reach[r]` be the minimum number `v` such that `v % a == r` and `v` is reachable from 0.\n    # This is a standard Dijkstra-like approach.\n    # Nodes are `0, 1, ..., a-1`. Edge `r -> (r-b)%a` with weight `b`. Edge `r -> (r+a)%a = r` with weight `a`.\n    # No, the weight is not `a`. The value is `v+a`.\n    # The actual value is `v+a` or `v-b`.\n    # We want to find the set of reachable points.\n    # Let `dp[r]` be the smallest value `v` such that `v % a == r` and `v` is reachable from 0.\n    # Initialize `dp[0] = 0`, `dp[r] = infinity` for `r != 0`.\n    # Use Dijkstra:\n    # Priority queue stores `(value, remainder)`.\n    # `pq = [(0, 0)]`\n    # `dp = [float('inf')] * a`\n    # `dp[0] = 0`\n\n    # While pq is not empty:\n    #   `val, r = heappop(pq)`\n    #   If `val > dp[r]`, continue.\n    #   \n    #   Try jump `+a`: `new_val = val + a`. `new_r = r`.\n    #   If `new_val < dp[new_r]`: `dp[new_r] = new_val`. `heappush(pq, (new_val, new_r))`.\n    #   \n    #   Try jump `-b`: `new_val = val - b`. `new_r = (r - b) % a`.\n    #   If `new_val >= 0` and `new_val < dp[new_r]`: `dp[new_r] = new_val`. `heappush(pq, (new_val, new_r))`.\n\n    # This finds the minimum reachable value for each remainder modulo `a`.\n    # `min_reach[r]` will store the minimum reachable value `v` such that `v % a == r`.\n    # Any reachable value `V` must be of the form `min_reach[V % a] + k * a` for some `k >= 0`.\n    # And `V` must be non-negative.\n    # The constraint is that all intermediate points must be in `[0, x]`.\n\n    # Let's re-evaluate the definition of f(x).\n    # \"number of distinct integers the frog can reach if it never jumps on an integer outside the interval [0, x]\"\n    # This implies that for a given `x`, we can perform a BFS/DFS.\n    # Start with `S = {0}`. `Q = deque([0])`.\n    # While `Q` is not empty:\n    #   `curr = Q.popleft()`\n    #   `next_plus = curr + a`\n    #   If `next_plus <= x` and `next_plus` not in `S`:\n    #     `S.add(next_plus)`\n    #     `Q.append(next_plus)`\n    #   `next_minus = curr - b`\n    #   If `next_minus >= 0` and `next_minus` not in `S`:\n    #     `S.add(next_minus)`\n    #     `Q.append(next_minus)`\n    # `f(x) = len(S)`.\n\n    # This is too slow for `m=10^9`.\n    # The `f(x)` values are non-decreasing.\n    # For `x` large enough, specifically `x >= a+b-1`, the set of reachable points might stabilize.\n    # The crucial observation for problems like this is that if you can reach `p`, and `p >= b`,\n    # then you can jump to `p-b`. If `p-b >= 0`, you can reach `p-b`.\n    # If `p` is reachable, and `p+a <= x`, then `p+a` is reachable.\n    # If `p` is reachable, and `p-b >= 0`, then `p-b` is reachable.\n\n    # Let `reachable[k]` be true if `k` is reachable.\n    # `reachable[0] = True`.\n    # `f(x)` counts `k` such that `reachable[k]` is true and `0 <= k <= x`.\n\n    # Consider the smallest number `v` such that `v % a == r` and `v` is reachable.\n    # Let `min_val[r]` be this value.\n    # We can compute `min_val` using Dijkstra on `a` states.\n    # `min_val = [float('inf')] * a`\n    # `min_val[0] = 0`\n    # `pq = [(0, 0)]` # (value, remainder)\n\n    # `import heapq`\n    # `heapq.heappush(pq, (0, 0))`\n\n    # while pq:\n    #     val, r = heapq.heappop(pq)\n    #     if val > min_val[r]:\n    #         continue\n\n    #     # Try jump +a: new_val = val + a. new_r = r.\n    #     # This is implicitly handled by the structure of reachable points.\n    #     # If val is reachable, then val+a, val+2a, ... are also reachable.\n    #     # But we need to find the *minimum* value for each remainder.\n    #     # A direct +a jump from val to val+a doesn't change remainder.\n    #     # So min_val[r] is already the minimum for this remainder.\n    #     # We only need to consider the -b jump.\n    #     # From val, we can jump to val-b.\n    #     # new_val = val - b\n    #     # new_r = (r - b) % a\n    #     # If new_val >= 0 and new_val < min_val[new_r]:\n    #     #     min_val[new_r] = new_val\n    #     #     heapq.heappush(pq, (new_val, new_r))\n\n    # This is the standard \"shortest path on states modulo a\" problem.\n    # The states are `0, 1, ..., a-1`.\n    # From state `r`, we can reach state `(r-b)%a` with cost `b`.\n    # We can also reach state `(r+a)%a = r` with cost `a`.\n    # The cost here means the *difference* in value.\n    # `min_val[r]` = minimum non-negative value `v` such that `v % a == r` and `v` is reachable.\n    # Start with `min_val[0] = 0`, others `inf`.\n    # Use Dijkstra.\n    # `pq = [(0, 0)]` (cost, remainder)\n    # `dist = [float('inf')] * a`\n    # `dist[0] = 0`\n\n    # `while pq:`\n    # `    d, u = heapq.heappop(pq)`\n    # `    if d > dist[u]:`\n    # `        continue`\n\n    # `    # Option 1: jump +a`\n    # `    # From u, we can reach u+a. This is a \"cost\" of 'a' to reach a value in the same remainder class.\n    # `    # This doesn't change the remainder class, so it's not useful for finding min_val[r].`\n    # `    # It means if we reach u, we can also reach u+a, u+2a, ...`\n\n    # `    # Option 2: jump -b`\n    # `    # From u, we can reach u-b. The remainder is (u-b)%a.`\n    # `    # The new value is d-b. We need d-b >= 0.`\n    # `    # If d-b >= 0 and d-b < dist[(u-b)%a]:`\n    # `    #    dist[(u-b)%a] = d-b`\n    # `    #    heapq.heappush(pq, (d-b, (u-b)%a))`\n\n    # This Dijkstra only considers `d-b`. It finds the smallest non-negative `v` for each `r`.\n    # This `min_val[r]` is the smallest reachable point with remainder `r` modulo `a`.\n    # Let's call this `min_val_mod_a`.\n    # `min_val_mod_a = [float('inf')] * a`\n    # `min_val_mod_a[0] = 0`\n    # `q = collections.deque([(0, 0)])` # (value, remainder)\n    # This is a 0-1 BFS / Dijkstra variant because edge weights are constant (b) or 0 (for +a).\n    # No, it's not 0-1 BFS. The edge cost is `b`.\n    # `min_val_mod_a = [float('inf')] * a`\n    # `min_val_mod_a[0] = 0`\n    # `pq = [(0, 0)]` # (value, remainder)\n    # `import heapq`\n    # `heapq.heappush(pq, (0, 0))`\n\n    # `while pq:`\n    # `    val, r = heapq.heappop(pq)`\n    # `    if val > min_val_mod_a[r]:`\n    # `        continue`\n\n    # `    # Jump -b`\n    # `    new_r = (r - b) % a`\n    # `    new_val = val - b`\n    # `    if new_val >= 0 and new_val < min_val_mod_a[new_r]:`\n    # `        min_val_mod_a[new_r] = new_val`\n    # `        heapq.heappush(pq, (new_val, new_r))`\n\n    # `    # Jump +a (this doesn't change remainder, but it increases the value)`\n    # `    # This jump is not useful for finding the MINIMUM value for a remainder.`\n    # `    # If we have min_val_mod_a[r], then min_val_mod_a[r] + k*a are also reachable.`\n    # `    # The Dijkstra above only considers the -b jump to find the minimum value in each remainder class.`\n    # `    # This is because a +a jump from val to val+a doesn't change the remainder.`\n    # `    # So min_val_mod_a[r] is the smallest number for that remainder that can be reached by a sequence of +a and -b jumps.`\n\n    # The `min_val_mod_a` array will contain the smallest reachable value for each remainder modulo `a`.\n    # The values in `min_val_mod_a` can be up to `a*b`.\n    # Max value for `a` is `10^5`, `b` is `10^5`. So `a*b` can be `10^10`.\n    # This is too large for `min_val_mod_a` to store.\n\n    # Let's reconsider the problem constraints. `a, b <= 10^5`.\n    # The values `f(i)` are needed for `i` up to `m=10^9`.\n    # The behavior of `f(i)` changes when `i` is small.\n    # When `i` is large, `f(i)` might follow a linear pattern.\n    # The \"stabilization point\" for these problems is often `a+b-1` or `a*b` or `lcm(a,b)`.\n    # The crucial observation is that if we can reach `p`, then we can reach `p+a` (if `p+a <= x`)\n    # and `p-b` (if `p-b >= 0`).\n    # If `p` is reachable, and `p >= b`, then `p-b` is reachable.\n    # If `p` is reachable, and `p+a <= x`, then `p+a` is reachable.\n    #\n    # The set of all possible reachable points (without `x` constraint) is `k*gcd(a,b)` for `k >= 0`.\n    # With the `[0, x]` constraint, we are interested in a subset of these.\n    #\n    # Let `dp[i]` be true if `i` is reachable.\n    # `dp[0] = True`.\n    # `q = collections.deque([0])`\n    # `max_reach_val = 0`\n    # `reachable_set = {0}`\n    # `f_values = [0] * (max_dp_range + 1)`\n    # `f_values[0] = 1`\n\n    # This is the actual BFS that computes `f(i)` for `i` up to `max_dp_range`.\n    # The `max_dp_range` should be large enough to cover the \"small\" values.\n    # A good bound for the \"small\" values is `a+b-1`.\n    # Why `a+b-1`? Because if `k` is reachable and `k >= b`, then `k-b` is reachable.\n    # If we are at a point `p >= b`, and we want to reach `p+a`, we can do `p -> p-b -> p-b+a -> p-b+a-b ...`\n    # The values `0, ..., a+b-1` are usually the \"critical\" range.\n    # Let `max_bfs_limit = a + b - 1`. If `m` is smaller, use `m`.\n    \n    limit_for_bfs = min(m, a + b - 1) # A safe upper bound for BFS\n    \n    reachable_in_bfs = [False] * (limit_for_bfs + 1)\n    reachable_in_bfs[0] = True\n    q = collections.deque([0])\n    \n    current_f = 0 # Number of reachable points found so far\n    \n    # Precompute f(i) for i up to limit_for_bfs\n    for i in range(limit_for_bfs + 1):\n        # When we compute f(i), we need to know all points reachable within [0, i].\n        # This means all points `p` such that `p` is reachable by jumps within `[0, i]`.\n        # This is not exactly a standard BFS. The `x` constraint changes for each `f(x)`.\n        # We need to find `f(i)` for `i=0, ..., m`.\n\n        # Let's use the min_val_mod_a approach, but correctly.\n        # `min_reach[r]` = minimum value `v` such that `v % a == r` and `v` is reachable from 0.\n        # This `v` means `v` can be reached by a sequence of +a and -b jumps, where all intermediate points\n        # are non-negative. We don't consider the upper bound `x` here.\n        \n        # This `min_reach` array is computed using Dijkstra on `a` states.\n        # States are `0, 1, ..., a-1`.\n        # From state `r`, we can go to `(r-b)%a` with cost `b`.\n        # `min_reach[r]` is the minimum value in that congruence class.\n        # `dist = [float('inf')] * a`\n        # `dist[0] = 0`\n        # `pq = [(0, 0)]`\n        # `import heapq`\n        # `heapq.heappush(pq, (0, 0))`\n        \n        # `while pq:`\n        # `    d, u = heapq.heappop(pq)`\n        # `    if d > dist[u]:`\n        # `        continue`\n        # `    # Jump -b`\n        # `    new_r = (u - b) % a`\n        # `    new_d = d - b`\n        # `    if new_d >= 0 and new_d < dist[new_r]:`\n        # `        dist[new_r] = new_d`\n        # `        heapq.heappush(pq, (new_d, new_r))`\n        # This finds the smallest non-negative value for each remainder modulo `a`.\n        # The values in `dist` can be up to `a*b`. Max `10^5 * 10^5 = 10^10`. This is too large.\n        # The values in `dist` are actually bounded by `a+b-1` for the \"small\" values.\n        # Or, the maximum value in `dist` is `a*b/gcd(a,b) - a - b`. No, this is for Frobenius coin problem.\n        # For this problem, the maximum value in `dist` is `a+b-1` if `gcd(a,b)=1`.\n        # If `gcd(a,b) = g`, then all values are multiples of `g`.\n        # `dist[r]` stores the minimum `v` such that `v % a == r` and `v` is reachable.\n        # The maximum value in `dist` is bounded by `a * b / gcd(a,b)`.\n        # No, it's bounded by `a + b - 1` if `gcd(a,b) = 1`.\n        # For general `gcd(a,b) = g`, it's bounded by `(a/g + b/g - 1) * g`.\n        # This can be up to `(10^5 + 10^5 - 1) * 10^5` if `g=1`. No, this is wrong.\n        # It's bounded by `a * (b/g)`. Max `10^5 * 10^5 = 10^10`. This is the problem.\n\n        # The `min_val_mod_a` values are actually bounded by `a+b-1`.\n        # If `v` is reachable, then `v+a` is reachable.\n        # If `v` is reachable and `v >= b`, then `v-b` is reachable.\n        # If we can reach `p`, we can reach `p+k*a` for any `k >= 0`.\n        # So `min_val_mod_a[r]` is the smallest `p` such that `p % a == r` and `p` is reachable.\n        # Any other reachable point `p'` with `p' % a == r` must be `p + k*a` for some `k >= 0`.\n        # This means that all points `min_val_mod_a[r], min_val_mod_a[r]+a, min_val_mod_a[r]+2a, ...`\n        # are reachable (ignoring the `x` constraint for now).\n        # The maximum value in `min_val_mod_a` is `a+b-1`. This is a known result for `gcd(a,b)=1`.\n        # If `gcd(a,b) = g`, then the maximum value in `min_val_mod_a` is `(a/g + b/g - 1) * g`.\n        # This is still too large.\n\n    # Let's use the BFS approach for small `x`.\n    # The `f(x)` values are not just about `x` itself, but about the interval `[0, x]`.\n    # A point `p` is reachable for a given `x` if there is a path `0 = p_0, p_1, ..., p_k = p`\n    # such that `0 <= p_j <= x` for all `j`.\n    # This is a standard BFS where the `x` acts as a hard boundary.\n    # The number of states is `m+1`. Max `10^9`. Too slow.\n\n    # The behavior of `f(x)` changes when `x` is large enough.\n    # For `x >= a+b-1`, `f(x)` becomes `f(x-1) + 1` or `f(x-1)`.\n    # The `f(x)` function will be `f(x) = C + floor(x/g)` for large `x`.\n    # No, it's `f(x) = C + (x-K)/g` for `x >= K`.\n    # Let `g = gcd(a,b)`. All reachable points are multiples of `g`.\n    # So `f(x)` counts `k*g` such that `k*g` is reachable within `[0, x]`.\n\n    # Let `dp[i]` be the minimum number of +a jumps needed to reach `i` without going below 0.\n    # This is useful for the \"never jumps outside [0, x]\" constraint.\n    # `dp[i]` is the minimum `k` such that `i = k*a - l*b` for some `l >= 0`, and all intermediate points are >= 0.\n    # This is essentially the same as `min_val_mod_a` but we need to track `k`.\n\n    # Let `min_pos[r]` be the minimum value `v` such that `v % a == r` and `v` is reachable from 0.\n    # This is bounded by `a+b-1` (when `gcd(a,b)=1`).\n    # If `gcd(a,b) = g`, then `min_pos[r]` is `g * (min_pos_norm[r/g])`\n    # where `min_pos_norm` is for `a/g, b/g`.\n    # The maximum value in `min_pos` will be `(a/g + b/g - 1) * g`.\n    # This value is `lcm(a,b) - a - b` (for `gcd(a,b)=1`).\n    # No, it's `a*b/g - a - b`.\n    # The largest value that cannot be expressed as `k*a + l*b` (Frobenius number) is `a*b - a - b`.\n    # But here we have `k*a - l*b`.\n    # The largest number not reachable using `+a` and `-b` (staying non-negative) is `a+b-1`.\n    # This is a well-known result from the coin problem if we consider `a` and `b` as costs.\n    # The maximum value in `min_pos` is `a+b-1`. This is for `a,b` coprime.\n    # If `gcd(a,b) = g`, then `min_pos[r]` is `(a/g + b/g - 1) * g` for `r` that are multiples of `g`.\n    # The values `min_pos[r]` can be up to `2 * 10^5`. This is manageable!\n\n    # Let `min_pos[r]` be the minimum value `v` such that `v >= 0`, `v % a == r`, and `v` is reachable from 0\n    # (without any upper bound `x`).\n    \n    min_pos = [float('inf')] * a\n    min_pos[0] = 0\n    q = collections.deque([0]) # Stores values, not (value, remainder)\n    \n    # BFS to find min_pos[r] for all r.\n    # We only care about `v % a`.\n    # If `curr` is reachable, then `curr+a` is reachable. `(curr+a)%a == curr%a`.\n    # If `curr` is reachable and `curr >= b`, then `curr-b` is reachable. `(curr-b)%a`.\n    \n    # The BFS should be on `remainder` states.\n    # `dist[r]` = min value `v` such that `v % a == r` and `v` is reachable.\n    # This is a Dijkstra.\n    \n    # `min_val_for_rem = [float('inf')] * a`\n    # `min_val_for_rem[0] = 0`\n    # `pq = [(0, 0)]` # (value, remainder)\n    # `import heapq`\n    # `heapq.heappush(pq, (0, 0))`\n    \n    # `while pq:`\n    # `    val, r = heapq.heappop(pq)`\n    # `    if val > min_val_for_rem[r]:`\n    # `        continue`\n            \n    # `    # Try jump -b`\n    # `    new_r = (r - b) % a`\n    # `    new_val = val - b`\n    # `    if new_val >= 0 and new_val < min_val_for_rem[new_r]:`\n    # `        min_val_for_rem[new_r] = new_val`\n    # `        heapq.heappush(pq, (new_val, new_r))`\n            \n    # The max value in `min_val_for_rem` is `a+b-1` (when `gcd(a,b)=1`).\n    # If `gcd(a,b)=g`, then `min_val_for_rem[r]` is defined only for `r` that are multiples of `g`.\n    # And for those `r`, `min_val_for_rem[r]` is `g * (min_val_for_rem_normalized[r/g])`.\n    # The maximum value in `min_val_for_rem` is `(a/g + b/g - 1) * g`.\n    # Max value of `a/g` is `a`. Max value of `b/g` is `b`.\n    # So max value is `(a+b-1) * g`. No, this is wrong.\n    # The values in `min_val_for_rem` are at most `a+b-1`.\n    # This is because if `v >= a+b`, then we can always express `v` as `v = k*a - l*b`\n    # and `v-b` is also reachable.\n    # The values in `min_val_for_rem` are bounded by `a+b-1`. This is a crucial fact.\n    # So `min_val_for_rem` values are at most `2*10^5`. This is feasible.\n\n    # Let `min_val_for_rem[r]` be the smallest reachable non-negative integer `v` such that `v % a == r`.\n    min_val_for_rem = [float('inf')] * a\n    min_val_for_rem[0] = 0\n    \n    q_dijkstra = collections.deque([(0, 0)]) # (value, remainder)\n    \n    while q_dijkstra:\n        val, r = q_dijkstra.popleft() # Using deque as a BFS queue, assuming weights are uniform (b)\n                                     # This is actually a 0-1 BFS style, but weights are 'b'.\n                                     # So it should be Dijkstra with a priority queue.\n                                     # Let's use a standard Dijkstra.\n    \n    # Re-doing Dijkstra with `heapq`\n    import heapq\n    min_val_for_rem = [float('inf')] * a\n    min_val_for_rem[0] = 0\n    pq = [(0, 0)] # (value, remainder)\n    \n    while pq:\n        val, r = heapq.heappop(pq)\n        \n        if val > min_val_for_rem[r]:\n            continue\n            \n        # Try jump -b\n        new_r_minus = (r - b) % a\n        new_val_minus = val - b\n        if new_val_minus >= 0 and new_val_minus < min_val_for_rem[new_r_minus]:\n            min_val_for_rem[new_r_minus] = new_val_minus\n            heapq.heappush(pq, (new_val_minus, new_r_minus))\n\n    # Now `min_val_for_rem[r]` contains the smallest non-negative value `v` such that `v % a == r` and `v` is reachable.\n    # Any reachable point `P` such that `P % a == r` must be of the form `min_val_for_rem[r] + k*a` for some `k >= 0`.\n    # We need to sum `f(i)` for `i=0` to `m`.\n    # `f(i)` is the count of reachable points `p` such that `0 <= p <= i`.\n    #\n    # The set of all reachable points is `S_all = { min_val_for_rem[r] + k*a | r in [0, a-1], k >= 0, min_val_for_rem[r] != inf }`.\n    # For a given `i`, `f(i)` is the count of points `p` in `S_all` such that `p <= i`.\n    #\n    # Let's calculate `f(i)` for `i` up to `max_val_in_min_val_for_rem + a`.\n    # The maximum value in `min_val_for_rem` is `max_min_val`.\n    # `max_min_val = max(v for v in min_val_for_rem if v != float('inf'))`.\n    # The `max_min_val` is bounded by `a+b-1`. So `max_min_val` is at most `2 * 10^5 - 1`.\n    \n    # We need `f(i)` for `i` up to `m`.\n    # Let `prefix_counts[k]` be the number of reachable points `p <= k`.\n    # We can compute `prefix_counts` up to `max_min_val + a` (or `m` if `m` is smaller).\n    \n    # Collect all `min_val_for_rem` values that are finite.\n    reachable_base_points = sorted([v for v in min_val_for_rem if v != float('inf')])\n    \n    # Calculate `f(i)` for `i` up to `min(m, a+b+a-1)` (or some similar bound where the pattern starts).\n    # The pattern for `f(i)` becomes simple when `i` is large enough.\n    # For `i >= max(min_val_for_rem) + a`, `f(i)` increases by `1` for every `g = gcd(a,b)` steps.\n    # No, for `i >= max(min_val_for_rem)`, every `a` steps, `f(i)` increases by `a/g` or `1`.\n    # Let's count the number of reachable points up to `i`.\n    \n    # `f_val_arr[i]` stores `f(i)`.\n    # The max value `max_consider_i` for explicit calculation of `f(i)` is `a + b - 1 + a` (approx `3 * 10^5`).\n    # Or, `max(min_val_for_rem) + a`.\n    # Let `max_explicit_i = min(m, a + b + a - 1)`.\n    # If `m` is small, `max_explicit_i` is `m`.\n    \n    # Let's count how many reachable points `p` satisfy `p <= i`.\n    # `count_reachable_up_to[k]` = number of reachable points `p <= k`.\n    # `count_reachable_up_to` array will be computed up to `min(m, a+b+a-1)`.\n    \n    # `actual_reachable_points` will store all reachable points up to `max_explicit_i`.\n    \n    # First, collect all points `min_val_for_rem[r] + k*a` that are `<= max_explicit_i`.\n    \n    # Max value in `min_val_for_rem` is `max_base_val`.\n    max_base_val = 0\n    for val in min_val_for_rem:\n        if val != float('inf'):\n            max_base_val = max(max_base_val, val)\n            \n    # The threshold `K` where the pattern stabilizes is `max_base_val`.\n    # For `i >= max_base_val`, for each `r`, `min_val_for_rem[r] + k*a <= i` means `k*a <= i - min_val_for_rem[r]`.\n    # So `k <= (i - min_val_for_rem[r]) / a`.\n    # The number of such `k` is `floor((i - min_val_for_rem[r]) / a) + 1`.\n    \n    # Let `K_stable = max_base_val`.\n    # For `i < K_stable`, we need to compute `f(i)` explicitly.\n    # For `i >= K_stable`, `f(i)` can be computed by a formula.\n    \n    # `max_K_stable = max(min_val_for_rem)`\n    # The values in `min_val_for_rem` are bounded by `a+b-1`.\n    # So `K_stable` is at most `a+b-1`.\n    # The range `[0, K_stable + a - 1]` is where we need to be careful.\n    # Let `limit_i = min(m, K_stable + a - 1)`.\n    # This `limit_i` is at most `m` and at most `(a+b-1) + a - 1` approx `3*10^5`.\n    \n    f_values_explicit = [0] * (min(m, max_base_val + a) + 1)\n    \n    # Fill `f_values_explicit`\n    # `num_reachable_points_up_to_i[i]` = count of reachable points `p <= i`.\n    \n    # Create a boolean array `is_reachable` up to `max_base_val + a`\n    # This array tracks actual reachable points within the range.\n    is_reachable_upto_limit = [False] * (min(m, max_base_val + a) + 1)\n    \n    for r in range(a):\n        if min_val_for_rem[r] == float('inf'):\n            continue\n        \n        start_point = min_val_for_rem[r]\n        \n        # All points `start_point + k*a` are reachable.\n        # Mark them in `is_reachable_upto_limit`.\n        k = 0\n        while True:\n            current_point = start_point + k * a\n            if current_point > min(m, max_base_val + a):\n                break\n            is_reachable_upto_limit[current_point] = True\n            k += 1\n            \n    current_count = 0\n    for i in range(len(f_values_explicit)):\n        if is_reachable_upto_limit[i]:\n            current_count += 1\n        f_values_explicit[i] = current_count\n        ans += f_values_explicit[i]\n\n    # Now `ans` contains `sum_{i=0}^{limit_i} f(i)`.\n    # We need to calculate `sum_{i=limit_i+1}^{m} f(i)`.\n    \n    # For `i > max_base_val`:\n    # `f(i)` = sum over `r` of `(floor((i - min_val_for_rem[r]) / a) + 1)`\n    # for `min_val_for_rem[r] <= i`.\n    # This sum is constant for `r` where `min_val_for_rem[r]` is defined.\n    \n    # Let `N_reachable_base = len(reachable_base_points)`.\n    # For `i >= max_base_val`, all `min_val_for_rem[r]` are `<= i`.\n    # So `f(i) = sum_{r | min_val_for_rem[r] != inf} (floor((i - min_val_for_rem[r]) / a) + 1)`\n    # `f(i) = sum_{r | min_val_for_rem[r] != inf} (floor((i - min_val_for_rem[r]) / a)) + N_reachable_base`\n    # `f(i) = N_reachable_base + sum_{r | min_val_for_rem[r] != inf} floor((i - min_val_for_rem[r]) / a)`\n    \n    # Let `num_base_points = 0`\n    # `sum_base_points = 0`\n    # for val in min_val_for_rem:\n    #     if val != float('inf'):\n    #         num_base_points += 1\n    #         sum_base_points += val\n    \n    # For `i >= max_base_val`:\n    # `f(i) = num_base_points + sum_{r | min_val_for_rem[r] != inf} floor((i - min_val_for_rem[r]) / a)`\n    # `f(i) = num_base_points + sum_{r | min_val_for_rem[r] != inf} ( (i - min_val_for_rem[r]) // a )`\n    # This `floor` is integer division.\n    \n    # `f(i) = num_base_points + (num_base_points * i - sum_base_points) // a`\n    # This is correct if `i - min_val_for_rem[r]` is always positive.\n    # This is true for `i >= max_base_val`.\n    \n    # The sum `sum_{i=limit_i+1}^{m} f(i)` needs to be calculated.\n    \n    # The formula `f(i) = num_base_points + (num_base_points * i - sum_base_points) // a` is valid for `i >= max_base_val`.\n    # Let `start_sum_i = len(f_values_explicit)`.\n    # We need to sum from `start_sum_i` to `m`.\n    \n    if m < len(f_values_explicit) - 1: # if m is fully covered by explicit calculation\n        print(ans)\n        return\n        \n    start_sum_i = len(f_values_explicit)\n    \n    num_base_points = 0\n    sum_base_points = 0\n    for val in min_val_for_rem:\n        if val != float('inf'):\n            num_base_points += 1\n            sum_base_points += val\n            \n    # Sum `f(i)` for `i` from `start_sum_i` to `m`.\n    # `f(i) = num_base_points + (num_base_points * i - sum_base_points) // a`\n    # This can be written as `C1 + C2 * i // a` where `C1 = num_base_points` and `C2 = num_base_points`.\n    # No, it's `num_base_points + floor(i/a * num_base_points - sum_base_points/a)`.\n    # This is `num_base_points + floor((num_base_points * i - sum_base_points) / a)`.\n    \n    # We need to sum `num_base_points + floor((num_base_points * i - sum_base_points) / a)` for `i` from `start_sum_i` to `m`.\n    \n    # Let `A_val = num_base_points`, `B_val = num_base_points`, `C_val = sum_base_points`.\n    # We need to sum `A_val + floor((B_val * i - C_val) / a)`.\n    # This is `A_val * (m - start_sum_i + 1) + sum_{i=start_sum_i}^m floor((B_val * i - C_val) / a)`.\n    \n    # The sum `sum_{i=L}^R floor((P*i + Q)/D)` can be computed using `floor_sum` function.\n    # Here `P=B_val`, `Q=-C_val`, `D=a`.\n    \n    # `floor_sum(n, m, a, b)` computes `sum_{i=0}^{n-1} floor((a*i+b)/m)`.\n    # We need `sum_{i=start_sum_i}^{m} floor((num_base_points * i - sum_base_points) / a)`.\n    # Let `i' = i - start_sum_i`. Then `i = i' + start_sum_i`.\n    # Sum `i'=0` to `m - start_sum_i`: `floor((num_base_points * (i' + start_sum_i) - sum_base_points) / a)`\n    # `floor((num_base_points * i' + num_base_points * start_sum_i - sum_base_points) / a)`\n    # `floor((P*i' + Q') / D)` where `P = num_base_points`, `Q' = num_base_points * start_sum_i - sum_base_points`, `D = a`.\n    # `n = m - start_sum_i + 1`.\n    \n    def floor_sum(n, m, a_coeff, b_coeff):\n        # Computes sum_{i=0}^{n-1} floor((a_coeff*i + b_coeff) / m)\n        res = 0\n        if n == 0:\n            return 0\n        \n        if a_coeff >= m:\n            res += (n - 1) * n // 2 * (a_coeff // m)\n            a_coeff %= m\n        if b_coeff >= m:\n            res += n * (b_coeff // m)\n            b_coeff %= m\n            \n        y_max = (a_coeff * (n - 1) + b_coeff) // m\n        if y_max == 0:\n            return res\n            \n        x_max = y_max * m - b_coeff\n        res += (n - (x_max + a_coeff - 1) // a_coeff) * y_max\n        res += floor_sum(y_max, a_coeff, m, (a_coeff - x_max % a_coeff) % a_coeff)\n        return res\n    \n    if m >= start_sum_i:\n        num_terms_in_sum = m - start_sum_i + 1\n        \n        # Add `num_base_points * num_terms_in_sum`\n        ans += num_base_points * num_terms_in_sum\n        \n        # Add `sum_{i=start_sum_i}^m floor((num_base_points * i - sum_base_points) / a)`\n        # `P = num_base_points`, `Q = num_base_points * start_sum_i - sum_base_points`, `D = a`.\n        \n        P = num_base_points\n        Q_prime = num_base_points * start_sum_i - sum_base_points\n        D = a\n        N = num_terms_in_sum # m - start_sum_i + 1\n        \n        ans += floor_sum(N, D, P, Q_prime)\n\n    print(ans)\n\nsolve()"}
{"task_id": "E2H_CF980E", "completion": "import sys\n\nsys.setrecursionlimit(10**6)\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # We want to keep n - k contestants.\n    # The total number of fans is sum(2^i) for kept districts.\n    # To maximize this, we should keep districts with larger indices.\n    # The problem is to find a connected subgraph of size n-k with maximum sum of 2^i.\n    # This is equivalent to finding a connected subgraph of size n-k that contains the largest possible indices.\n    # Or, equivalently, remove k nodes such that the remaining n-k nodes form a connected component\n    # and the sum of 2^i for removed nodes is minimized.\n    # This means we should remove nodes with smaller indices.\n\n    # We want to remove k nodes.\n    # The strategy is to keep the largest possible indices.\n    # We will try to keep node n, then n-1, then n-2, and so on, as long as they can form a connected component\n    # of size n-k.\n\n    # Let's rephrase: we need to select a connected component of size (n-k) such that the sum of 2^i is maximized.\n    # This implies we want to keep nodes with large indices.\n    # Consider the nodes in decreasing order of their index: n, n-1, n-2, ..., 1.\n    # We want to keep as many of the largest indexed nodes as possible.\n    # If we decide to keep a set of nodes, say S, they must form a connected component.\n    # The total number of nodes to keep is N_keep = n - k.\n\n    # The most \"valuable\" node is n, then n-1, etc.\n    # We want to keep the N_keep most valuable nodes that can form a connected component.\n    # This is equivalent to finding the connected component of size N_keep that contains the node with the largest index.\n    # If there are multiple such components, pick the one with the largest sum of indices.\n    # This is a bit tricky.\n\n    # Let's consider the nodes we must remove. We must remove k nodes.\n    # To maximize sum(2^i), we should remove nodes with the smallest indices.\n    # We want to find a connected component of size n-k.\n    # The nodes that are *not* in this component are the k nodes we remove.\n    # We want to pick the k nodes to remove such that their indices are as small as possible.\n    # This means we try to remove 1, then 2, then 3, ... as long as the remaining graph stays connected\n    # and has size n-k.\n\n    # Let's try a greedy approach:\n    # We want to keep n-k nodes.\n    # We want to remove k nodes.\n    # To maximize sum(2^i), we should remove nodes with small indices.\n    # Let's maintain a set of nodes to be kept, initially all nodes.\n    # Iterate from node 1 up to n. If we can remove node i without disconnecting the remaining graph\n    # and we still need to remove more nodes, then remove node i.\n\n    # This is a classic problem that can be solved by finding the \"centroid\" or by\n    # a greedy approach on the nodes sorted by some criteria.\n    # Here, the criteria is the node index. We want to remove nodes with small indices.\n\n    # Let's try to identify the set of (n-k) nodes to keep.\n    # We want to keep the largest possible indices.\n    # What if we start from node N and try to build a component of size n-k?\n    # This seems like a good approach:\n    # The node N is always a good candidate to keep.\n    # Let's try to keep node N. Then we need to keep (n-k-1) more nodes.\n    # We want to pick these from N-1, N-2, ...\n    # This sounds like a variation of finding a path/component with max sum.\n\n    # Consider the nodes in decreasing order: n, n-1, ..., 1.\n    # We want to select n-k nodes.\n    # We want to select node n.\n    # What if we root the tree at an arbitrary node, say 1?\n    # Or, root the tree at the \"most valuable\" node we are sure to keep, which is N.\n\n    # Let's try to determine the nodes to remove.\n    # We must remove exactly k nodes.\n    # To maximize the sum of 2^i for kept nodes, we should remove nodes with the smallest indices.\n    # We want to remove nodes 1, 2, 3, ... as much as possible, as long as the remaining graph of size n-k is connected.\n\n    # We can use a Disjoint Set Union (DSU) or a similar structure to keep track of connectivity.\n    # Or, we can use a \"pruning\" approach.\n    # Start with all nodes. We want to remove k nodes.\n    # We iterate through nodes from 1 to n.\n    # For each node i, if we can remove it (i.e., it's a leaf in the current graph, or removing it doesn't disconnect the desired component)\n    # and we still need to remove more nodes, we remove it.\n\n    # The condition \"remaining graph stays connected\" is key.\n    # If we remove a node, it must not split the desired component.\n    # This means we must remove \"leaves\" of the desired component.\n    # The nodes we remove are those that are \"farthest\" from the \"center\" of the desired component,\n    # and have small indices.\n\n    # Let's consider the nodes in increasing order of index: 1, 2, ..., n.\n    # We want to remove k nodes.\n    # We iterate from i = 1 to n.\n    # If node i is a \"leaf\" of the current set of nodes we are considering keeping,\n    # and we still need to remove nodes, we remove i.\n    # What defines a \"leaf\" in this context? A node that has only one neighbor *among the nodes we are currently keeping*.\n\n    # This is a standard approach for this type of problem:\n    # 1. Initialize a set of nodes to keep: all nodes {1, ..., n}.\n    # 2. Maintain a count of nodes to remove: `k_to_remove = k`.\n    # 3. Maintain the degree of each node *within the set of kept nodes*.\n    # 4. Use a queue for nodes that are \"removable candidates\" (e.g., degree 1).\n    # 5. Add all nodes with degree 1 (leaves of the initial tree) to the queue.\n    # 6. Process the queue:\n    #    When we extract node `u` from the queue:\n    #    If `k_to_remove > 0`:\n    #        Mark `u` as removed.\n    #        Decrement `k_to_remove`.\n    #        For each neighbor `v` of `u`:\n    #            Decrement `v`'s degree in the kept set.\n    #            If `v`'s degree becomes 1 and `v` is not marked as removed, add `v` to the queue.\n    #    Else (k_to_remove == 0):\n    #        Stop. We have removed enough nodes.\n\n    # The problem with the above greedy approach is that it removes nodes based on their current degree 1,\n    # not necessarily based on their index. We want to remove nodes with *small* indices first.\n    # So, we should use a min-priority queue for the removable candidates, ordered by node index.\n\n    # Algorithm:\n    # 1. Initialize `removed_nodes` set to empty.\n    # 2. Initialize `current_degree[u]` for each `u` to its degree in the original tree.\n    # 3. Initialize a min-priority queue `pq`.\n    # 4. For each node `u` from 1 to `n`:\n    #    If `current_degree[u] == 1`:\n    #        Add `u` to `pq` (priority is `u`'s index).\n\n    # 5. While `k > 0` and `pq` is not empty:\n    #    Extract `u` with the smallest index from `pq`.\n    #    If `u` is already marked as removed (this shouldn't happen if we manage `removed_nodes` correctly, but good to check):\n    #        Continue.\n\n    #    Mark `u` as removed.\n    #    Add `u` to `removed_nodes`.\n    #    `k -= 1`.\n\n    #    For each neighbor `v` of `u`:\n    #        If `v` is not in `removed_nodes`:\n    #            `current_degree[v] -= 1`.\n    #            If `current_degree[v] == 1`:\n    #                Add `v` to `pq`.\n\n    # 6. The nodes in `removed_nodes` are the ones to remove. Print them in increasing order.\n\n    # Let's trace this with an example.\n    # N=6, K=3\n    # Edges: (2,1), (2,6), (4,2), (5,6), (2,3)\n    # Adjacency list:\n    # 1: [2]\n    # 2: [1, 6, 4, 3]\n    # 3: [2]\n    # 4: [2]\n    # 5: [6]\n    # 6: [2, 5]\n\n    # Initial degrees:\n    # deg[1]=1\n    # deg[2]=4\n    # deg[3]=1\n    # deg[4]=1\n    # deg[5]=1\n    # deg[6]=2\n\n    # Initial pq: [ (1, 1), (3, 1), (4, 1), (5, 1) ] (node, degree)\n    # (using tuples for pq elements, (index, degree) or just index if degree is always 1 for pq)\n    # Let's just store the index in pq.\n\n    # removed_nodes = set()\n    # current_degree = [0, 1, 4, 1, 1, 1, 2] (index 0 unused)\n    # pq = min-heap: [1, 3, 4, 5]\n    # k = 3\n\n    # Iteration 1:\n    # Pop 1 from pq.\n    # removed_nodes = {1}\n    # k = 2\n    # Neighbor of 1 is 2.\n    # current_degree[2] = 4 - 1 = 3.\n    # 2's degree is not 1, so don't add to pq.\n    # pq = [3, 4, 5]\n\n    # Iteration 2:\n    # Pop 3 from pq.\n    # removed_nodes = {1, 3}\n    # k = 1\n    # Neighbor of 3 is 2.\n    # current_degree[2] = 3 - 1 = 2.\n    # 2's degree is not 1, so don't add to pq.\n    # pq = [4, 5]\n\n    # Iteration 3:\n    # Pop 4 from pq.\n    # removed_nodes = {1, 3, 4}\n    # k = 0\n    # Neighbor of 4 is 2.\n    # current_degree[2] = 2 - 1 = 1.\n    # current_degree[2] is now 1. Add 2 to pq.\n    # pq = [2, 5] (or [5, 2] depending on implementation, but 2 has higher priority)\n\n    # k is now 0. Stop.\n    # Removed nodes: {1, 3, 4}.\n    # Output: 1 3 4. This matches the example!\n\n    # This greedy strategy seems correct.\n    # The intuition is that to keep a connected component of size N-K with maximal sum of 2^i,\n    # we should remove nodes with minimal indices.\n    # When removing nodes, we must ensure the remaining N-K nodes form a connected component.\n    # This means we cannot remove an articulation point if it would split the desired component.\n    # By only removing \"leaves\" (nodes with degree 1 in the current subgraph), we guarantee that\n    # the remaining graph stays connected.\n    # When a node `u` is removed, its neighbors `v` have their effective degree decreased.\n    # If a neighbor `v` then becomes a leaf (degree 1), it becomes a candidate for removal.\n    # By using a min-priority queue on node index, we prioritize removing the smallest indexed leaves.\n    # This ensures that we remove the k \"least valuable\" nodes that are \"on the periphery\" of the desired component.\n\n    # Implementation details:\n    # Use `collections.deque` for a regular queue if we don't need priority, but here we need `heapq`.\n    import heapq\n\n    current_degree = [0] * (n + 1)\n    for u in range(1, n + 1):\n        current_degree[u] = len(adj[u])\n\n    pq = []\n    for u in range(1, n + 1):\n        if current_degree[u] == 1:\n            heapq.heappush(pq, u)\n\n    removed_nodes = [False] * (n + 1)\n    removed_count = 0\n    result_nodes = []\n\n    while removed_count < k and pq:\n        u = heapq.heappop(pq)\n\n        if removed_nodes[u]: # Already processed, maybe added multiple times if degree changed and then changed back\n            continue\n\n        removed_nodes[u] = True\n        result_nodes.append(u)\n        removed_count += 1\n\n        for v in adj[u]:\n            if not removed_nodes[v]:\n                current_degree[v] -= 1\n                if current_degree[v] == 1:\n                    heapq.heappush(pq, v)\n\n    result_nodes.sort()\n    sys.stdout.write(\" \".join(map(str, result_nodes)) + \"\\n\")\n\nsolve()"}
{"task_id": "E2H_CF1709F", "completion": "import sys\n\nMOD = 998244353\n\ndef solve():\n    n, k, f = map(int, sys.stdin.readline().split())\n\n    max_possible_size = k * (1 << (n - 1))\n\n    if f > max_possible_size:\n        print(0)\n        return\n\n    dp = [[0] * (max_possible_size + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        new_dp = [0] * (max_possible_size + 1)\n        for prev_sum in range(max_possible_size + 1):\n            if dp[i][prev_sum] == 0:\n                continue\n            for c_val in range(k + 1):\n                current_sum = prev_sum + c_val * (1 << (n - 1 - i))\n                if current_sum <= max_possible_size:\n                    new_dp[current_sum] = (new_dp[current_sum] + dp[i][prev_sum]) % MOD\n        dp[i+1] = new_dp\n\n    ans = dp[n][f]\n    print(ans)\n\nif __name__ == '__main__':\n    solve()"}
